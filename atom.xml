<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>原力小站</title>
  
  <subtitle>扎导的原版正联出了吗？</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://Bithub00.com/"/>
  <updated>2019-08-07T12:00:22.361Z</updated>
  <id>http://Bithub00.com/</id>
  
  <author>
    <name>Mr.shuan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>RUC与AOC</title>
    <link href="http://Bithub00.com/2019/08/07/ROC%E4%B8%8EAUC/"/>
    <id>http://Bithub00.com/2019/08/07/ROC与AUC/</id>
    <published>2019-08-07T07:38:52.547Z</published>
    <updated>2019-08-07T12:00:22.361Z</updated>
    
    <content type="html"><![CDATA[<p>用本文记录自己对ROC曲线与AUC值的学习和理解<br><a id="more"></a></p><h3 id="ROC曲线定义"><a href="#ROC曲线定义" class="headerlink" title="ROC曲线定义"></a>ROC曲线定义</h3><p>ROC曲线与AUC值常被用来评价一个二分类器的好坏，以下内容出自项亮《推荐系统实践》的“分类问题”一节：</p><blockquote><p>对于二类分类问题常用的评价指标是精确率(precision)和召回率(recall)，通常以关注的类为正类，其他类为负类，分类器可将实例分成正类(positive)和负类(negative)，预测时会出现4种情况：  </p><ul><li>TP (True Positice)——将正类预测为正类数</li><li>FN (False Negative)——将正类预测为负类数</li><li>FP (False Positive)——将负类预测为正类数</li><li>TN (True Negative)——将负类预测为负类数  </li></ul><p>精确率定义为</p><script type="math/tex; mode=display">P =\frac{TP}{TP + FP}</script><p>召回率定义为</p><script type="math/tex; mode=display">R =\frac{TP}{TP + FN}</script></blockquote><p>而ROC曲线与上面的定义有关，FPR(False Positive Rate)为x轴，它以TPR(True Positive Rate)为y轴，它们的定义分别为：</p><script type="math/tex; mode=display">\begin{aligned}TPR & = \frac{TP}{TP+FN} \\FPR & =1-\frac{TN}{TN+FP} \\& = \frac{FP}{TN+FP}\end{aligned}</script><p>可以看到，TPR与召回率的定义是一样的，直观理解是：</p><ul><li>横坐标：伪正类率(False positive rate， FPR)，<strong>预测为正但实际为负</strong>的样本占所有<strong>负例样本</strong>的比例；</li><li>纵坐标：真正类率(True positive rate， TPR)，<strong>预测为正且实际为正</strong>的样本占所有<strong>正例样本</strong>的比例。</li></ul><p>其实ROC的曲线的横坐标和纵坐标是没有相关性的，不能把ROC曲线当成函数曲线来分析，应该把它看成无数个点，每个点都代表一个分类器，其横纵坐标代表了这个分类器的性能。为了更好的理解ROC曲线，引入ROC空间的概念：<br><img src="https://s2.ax1x.com/2019/08/07/eIKD5d.png" alt="ROC空间"></p><p>A,B,C,C’为四个分类器，指标如下：<br><img src="https://s2.ax1x.com/2019/08/07/eI82Mn.png" alt="分类器"></p><p>其中C’的性能最好，B的准确率为0.5，几乎是随即分类，图中左上角的点为完美分类，它代表所有的分类完全正确，分类为1的点完全正确，分类为0的点没有错误。<br>在一个二分类模型中，分类器给出每个实例为正类的概率，那么通过设定一个阈值如0.6，概率大于等于0.6的为正类，小于0.6的为负类。对应的就可以算出一组(FPR,TPR)，在平面中得到对应坐标点。随着阈值的逐渐减小，越来越多的实例被划分为正类，但是这些正类中同样也掺杂着真正的负实例，即TPR和FPR会同时增大。阈值最大时，对应坐标点为(0,0)，阈值最小时，对应坐标点(1,1)</p><p>典型的ROC曲线：<br><img src="https://s2.ax1x.com/2019/08/07/eI8jZ6.png" alt="eI8jZ6.png"></p><p>理想情况下，TPR应该接近1，FPR应该接近0。ROC曲线上的每一个点对应于一个阈值，对于一个分类器，每个阈值下会有一个TPR和FPR。比如阈值最大时，TP=FP=0，对应于原点；阈值最小时，TN=FN=1，对应于右上角的点(1,1)。</p><h3 id="绘制ROC曲线"><a href="#绘制ROC曲线" class="headerlink" title="绘制ROC曲线"></a>绘制ROC曲线</h3><p>对于一个特定的分类器和测试数据集，显然只能得到一个分类结果，即一组FPR和TPR结果，而要得到一个曲线，我们实际上需要一系列FPR和TPR的值，如何得到呢？办法就是从阈值下手。分类器的一个重要功能是“概率输出”，即表示分类器认为某个样本具有多大的概率属于正样本（或负样本）。<br>假如我们已经得到了所有样本的概率输出（属于正样本的概率），现在的问题是如何改变阈值从而得到不同的PPR和TPR结果。根据每个测试样本属于正样本的概率值从大到小排序，下图是一个示例，图中共有20个测试样本，“Class”一栏表示每个测试样本真正的标签（p表示正样本，n表示负样本），“Score”表示每个测试样本属于正样本的概率。</p><p><img src="https://s2.ax1x.com/2019/08/07/eII1PK.png" alt="eII1PK.png"></p><p>接下来从高到低，依次将“Score”值作为阈值，当测试样本属于正样本的概率大于或等于这个阈值时，我们认为它为正样本，否则为负样本。举例来说，对于图中的第4个样本，其“Score”值为0.6，那么样本1，2，3，4都被认为是正样本，因为它们的“Score”值都大于等于0.6，而其他样本则都认为是负样本。每次选取一个不同的阈值，我们就可以得到一组FPR和TPR，即ROC曲线上的一点。这样一来，我们一共得到了20组FPR和TPR的值，将它们画在ROC曲线的结果如下图：</p><p><img src="https://s2.ax1x.com/2019/08/07/eIIdat.png" alt="eIIdat.png"></p><p>当我们将阈值设置为1和0时，分别可以得到ROC曲线上的(0,0)和(1,1)两个点。将这些(FPR,TPR)对连接起来，就得到了ROC曲线。当阈值取值越多，ROC曲线越平滑。<br>其实并不一定要得到每个测试样本是正样本的概率值，只要得到这个分类器对该测试样本的“评分值”即可（评分值并不一定在(0,1)区间）。评分越高，表示分类器越肯定地认为这个测试样本是正样本，而且同时使用各个评分值作为阈值。</p><h3 id="AUC值定义"><a href="#AUC值定义" class="headerlink" title="AUC值定义"></a>AUC值定义</h3><p>AUC (Area Under Curve) 被定义为ROC曲线下的面积，这个面积的数值不会大于1。又由于ROC曲线一般都处于y=x这条直线的上方，所以AUC的取值范围一般在0.5和1之间。使用AUC值作为评价标准是因为很多时候ROC曲线并不能清晰的说明哪个分类器的效果更好，而作为一个数值，对应AUC更大的分类器效果更好。<br>将AUC值看成一个概率值，当你随机挑选一个正样本以及一个负样本，当前的分类算法根据计算得到的Score值将这个正样本排在负样本前面的概率就是AUC值。当然，AUC值越大，当前的分类算法越有可能将正样本排在负样本前面，即能够更好的分类。<br>从AUC判断分类器（预测模型）优劣的标准：  </p><ul><li>AUC = 1，完美分类器，采用这个预测模型时，存在至少一个阈值能得出完美预测。绝大多数预测的场合，不存在完美分类器。</li><li>0.5 &lt; AUC &lt; 1，优于随机猜测。这个分类器（模型）妥善设定阈值的话，能有预测价值。</li><li>AUC = 0.5，跟随机猜测一样（例：丢铜板），模型没有预测价值。</li><li>AUC &lt; 0.5，比随机猜测还差；对预测结果取反之后就优于随机猜测。</li></ul><p>三种AUC值示例：<br><img src="https://s2.ax1x.com/2019/08/07/eIILZR.png" alt="eIILZR.png"></p><h3 id="为什么用ROC曲线"><a href="#为什么用ROC曲线" class="headerlink" title="为什么用ROC曲线"></a>为什么用ROC曲线</h3><p>既然已经这么多评价标准，为什么还要使用ROC和AUC呢？因为ROC曲线有个很好的特性：当测试集中的正负样本的分布变化的时候，ROC曲线能够保持不变。在实际的数据集中经常会出现类不平衡（class imbalance）现象，即负样本比正样本多很多（或者相反），而且测试数据中的正负样本的分布也可能随着时间变化。下图是ROC曲线和Precision-Recall曲线的对比：</p><p><img src="https://s2.ax1x.com/2019/08/07/eIokdI.png" alt="eIokdI.png"></p><p>在上图中，(a)和(c)为ROC曲线，(b)和(d)为Precision-Recall曲线。(a)和(b)展示的是分类其在原始测试集（正负样本分布平衡）的结果，(c)和(d)是将测试集中负样本的数量增加到原来的10倍后，分类器的结果。可以明显的看出，ROC曲线基本保持原貌，而Precision-Recall曲线则变化较大。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://en.wikipedia.org/wiki/Receiver_operating_characteristic" target="_blank" rel="noopener">维基百科</a></li><li><a href="http://alexkong.net/2013/06/introduction-to-auc-and-roc/" target="_blank" rel="noopener">孔明的博客</a></li><li><a href="https://blog.csdn.net/abcjennifer/article/details/7359370" target="_blank" rel="noopener">ROC曲线-阈值评价标准</a></li><li><a href="https://www.jianshu.com/p/c61ae11cc5f6" target="_blank" rel="noopener">简书</a></li><li><a href="http://www.cnblogs.com/dlml/p/4403482.html" target="_blank" rel="noopener">博客园</a></li><li><a href="https://www.zhihu.com/question/30643044" target="_blank" rel="noopener">知乎问答</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用本文记录自己对ROC曲线与AUC值的学习和理解&lt;br&gt;
    
    </summary>
    
    
      <category term="评价指标" scheme="http://Bithub00.com/tags/%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/"/>
    
  </entry>
  
  <entry>
    <title>推荐系统学习记录</title>
    <link href="http://Bithub00.com/2019/08/05/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"/>
    <id>http://Bithub00.com/2019/08/05/推荐系统/</id>
    <published>2019-08-05T11:40:06.163Z</published>
    <updated>2019-08-08T09:14:50.843Z</updated>
    
    <content type="html"><![CDATA[<p>用本文记录学习推荐系统的过程，以及一些实用的资料与资源。<br><a id="more"></a></p><h2 id="推荐系统数据集"><a href="#推荐系统数据集" class="headerlink" title="推荐系统数据集"></a><a href="http://cseweb.ucsd.edu/~jmcauley/datasets.html" target="_blank" rel="noopener">推荐系统数据集</a></h2><h2 id="基于隐式反馈数据的推荐系统【理论及python实践】"><a href="#基于隐式反馈数据的推荐系统【理论及python实践】" class="headerlink" title="基于隐式反馈数据的推荐系统【理论及python实践】"></a>基于隐式反馈数据的推荐系统【理论及python实践】</h2><blockquote><p>Yifan Hu,Yehuda Koren,Chris Volinsky.Collaborative Filtering for Implicit Feedback Datasets[J].IEEE International Conference on Data Mining，2008</p></blockquote><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>隐式反馈(Implict)数据就是用户的行为数据，包括点击，浏览和停留等，它不像评分和点赞一样直观地表示了用户的喜好。实际情况中像评分这种显式数据往往很难获得，因为它输入用户额外的进行操作，而像点击这种隐式反馈的数据，是随着用户的行为自然产生的，不需要额外的获取成本，因此实际情况中隐式反馈的数据规模要远大于显式反馈，因此很有必要研究基于隐式反馈数据的推荐系统</p><p>隐式反馈数据的特征：</p><ol><li>没有负样本。不同于评分，用户可以通过打低分来表达对某个物品的厌恶，我们只能通过点击猜测用户可能对某个物品有偏好，而不能通过没有点击来说明用户不喜欢，可能只是他还没接触过这个物品。处理显式数据时，缺失的评分项可以当作缺失值处理，而处理隐式数据时，为了避免只得到正向反馈，必须要对数据整体进行分析。</li><li>隐含很多的噪声数据。例如用户购买某个物品，不代表他一定喜欢这个物品，可能只是作为礼物或者其它原因，而给一个物品打高分可以很大程度上表示他偏好这个用品。</li><li>数值含义不同。在显式数据里，数值的含义代表偏好程度，如评分；而隐式数据里，数值代表置信度，往往表现为行为的频率，例如观看次数等等。频率越高，我们越能确定它与用户的偏好相关联，而不是一个偶然性情况。</li><li>评价指标不同。传统的推荐系统可以使用如均方根误差(Mean Square Error)来判断预测的好坏，而隐式数据上会有不同。</li></ol><h3 id="符号定义"><a href="#符号定义" class="headerlink" title="符号定义"></a>符号定义</h3><p>$r_{ui}$定义为用户$u$对物品$i$的一次观测值，例如购买物品的次数或浏览网页的次数，在电视节目推荐中，它代表完整观看某个节目的次数，0.7表示观看了节目的70%。区别于显式数据将空缺数据当作缺失值处理，我们将缺失值置为0，表示没有此观测记录。</p><h3 id="隐语义模型"><a href="#隐语义模型" class="headerlink" title="隐语义模型"></a>隐语义模型</h3><p>隐语义模型通过用户特征向量$x_u\in R^f$和物品特征向量$y_i\in R^f$来进行预测，预测评分用上面两个向量的内积形式表示：$\hat{r}_{ui}=x_u^Ty_i$，具体细节可见另一篇博客的<a href="http://www.bithub00.com/2019/04/12/imputing%20structured%20missing%20values%20in%20spatial%20data%20with%20clsutered%20adversarial%20matrix%20factorization/" target="_blank" rel="noopener">矩阵分解引入</a>部分。目标函数表示为：</p><script type="math/tex; mode=display">min_{x_*,y_*}\sum_{r_{ui}\ is\ known}(r_{ui}-x_u^Ty_i)^2+\lambda(\mid\mid x_u \mid\mid^2+\mid\mid y_i \mid\mid^2)</script><p>公式中的$\lambda$作为正则化参数，用于<a href="http://www.bithub00.com/2019/04/03/%E8%8C%83%E6%95%B0/" target="_blank" rel="noopener">约束</a>模型，参数的求解常使用随机梯度下降。然而这种方法在应用于隐式反馈数据时需要做调整</p><h3 id="论文提出的模型"><a href="#论文提出的模型" class="headerlink" title="论文提出的模型"></a>论文提出的模型</h3><p>首先引入一个二值变量$p_{ui}$来标识用户对物品是否产生过行为如购买、观看等等：</p><script type="math/tex; mode=display">p_{ui} =\begin{cases}1, &r_{ui} > 0\\0, &r_{ui} = 0\end{cases}</script><p>注意，$p_{ui}=1$只是暗示了用户喜欢某个物品的可能，而且$r_{ui}$的数值越大应该表示喜欢的可能性越大，因此再引入变量表示这种可能性：</p><script type="math/tex; mode=display">c_{ui}=1+\alpha r_{ui}</script><p>引入$c_{ui}$后，对于每一个观测值，我们有一个最小的可能性1，随着观测值的增大，可能性也在逐渐增大，这里的可能性与概率的含义不同，论文中将常数$\alpha$设为40<br>我们的目标是为每一个用户和物品分别得到一个用户特征向量$x_u\in R^f$和物品特征向量$y_i\in R^f$，则预测值可以通过两个向量的内积表示：$p_{ui}=x^T_uy_i$，即预测用户是否会对某个物品产生行为，则目标函数可表示为：</p><script type="math/tex; mode=display">min_{x_*,y_*}L(X,Y)=min_{x_*,y_*}\sum_{u,i}c_{ui}(p_{ui}-x_u^Ty_i)^2+\lambda(\sum_u\mid\mid x_u \mid\mid^2+\sum_i\mid\mid y_i \mid\mid^2)</script><p>同理，第二项为约束项，防止过拟合于训练数据。下一步就是根据目标函数进行求解，因为原始表达式计算复杂度太高，输入的数据集为$m\ast n$的矩阵，m为用户数，n为物品数，规模很容易达到百万级，需要进行相应的优化。<br>我们引入交替最小二乘法(Alternate Least Sqaures)， 目标函数需要优化用户和物品两个维度，可以先固定物品这个维度，对用户唯独进行优化，我的推导过程（论文只给了结果表达式）：<br>对$x_u$求导，可得：</p><script type="math/tex; mode=display">\begin{aligned}\frac{\partial L}{\partial x_u} & = -2\sum_i(p_{ui}-x^T_uy_i)y_ic_{ui}+2\lambda x_u \\& = -2\sum_i(p_{ui}-y_i^Tx_u)y_ic_{ui} + 2\lambda x_u \\& = -2Y^TC_up(u)+2Y^TC_uYx_u+2\lambda x_u\end{aligned}</script><p>其中$Y_{n\ast f}$为含有所有物品特征向量的矩阵，f类似隐语义模型中的隐含特征，可见<a href="http://www.bithub00.com/2019/04/12/imputing%20structured%20missing%20values%20in%20spatial%20data%20with%20clsutered%20adversarial%20matrix%20factorization/" target="_blank" rel="noopener">矩阵分解引入</a>中的解释。令求导结果为0，则有：</p><script type="math/tex; mode=display">\begin{aligned}Y^TC_uYx_u+\lambda Ix_u & = Y^TC_uP_u \\x_u & = (Y^TC_uY+\lambda I)^{-1}Y^TC_up(u)\end{aligned}</script><p>观察表达式，计算复杂度的瓶颈在于计算$Y^TC^uY$这一部分，计算每一个用户的时间复杂度为$O(f^2n)$，我们使用线性代数的知识进行简单的变形：$Y^TC^uY=Y^TY+Y^T(C^u-I)Y$，其中$Y^TY$与用户u无关，可以在迭代开始时预先计算，而$Y^T(C^u-I)Y$中的$C^u-I$只有$n_u$个非零值，其中$n_u$是用户u$r_{ui}&gt;0$的个数，很明显$n_u\ll n$。同样地，$C^up(u)$也只含有$n_u$个非零值，则此时对于单个用户$x_u$的计算复杂度为$O(f^2n_u+f^3)$，其中$O(f^3)$求逆的时间复杂度，总共有m个用户，所以总的时间复杂度为$O(f^2N+f^3m)$，N为总的非零值的个数，隐含特征f的个数通常设置为20-200。则$y_i$的表达式同理：</p><script type="math/tex; mode=display">y_i=(X^TC^iX+\lambda I)^{-1}X^TC^ip(i)</script><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>理解完论文框架后，使用一个<a href="http://archive.ics.uci.edu/ml/machine-learning-databases/00352" target="_blank" rel="noopener">数据集</a>进行实践，自己构建一个基于隐式反馈数据的推荐系统。数据集来源于UCI大学的机器学习资源库，它包含了一个位于英国的网上零售商时间跨度为八个月的所以购买记录，数据集中包含了InvoiceNo StockCode Description Quantity InvoiceDate UnitPrice CustomID Country这些字段。</p><h4 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h4><ul><li>下载数据并读取<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">retail_data = pd.read_excel(<span class="string">'Online Retail.xlsx'</span>)</span><br><span class="line">print(retail_data.info())</span><br><span class="line"></span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">pandas</span>.<span class="title">core</span>.<span class="title">frame</span>.<span class="title">DataFrame</span>'&gt;</span></span><br><span class="line"><span class="class"><span class="title">RangeIndex</span>:</span> <span class="number">541909</span> entries, <span class="number">0</span> to <span class="number">541908</span></span><br><span class="line">Data columns (total <span class="number">8</span> columns):</span><br><span class="line">InvoiceNo      <span class="number">541909</span> non-null object</span><br><span class="line">StockCode      <span class="number">541909</span> non-null object</span><br><span class="line">Description    <span class="number">540455</span> non-null object</span><br><span class="line">Quantity       <span class="number">541909</span> non-null int64</span><br><span class="line">InvoiceDate    <span class="number">541909</span> non-null datetime64[ns]</span><br><span class="line">UnitPrice      <span class="number">541909</span> non-null float64</span><br><span class="line">CustomerID     <span class="number">406829</span> non-null float64</span><br><span class="line">Country        <span class="number">541909</span> non-null object</span><br><span class="line">dtypes: datetime64[ns](<span class="number">1</span>), float64(<span class="number">2</span>), int64(<span class="number">1</span>), object(<span class="number">4</span>)</span><br><span class="line">memory usage: <span class="number">33.1</span>+ MB</span><br></pre></td></tr></table></figure></li></ul><p>可以看到，除了CustomerID这一字段外，其它字段几乎没有缺失值，但如果CustomerID未知，我们就无法知道购买记录中是谁购买了某个商品，因此需要将CustomerID未知的记录去除：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">cleaned_retail = retail_data.loc[pd.isnull(retail_data.CustomerID) == <span class="keyword">False</span>]</span><br><span class="line">print(cleaned_retail.info())</span><br><span class="line"></span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">pandas</span>.<span class="title">core</span>.<span class="title">frame</span>.<span class="title">DataFrame</span>'&gt;</span></span><br><span class="line"><span class="class"><span class="title">Int64Index</span>:</span> <span class="number">406829</span> entries, <span class="number">0</span> to <span class="number">541908</span></span><br><span class="line">Data columns (total <span class="number">8</span> columns):</span><br><span class="line">InvoiceNo      <span class="number">406829</span> non-null object</span><br><span class="line">StockCode      <span class="number">406829</span> non-null object</span><br><span class="line">Description    <span class="number">406829</span> non-null object</span><br><span class="line">Quantity       <span class="number">406829</span> non-null int64</span><br><span class="line">InvoiceDate    <span class="number">406829</span> non-null datetime64[ns]</span><br><span class="line">UnitPrice      <span class="number">406829</span> non-null float64</span><br><span class="line">CustomerID     <span class="number">406829</span> non-null float64</span><br><span class="line">Country        <span class="number">406829</span> non-null object</span><br><span class="line">dtypes: datetime64[ns](<span class="number">1</span>), float64(<span class="number">2</span>), int64(<span class="number">1</span>), object(<span class="number">4</span>)</span><br><span class="line">memory usage: <span class="number">27.9</span>+ MB</span><br></pre></td></tr></table></figure></p><p>这样所有的购买记录都可以对应到唯一的顾客了。接下来我们生成一个商品的描述表，方便查看某个商品编号对应的商品是什么：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">item_lookup = cleaned_retail[[<span class="string">'StockCode'</span>, <span class="string">'Description'</span>]].drop_duplicates()</span><br><span class="line">item_lookup[<span class="string">'StockCode'</span>] = item_lookup.StockCode.astype(str)</span><br><span class="line">print(item_lookup.info()) </span><br><span class="line"></span><br><span class="line">        StockCodeDescription</span><br><span class="line"><span class="number">0</span><span class="number">85123</span>AWHITE HANGING HEART T-LIGHT HOLDER</span><br><span class="line"><span class="number">1</span><span class="number">71053</span>WHITE METAL LANTERN</span><br><span class="line"><span class="number">2</span><span class="number">84406</span>BCREAM CUPID HEARTS COAT HANGER</span><br><span class="line"><span class="number">3</span><span class="number">84029</span>GKNITTED UNION FLAG HOT WATER BOTTLE</span><br><span class="line"><span class="number">4</span><span class="number">84029</span>ERED WOOLLY HOTTIE WHITE HEART.</span><br></pre></td></tr></table></figure></p><p>接下来需要做的是</p><ul><li><p>对于某个用户，将他购买的相同物品的数目进行求和</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cleaned_retail[<span class="string">'CustomerID'</span>] = cleaned_retail.CustomerID.astype(int)</span><br><span class="line">cleaned_retail = cleaned_retail[[<span class="string">'StockCode'</span>, <span class="string">'Quantity'</span>, <span class="string">'CustomerID'</span>]] <span class="comment">#只需要这三个字段，其它像日期等不需要 </span></span><br><span class="line">grouped_cleaned = cleaned_retail.groupby([<span class="string">'CustomerID'</span>, <span class="string">'StockCode'</span>]).sum().reset_index()</span><br></pre></td></tr></table></figure></li><li><p>将求和结果中的0置为1，数目为0的情况往往是顾客进行了退货，这种情况我们也当作顾客购买了商品，而不是当作没购买的情况处理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grouped_cleaned.Quantity.loc[grouped_cleaned.Quantity == <span class="number">0</span>] = <span class="number">1</span></span><br></pre></td></tr></table></figure></li><li><p>去除求和结果中小于0的记录</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grouped_purchased = grouped_cleaned.query(<span class="string">'Quantity &gt; 0'</span>)</span><br></pre></td></tr></table></figure></li><li><p>建立ALS算法中输入的数据矩阵</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">customers = list(np.sort(grouped_purchased.CustomerID.unique()))  </span><br><span class="line">products = list(grouped_purchased.StockCode.unique())</span><br><span class="line">quantity = list(grouped_purchased.Quantity)</span><br><span class="line">rows = grouped_purchased.CustomerID.astype(<span class="string">'category'</span>, categories=customers).cat.codes</span><br><span class="line">cols = grouped_purchased.StockCode.astype(<span class="string">'category'</span>, categories=products).cat.codes</span><br><span class="line">purchases_sparse = sparse.csr_matrix((quantity, (rows, cols)), shape=(len(customers), len(products)))</span><br><span class="line"></span><br><span class="line">&lt;<span class="number">4338</span>x3664 sparse matrix of type <span class="string">'&lt;class '</span>numpy.int64<span class="string">'&gt;'</span></span><br><span class="line"><span class="keyword">with</span> <span class="number">266723</span> stored elements <span class="keyword">in</span> Compressed Sparse Row format&gt;</span><br></pre></td></tr></table></figure></li></ul><p>构建的输入矩阵维度是$4338\ast 3664$，其中有266723个非空值。</p><h4 id="划分数据集"><a href="#划分数据集" class="headerlink" title="划分数据集"></a>划分数据集</h4><p>接下来需要把输入数据划分为训练集和测试集，传统的划分方式如图所示：</p><p><img src="https://s2.ax1x.com/2019/08/07/e5hMTK.png" alt="划分数据"></p><p>然而这种方式对于推荐系统是不适用的，因为矩阵分解时需要用上所有的用户-物品数据，更好的方法是随机隐藏输入矩阵中的某些观测值，将隐藏好的矩阵作为训练数据，将完整的矩阵作为测试矩阵，来判断推荐的物品用户是否会购买。</p><p><img src="https://s2.ax1x.com/2019/08/07/e54m9g.png" alt="划分数据"></p><p>为了对比推荐的效果，我们可以和另一种推荐方法作对比，即只推荐最流行的物品。</p><ul><li>划分数据集<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_train</span><span class="params">(ratings, pct_test)</span>:</span></span><br><span class="line">        test_set = ratings.copy()</span><br><span class="line">        test_set[test_set != <span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        training_set = ratings.copy()</span><br><span class="line">        nonzero_inds = training_set.nonzero()</span><br><span class="line">        nonzero_pairs = list(zip(nonzero_inds[<span class="number">0</span>], nonzero_inds[<span class="number">1</span>]))</span><br><span class="line">        random.seed(<span class="number">0</span>)</span><br><span class="line">        num_samples = int(np.ceil(pct_test * len(nonzero_pairs)))</span><br><span class="line">        samples = random.sample(nonzero_pairs, num_samples)</span><br><span class="line">        user_inds = [index[<span class="number">0</span>] <span class="keyword">for</span> index <span class="keyword">in</span> samples]</span><br><span class="line">        item_inds = [index[<span class="number">1</span>] <span class="keyword">for</span> index <span class="keyword">in</span> samples]</span><br><span class="line">        training_set[user_inds, item_inds] = <span class="number">0</span></span><br><span class="line">        training_set.eliminate_zeros()</span><br><span class="line">        <span class="keyword">return</span> training_set, test_set, list(set(user_inds))</span><br></pre></td></tr></table></figure></li></ul><h4 id="ALS算法"><a href="#ALS算法" class="headerlink" title="ALS算法"></a>ALS算法</h4><p>下一步就是实现论文所用的ALS算法，具体数学公式见上面的推导：</p><ul><li>ALS算法<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">implicit_weighted_ALS</span><span class="params">(training_set, lambda_val=<span class="number">0.1</span>, alpha=<span class="number">40</span>, iterations=<span class="number">10</span>, rank_size=<span class="number">20</span>, seed=<span class="number">0</span>)</span>:</span></span><br><span class="line">    conf = (alpha * training_set)</span><br><span class="line">    num_user = conf.shape[<span class="number">0</span>]</span><br><span class="line">    num_item = conf.shape[<span class="number">1</span>]</span><br><span class="line">    rstate = np.random.RandomState(seed)</span><br><span class="line">    X = sparse.csr_matrix(rstate.normal(size=(num_user, rank_size)))</span><br><span class="line">    Y = sparse.csr_matrix(rstate.normal(size=(num_item, rank_size)))</span><br><span class="line">    X_eye = sparse.eye(num_user)</span><br><span class="line">    Y_eye = sparse.eye(num_item)</span><br><span class="line">    lambda_eye = lambda_val * sparse.eye(rank_size)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> iter_step <span class="keyword">in</span> range(iterations):  </span><br><span class="line">        yTy = Y.T.dot(Y)</span><br><span class="line">        xTx = X.T.dot(X)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> u <span class="keyword">in</span> range(num_user):</span><br><span class="line">            conf_samp = conf[u, :].toarray()</span><br><span class="line">            pref = conf_samp.copy()</span><br><span class="line">            pref[pref != <span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">            CuI = sparse.diags(conf_samp, [<span class="number">0</span>])</span><br><span class="line">            yTCuIY = Y.T.dot(CuI).dot(Y)  </span><br><span class="line">            yTCupu = Y.T.dot(CuI + Y_eye).dot(pref.T)</span><br><span class="line">            X[u] = spsolve(yTy + yTCuIY + lambda_eye, yTCupu)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(num_item):</span><br><span class="line">            conf_samp = conf[:, i].T.toarray()</span><br><span class="line">            pref = conf_samp.copy()</span><br><span class="line">            pref[pref != <span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">            CiI = sparse.diags(conf_samp, [<span class="number">0</span>])</span><br><span class="line">            xTCiIX = X.T.dot(CiI).dot(X)  </span><br><span class="line">            xTCiPi = X.T.dot(CiI + X_eye).dot(pref.T)</span><br><span class="line">            Y[i] = spsolve(xTx + xTCiIX + lambda_eye, xTCiPi)</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> X, Y.T</span><br></pre></td></tr></table></figure></li></ul><p>我们可以举一个例子来看看效果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">user_vecs, item_vecs = implicit_weighted_ALS(product_train, lambda_val = <span class="number">0.1</span>, alpha = <span class="number">15</span>, iterations = <span class="number">1</span>, rank_size = <span class="number">20</span>)</span><br><span class="line">print(user_vecs[<span class="number">0</span>,:].dot(item_vecs).toarray()[<span class="number">0</span>,:<span class="number">5</span>])</span><br><span class="line">[ <span class="number">0.00644811</span>, <span class="number">-0.0014369</span> ,  <span class="number">0.00494281</span>,  <span class="number">0.00027502</span>,  <span class="number">0.01275582</span> ]</span><br></pre></td></tr></table></figure></p><p>对第一个用户来说，前五个物品中第五个物品的得分最高，因此会被用于推荐，这只是一次迭代的结果，迭代多次效果会更好，但原始ALS的算法计算过程太慢，我们需要对它加速，可以使用github上star数上千的python ALS加速版本，所用时间要少得多：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> implict</span><br><span class="line">alpha = <span class="number">15</span></span><br><span class="line">product_train, product_test, product_users_altered = make_train(purchases_sparse, pct_test=<span class="number">0.2</span>)</span><br><span class="line">user_vecs, item_vecs = implicit.alternating_least_squares((product_train * alpha).astype(<span class="string">'double'</span>), factors=<span class="number">20</span>, regularization=<span class="number">0.1</span>, iterations=<span class="number">50</span>)</span><br></pre></td></tr></table></figure><p>可以直观地感觉到计算速度大大加快了，用兴趣的可以去github上看看<a href="https://github.com/benfred/implicit" target="_blank" rel="noopener">源代码</a></p><h4 id="效果评估"><a href="#效果评估" class="headerlink" title="效果评估"></a>效果评估</h4><p>数据集有了，推荐系统也搭好了，那下一步就是对我们的推荐系统进行评估，看看它的表现。在划分训练集和测试集时，有这么一步：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test_set[test_set != <span class="number">0</span>] = <span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>于是推荐就变成了一个二分类问题，购买1或不购买0，这时就可以引入分类系统的评测指标：ROC(Receiver Operating Characteristic)曲线与AUC(Area Under the Curve)值。它的介绍可以看另一篇博客<a href="http://www.bithub00.com/2019/08/07/ROC%E4%B8%8EAUC/" target="_blank" rel="noopener">ROC与AUC</a>。接下来是编写一个函数计算AUC值以进行比较：</p><ul><li>AUC<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> metrics</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">auc_score</span><span class="params">(predictions, test)</span>:</span></span><br><span class="line">    fpr, tpr, thresholds = metrics.roc_curve(test, predictions)</span><br><span class="line">    <span class="keyword">return</span> metrics.auc(fpr, tpr)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用本文记录学习推荐系统的过程，以及一些实用的资料与资源。&lt;br&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://Bithub00.com/tags/python/"/>
    
      <category term="推荐系统" scheme="http://Bithub00.com/tags/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>宝贝陈列室</title>
    <link href="http://Bithub00.com/2019/07/25/%E5%AE%BF%E8%88%8D%E4%B8%80%E8%A7%92/"/>
    <id>http://Bithub00.com/2019/07/25/宿舍一角/</id>
    <published>2019-07-25T03:30:57.778Z</published>
    <updated>2019-07-25T03:40:57.406Z</updated>
    
    <content type="html"><![CDATA[<p><font size="3">展示一下自己收来的各种雕像和CD~</font><br><a id="more"></a></p><p><img src="https://s2.ax1x.com/2019/07/25/eZDA6x.jpg" alt="全览"></p><p><img src="https://s2.ax1x.com/2019/07/25/eZDk11.jpg" alt="致远星贵族小队"></p><p><img src="https://s2.ax1x.com/2019/07/25/eZDFpR.jpg" alt="不义联盟"></p><p><img src="https://s2.ax1x.com/2019/07/25/eZDEX6.jpg" alt="阿卡姆起源限定"></p><p><img src="https://s2.ax1x.com/2019/07/25/eZDPh9.jpg" alt="电视墙背景点亮"></p><p><img src="https://s2.ax1x.com/2019/07/25/eZDcHU.jpg" alt="全览"></p><p><img src="https://s2.ax1x.com/2019/07/25/eZDyuV.jpg" alt="自制老爷场景"></p><p><img src="https://s2.ax1x.com/2019/07/25/eZD2EF.jpg" alt="杰洛特"></p><p><img src="https://s2.ax1x.com/2019/07/25/eZD6BT.jpg" alt="老爷与丑爷"></p><p><img src="https://s2.ax1x.com/2019/07/25/eZDW4J.jpg" alt="雕像与CD"></p><p><img src="https://s2.ax1x.com/2019/07/25/eZDRN4.jpg" alt="正联星战与魔戒"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font size=&quot;3&quot;&gt;展示一下自己收来的各种雕像和CD~&lt;/font&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="宿舍" scheme="http://Bithub00.com/tags/%E5%AE%BF%E8%88%8D/"/>
    
  </entry>
  
  <entry>
    <title>Youtube爬虫</title>
    <link href="http://Bithub00.com/2019/07/25/Youtube%E7%88%AC%E8%99%AB/"/>
    <id>http://Bithub00.com/2019/07/25/Youtube爬虫/</id>
    <published>2019-07-25T02:31:32.337Z</published>
    <updated>2019-08-07T08:00:04.652Z</updated>
    
    <content type="html"><![CDATA[<h3 id="爬取相关频道Related-Channels"><a href="#爬取相关频道Related-Channels" class="headerlink" title="爬取相关频道Related Channels"></a>爬取相关频道Related Channels</h3><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="comment"># scrapy crawl related_channel_spider 命令行启动爬虫</span></span><br><span class="line"></span><br><span class="line">youtube_url = <span class="string">'https://www.youtube.com'</span></span><br><span class="line">kol = collections.OrderedDict()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RelatedChannelsSpider</span><span class="params">(scrapy.Spider)</span>:</span></span><br><span class="line">    name = <span class="string">'related_channel_spider'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close</span><span class="params">(spider, reason)</span>:</span></span><br><span class="line">        <span class="comment"># 爬虫结束后将爬取结果写入json文件</span></span><br><span class="line">        file_kol = open(<span class="string">'RelatedChannels_new.json'</span>, <span class="string">'a'</span>)</span><br><span class="line">        json.dump(kol, file_kol, sort_keys=<span class="keyword">True</span>, indent=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start_requests</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 爬虫数据来源:Youtube 频道链接</span></span><br><span class="line">        file_name = <span class="string">'kol_utm_campaign_ad.xlsx'</span></span><br><span class="line">        Channels = pd.read_excel(file_name, sheet_name=<span class="string">'ad_channel_new'</span>, header=<span class="number">0</span>, </span><br><span class="line">        usecols=[<span class="string">'Channel'</span>])</span><br><span class="line">        Titles = pd.read_excel(file_name, sheet_name=<span class="string">'ad_channel_new'</span>, header=<span class="number">0</span>, </span><br><span class="line">        usecols=[<span class="string">'KolName'</span>])</span><br><span class="line">        length = len(Channels)</span><br><span class="line">        start_urls = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, length):</span><br><span class="line">            url = &#123;&#125;</span><br><span class="line">            url[<span class="string">'url'</span>] = Channels[i:i + <span class="number">1</span>].values.item()</span><br><span class="line">            url[<span class="string">'title'</span>] = Titles[i:i + <span class="number">1</span>].values.item()</span><br><span class="line">            start_urls.append(url)</span><br><span class="line">        <span class="keyword">for</span> url <span class="keyword">in</span> start_urls:</span><br><span class="line">            request = scrapy.Request(url[<span class="string">'url'</span>], callback=self.parse)</span><br><span class="line">            request.meta[<span class="string">'title'</span>] = url[<span class="string">'title'</span>]</span><br><span class="line">            <span class="keyword">yield</span> request</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></span><br><span class="line">        related = collections.OrderedDict()</span><br><span class="line">        meta = response.meta</span><br><span class="line">        channel_title = meta[<span class="string">'title'</span>]</span><br><span class="line">        channel_url = response.url</span><br><span class="line">        <span class="keyword">yield</span> &#123;</span><br><span class="line">            <span class="string">'channel_title'</span>: channel_title,</span><br><span class="line">            <span class="string">'channel_url'</span>: channel_url</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment"># xpath解析网页</span></span><br><span class="line">        channel_item_lis = response.xpath(</span><br><span class="line">            <span class="string">'//li[contains(@class,</span></span><br><span class="line"><span class="string">            "branded-page-related-channels-item")]'</span></span><br><span class="line">            )</span><br><span class="line">        <span class="keyword">for</span> channel_item_li <span class="keyword">in</span> channel_item_lis:</span><br><span class="line">            related_channel_title = channel_item_li.xpath(</span><br><span class="line">                <span class="string">'span/div[contains(@class, </span></span><br><span class="line"><span class="string">                "yt-lockup-content")]/h3/a/text()'</span></span><br><span class="line">                ).extract()[<span class="number">0</span>]</span><br><span class="line">            relative_url = channel_item_li.xpath(</span><br><span class="line">                <span class="string">'span/div[contains(@class, </span></span><br><span class="line"><span class="string">                "yt-lockup-content")]/h3/a/@href'</span></span><br><span class="line">                ).extract()[<span class="number">0</span>]</span><br><span class="line">            related[related_channel_title] = youtube_url</span><br><span class="line">             + relative_url</span><br><span class="line">            print(related_channel_title, youtube_url</span><br><span class="line">             + relative_url)</span><br><span class="line">        <span class="keyword">if</span> related:</span><br><span class="line">            kol[channel_title] = related</span><br></pre></td></tr></table></figure><h3 id="爬取视频评论-包含评论内容、评论日期等"><a href="#爬取视频评论-包含评论内容、评论日期等" class="headerlink" title="爬取视频评论(包含评论内容、评论日期等)"></a>爬取视频评论(包含评论内容、评论日期等)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> lxml.html</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> lxml.cssselect <span class="keyword">import</span> CSSSelector</span><br><span class="line"></span><br><span class="line">YOUTUBE_COMMENTS_URL = </span><br><span class="line"><span class="string">'https://www.youtube.com/all_comments?v=&#123;youtube_id&#125;'</span></span><br><span class="line">YOUTUBE_COMMENTS_AJAX_URL = </span><br><span class="line"><span class="string">'https://www.youtube.com/comment_ajax'</span></span><br><span class="line">youtube_video_url = </span><br><span class="line"><span class="string">'https://www.youtube.com/watch?v='</span></span><br><span class="line"></span><br><span class="line">USER_AGENT = <span class="string">'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/48.0.2564.116 Safari/537.36'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_value</span><span class="params">(html, key, num_chars=<span class="number">2</span>)</span>:</span></span><br><span class="line">    pos_begin = html.find(key) + len(key) + num_chars</span><br><span class="line">    pos_end = html.find(<span class="string">'"'</span>, pos_begin)</span><br><span class="line">    <span class="keyword">return</span> html[pos_begin: pos_end]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract_comments</span><span class="params">(html)</span>:</span></span><br><span class="line">    tree = lxml.html.fromstring(html)</span><br><span class="line">    item_sel = CSSSelector(<span class="string">'.comment-item'</span>)</span><br><span class="line">    text_sel = CSSSelector(<span class="string">'.comment-text-content'</span>)</span><br><span class="line">    time_sel = CSSSelector(<span class="string">'.time'</span>)</span><br><span class="line">    author_sel = CSSSelector(<span class="string">'.user-name'</span>)</span><br><span class="line">    <span class="comment"># vote_sel = CSSSelector('.like-count') 是否爬取评论点赞数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> item_sel(tree):</span><br><span class="line">        <span class="keyword">yield</span> &#123;</span><br><span class="line">            <span class="string">'cid'</span>: item.get(<span class="string">'data-cid'</span>),</span><br><span class="line">            <span class="string">'text'</span>: text_sel(item)[<span class="number">0</span>].text_content(),</span><br><span class="line">            <span class="string">'time'</span>: time_sel(item)[<span class="number">0</span>].text_content().strip(),</span><br><span class="line">            <span class="string">'author'</span>: author_sel(item)[<span class="number">0</span>].text_content()</span><br><span class="line">          <span class="comment"># 'like-count': vote_sel(item)[0].text_content()</span></span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract_reply_cids</span><span class="params">(html)</span>:</span></span><br><span class="line">    tree = lxml.html.fromstring(html)</span><br><span class="line">    sel = CSSSelector(<span class="string">'.comment-replies-header &gt; .load-comments'</span>)</span><br><span class="line">    <span class="keyword">return</span> [i.get(<span class="string">'data-cid'</span>) <span class="keyword">for</span> i <span class="keyword">in</span> sel(tree)]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ajax_request</span><span class="params">(session, url, params, data, retries=<span class="number">10</span>, sleep=<span class="number">20</span>)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(retries):</span><br><span class="line">        response = session.post(url, params=params, data=data)</span><br><span class="line">        <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">            response_dict = json.loads(response.text)</span><br><span class="line">            <span class="keyword">return</span> response_dict.get(<span class="string">'page_token'</span>, <span class="keyword">None</span>),</span><br><span class="line">            response_dict[<span class="string">'html_content'</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            time.sleep(sleep)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_comments</span><span class="params">(youtube_id, sleep=<span class="number">1</span>)</span>:</span></span><br><span class="line">    session = requests.Session()</span><br><span class="line">    session.headers[<span class="string">'User-Agent'</span>] = USER_AGENT</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取初始页面的评论</span></span><br><span class="line">    response = session.get(YOUTUBE_COMMENTS_URL.format(youtube_id=youtube_id))</span><br><span class="line">    html = response.text</span><br><span class="line">    reply_cids = extract_reply_cids(html)</span><br><span class="line"></span><br><span class="line">    ret_cids = []</span><br><span class="line">    <span class="keyword">for</span> comment <span class="keyword">in</span> extract_comments(html):</span><br><span class="line">        ret_cids.append(comment[<span class="string">'cid'</span>])</span><br><span class="line">        <span class="keyword">yield</span> comment</span><br><span class="line"></span><br><span class="line">    page_token = find_value(html, <span class="string">'data-token'</span>)</span><br><span class="line">    session_token = find_value(html, <span class="string">'XSRF_TOKEN'</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    first_iteration = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取剩下的评论(等同于点击'show more')</span></span><br><span class="line">    <span class="keyword">while</span> page_token:</span><br><span class="line">        data = &#123;</span><br><span class="line">            <span class="string">'video_id'</span>: youtube_id,</span><br><span class="line">            <span class="string">'session_token'</span>: session_token</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        params = &#123;</span><br><span class="line">            <span class="string">'action_load_comments'</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="string">'order_by_time'</span>: <span class="keyword">True</span>,</span><br><span class="line">            <span class="string">'filter'</span>: youtube_id</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> first_iteration:</span><br><span class="line">            params[<span class="string">'order_menu'</span>] = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            data[<span class="string">'page_token'</span>] = page_token</span><br><span class="line"></span><br><span class="line">        response = ajax_request(session, YOUTUBE_COMMENTS_AJAX_URL, params, data)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> response:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        page_token, html = response</span><br><span class="line"></span><br><span class="line">        reply_cids += extract_reply_cids(html)</span><br><span class="line">        <span class="keyword">for</span> comment <span class="keyword">in</span> extract_comments(html):</span><br><span class="line">            <span class="keyword">if</span> comment[<span class="string">'cid'</span>] <span class="keyword">not</span> <span class="keyword">in</span> ret_cids:</span><br><span class="line">                ret_cids.append(comment[<span class="string">'cid'</span>])</span><br><span class="line">                <span class="keyword">yield</span> comment</span><br><span class="line"></span><br><span class="line">        first_iteration = <span class="keyword">False</span></span><br><span class="line">        time.sleep(sleep)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取评论回复</span></span><br><span class="line">    <span class="keyword">for</span> cid <span class="keyword">in</span> reply_cids:</span><br><span class="line">        data = &#123;<span class="string">'comment_id'</span>: cid,</span><br><span class="line">                <span class="string">'video_id'</span>: youtube_id,</span><br><span class="line">                <span class="string">'can_reply'</span>: <span class="number">1</span>,</span><br><span class="line">                <span class="string">'session_token'</span>: session_token&#125;</span><br><span class="line"></span><br><span class="line">        params = &#123;<span class="string">'action_load_replies'</span>: <span class="number">1</span>,</span><br><span class="line">                  <span class="string">'order_by_time'</span>: <span class="keyword">False</span>,</span><br><span class="line">                  <span class="string">'filter'</span>: youtube_id,</span><br><span class="line">                  <span class="string">'tab'</span>: <span class="string">'inbox'</span>&#125;</span><br><span class="line"></span><br><span class="line">        response = ajax_request(session, YOUTUBE_COMMENTS_AJAX_URL, params, data)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> response:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        _, html = response</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> comment <span class="keyword">in</span> extract_comments(html):</span><br><span class="line">            <span class="keyword">if</span> comment[<span class="string">'cid'</span>] <span class="keyword">not</span> <span class="keyword">in</span> ret_cids:</span><br><span class="line">                ret_cids.append(comment[<span class="string">'cid'</span>])</span><br><span class="line">                <span class="keyword">yield</span> comment</span><br><span class="line">        time.sleep(sleep)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span> <span class="comment"># 使用</span></span><br><span class="line">    <span class="keyword">for</span> comment <span class="keyword">in</span> download_comments(videoId):</span><br><span class="line">    ···</span><br></pre></td></tr></table></figure><h3 id="爬取某个视频主所有的视频"><a href="#爬取某个视频主所有的视频" class="headerlink" title="爬取某个视频主所有的视频"></a>爬取某个视频主所有的视频</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用Selenium</span></span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line">Channel_videos = <span class="string">'https://www.youtube.com/channel/UCGK0RMoHboOVUbdxDhLD1xw/videos'</span></span><br><span class="line">Video_Lists = []</span><br><span class="line">option = webdriver.ChromeOptions()</span><br><span class="line">option.add_argument(<span class="string">'headless'</span>)</span><br><span class="line">youtube_url = <span class="string">'https://www.youtube.com'</span></span><br><span class="line">browser = webdriver.Chrome(chrome_options=option, executable_path=<span class="string">'D:\Tool\Software\chromedriver_win32\\chromedriver.exe'</span>)</span><br><span class="line"><span class="comment"># 去掉option选项可以让chrome在前台显示，看看模拟的效果</span></span><br><span class="line">browser = webdriver.Chrome(executable_path=<span class="string">'D:\Tool\Software\chromedriver_win32\\chromedriver.exe'</span>)</span><br><span class="line">browser.get(Channel_videos)</span><br><span class="line">time.sleep(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">old_height = browser.execute_script(<span class="string">"return document.documentElement.scrollHeight;"</span>)</span><br><span class="line">browser.execute_script(<span class="string">"window.scrollTo(0, document.documentElement.scrollHeight);"</span>)</span><br><span class="line">time.sleep(<span class="number">5</span>)</span><br><span class="line">new_height = browser.execute_script(<span class="string">"return document.documentElement.scrollHeight;"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模拟浏览器向下滚动页面，直到所有视频都被加载出来</span></span><br><span class="line"><span class="keyword">while</span> new_height != old_height:</span><br><span class="line">    old_height = new_height</span><br><span class="line">    browser.execute_script(<span class="string">"window.scrollTo(0, document.documentElement.scrollHeight);"</span>)</span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">    new_height = browser.execute_script(<span class="string">"return document.documentElement.scrollHeight;"</span>)</span><br><span class="line"></span><br><span class="line">    html = browser.page_source</span><br><span class="line">    soup = BeautifulSoup(html, <span class="string">'lxml'</span>)</span><br><span class="line">    videoList = soup.findAll(<span class="string">"a"</span>, &#123;<span class="string">"class"</span>: <span class="string">"yt-simple-endpoint style-scope ytd-grid-video-renderer"</span>&#125;)</span><br><span class="line">    <span class="keyword">for</span> video <span class="keyword">in</span> videoList:</span><br><span class="line">        ···</span><br></pre></td></tr></table></figure><h3 id="获取视频的播放量和发布日期"><a href="#获取视频的播放量和发布日期" class="headerlink" title="获取视频的播放量和发布日期"></a>获取视频的播放量和发布日期</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 因为Youtube API每日有访问限制，超过它的配额后就无法再使用接口获取某个视频的播放量和发布日期了，使用爬虫就没有这种限制</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">youtube_video_url = <span class="string">'https://www.youtube.com/watch?v='</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">viewCount</span><span class="params">()</span>:</span></span><br><span class="line">        videoId = <span class="string">'P4ItC6jWN0s'</span></span><br><span class="line">        url = <span class="string">"https://www.youtube.com/watch"</span></span><br><span class="line">        querystring = &#123;<span class="string">"v"</span>: videoId&#125;</span><br><span class="line">        payload = <span class="string">""</span></span><br><span class="line">        headers = &#123;</span><br><span class="line">            <span class="string">'Content-Type'</span>: <span class="string">"application/json"</span>,</span><br><span class="line">            <span class="string">'User-Agent'</span>: <span class="string">"PostmanRuntime/7.15.0"</span>,</span><br><span class="line">            <span class="string">'Accept'</span>: <span class="string">"*/*"</span>,</span><br><span class="line">            <span class="string">'Cache-Control'</span>: <span class="string">"no-cache"</span>,</span><br><span class="line">            <span class="string">'Postman-Token'</span>: <span class="string">"296c1155-2adc-4028-95c2-26cffec91784,f5c8088f-432f-4a67-a815-13464bfca373"</span>,</span><br><span class="line">            <span class="string">'Host'</span>: <span class="string">"www.youtube.com"</span>,</span><br><span class="line">            <span class="string">'cookie'</span>: <span class="string">"YSC=nwR5fai12Kg; VISITOR_INFO1_LIVE=gAl5VFO7Gjo; PREF=f1=50000000; GPS=1"</span>,</span><br><span class="line">            <span class="string">'accept-encoding'</span>: <span class="string">"gzip, deflate"</span>,</span><br><span class="line">            <span class="string">'Connection'</span>: <span class="string">"keep-alive"</span>,</span><br><span class="line">            <span class="string">'cache-control'</span>: <span class="string">"no-cache"</span></span><br><span class="line">        &#125;</span><br><span class="line">        response = requests.request(<span class="string">"GET"</span>, url, data=payload, headers=headers, params=querystring)</span><br><span class="line">        html = etree.HTML(response.text)</span><br><span class="line">        datePublished = html.xpath(<span class="string">'//meta[@itemprop="datePublished"]/@content'</span>)</span><br><span class="line">        <span class="keyword">if</span> datePublished:</span><br><span class="line">            datePublished = datePublished[<span class="number">0</span>]</span><br><span class="line">            view_count = html.xpath(<span class="string">'//meta[@itemprop="interactionCount"]/@content'</span>)</span><br><span class="line">            <span class="keyword">if</span> view_count:</span><br><span class="line">                view_count = int(view_count[<span class="number">0</span>])</span><br><span class="line">                print(datePublished, view_count)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'Not Exist:'</span>,videoId)</span><br><span class="line"></span><br><span class="line">    file = open(<span class="string">'video_statstics.json'</span>, <span class="string">'a'</span>)</span><br><span class="line">    json.dump(video_statstics, file, indent=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    viewCount()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;爬取相关频道Related-Channels&quot;&gt;&lt;a href=&quot;#爬取相关频道Related-Channels&quot; class=&quot;headerlink&quot; title=&quot;爬取相关频道Related Channels&quot;&gt;&lt;/a&gt;爬取相关频道Related Channels&lt;/h3&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://Bithub00.com/tags/python/"/>
    
      <category term="爬虫" scheme="http://Bithub00.com/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>python常用操作</title>
    <link href="http://Bithub00.com/2019/07/25/python%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
    <id>http://Bithub00.com/2019/07/25/python常用操作/</id>
    <published>2019-07-25T02:13:08.319Z</published>
    <updated>2019-07-30T03:07:59.969Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>读取excel文件某一列</p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">names = pd.read_excel(</span><br><span class="line">    <span class="string">'NOT_EXIST_List.xlsx'</span>,</span><br><span class="line">    sheet_name=<span class="string">'NOT EXIST'</span>, </span><br><span class="line">    header=<span class="number">0</span>, </span><br><span class="line">    usecols=[<span class="string">'KolName'</span>])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(names)):</span><br><span class="line">    name = names[i:i + <span class="number">1</span>].values.item()</span><br></pre></td></tr></table></figure></li><li><p>List去重</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">List = pd.unique(List).tolist()</span><br></pre></td></tr></table></figure></li><li><p>将接口返回值解析成json格式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> request</span><br><span class="line">response = requests.request(</span><br><span class="line">    <span class="string">"GET"</span>, url,</span><br><span class="line">    data=payload, </span><br><span class="line">    headers=headers,</span><br><span class="line">    params=querystring)</span><br><span class="line">json_response = json.loads(response.text)</span><br></pre></td></tr></table></figure></li><li><p>移除字符串中的标点符号</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removePunctuation</span><span class="params">(text)</span>:</span></span><br><span class="line">    str = <span class="string">''</span>.join(c <span class="keyword">for</span> c <span class="keyword">in</span> text <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> string.punctuation)</span><br><span class="line">    <span class="keyword">return</span> str</span><br></pre></td></tr></table></figure></li><li><p>读取和写入json文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">file = open(<span class="string">'XXX.json'</span>, <span class="string">'r'</span>)</span><br><span class="line">XXX = json.loads(file.read())</span><br><span class="line">file = open(<span class="string">'XXX.json'</span>, <span class="string">'a'</span>)</span><br><span class="line">json.dump(XXX, file, indent=<span class="number">2</span>)</span><br></pre></td></tr></table></figure></li><li><p>将List写入excel文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">df = pd.DataFrame(List, columns=[<span class="string">'name'</span>, <span class="string">'url'</span>])</span><br><span class="line">writer = pd.ExcelWriter(<span class="string">'remain.xlsx'</span>)</span><br><span class="line">df.to_excel(writer, <span class="string">'remain'</span>)</span><br><span class="line">writer.save()</span><br></pre></td></tr></table></figure></li><li><p>dict根据key排序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sortdict</span><span class="params">(data)</span>:</span></span><br><span class="line">    result = collections.OrderedDict()</span><br><span class="line">    dict = sorted(data.items(), key=<span class="keyword">lambda</span> d: d[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(dict)):</span><br><span class="line">        result[dict[i][<span class="number">0</span>]] = dict[i][<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;读取excel文件某一列&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://Bithub00.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>imputing structured missing values in spatial data with clsutered adversarial matrix factorization</title>
    <link href="http://Bithub00.com/2019/04/12/imputing%20structured%20missing%20values%20in%20spatial%20data%20with%20clsutered%20adversarial%20matrix%20factorization/"/>
    <id>http://Bithub00.com/2019/04/12/imputing structured missing values in spatial data with clsutered adversarial matrix factorization/</id>
    <published>2019-04-12T15:55:11.077Z</published>
    <updated>2019-08-07T07:59:01.419Z</updated>
    
    <content type="html"><![CDATA[<font size="5">一种基于对抗模型用于补全带有结构性缺失信息的空间数据的矩阵分解技术</font><a id="more"></a><p>&#8194; </p><font size="3">摘要：在数据分析时，缺失的数据总是会成为一个重大的挑战，因为它带来了不确定性。在许多领域中，矩阵补全技术有着出色的表现。然而，在特定的空间数据集如地理坐标点时，这种传统的矩阵补全技术有着两个主要的限制：第一，这些方法往往假设缺失的数据是随机产生的，而这种假设对于空间数据集可能并不总是成立；第二，它们可能无法运用这些空间数据集中的结构信息。为了解决这些局限性，本论文提出了一种利用先验结构信息和生成对抗模型的矩阵分解技术。这个模型使用一个对抗网络通过学习数据集的概率分布来改善补全的结果。</font><font size="3">关键词：缺失数据估计；深度对抗网络；空间数据</font><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&#8194; 很多现实生活中的应用容易面临数据缺失的问题。而对于空间数据集，造成这种情况的原因有很多种。例如，在森林监测中，因为收集成本的原因，数据的缺失很普遍。【3】过去十年许多针对数据补全的工作在开展，从基本的统计方法到复杂的模型使用。后者的典例低秩矩阵补全技术为许多领域如推荐系统或图像重构带来了可观的改善【9】。这些方法通过发现并利用数据矩阵的低秩属性来建立已有值与缺失值的联系。而在这些矩阵补全方法里，矩阵分解是最为常用的方法之一，它将输入的数据矩阵分解成两个低秩矩阵的乘积，称为“特征因子”，接着通过最小化这个乘积与已有值的误差来学习这两个特征因子，随后利用它们来补全缺失的信息。【18】其它方法还有如带门槛的矩阵奇异值分解，核心思想是迭代地使用截断奇异值分解来补全。</p><p>&#8194; 这些矩阵补全的方法，往往假设缺失的数据是随机产生的。【2】然而，这个假设在空间数据上可能并不成立，因为它往往带有空间结构。例如，一项针对加拿大青少年的研究指出，家庭收入这一栏数据空缺的青少年有更低的可能性居住在富人区。【15】因此，当数据并不是随机缺失时，只是单纯地最小化两个特征因子的乘积与已有值的误差并不能保证补全数据的有效性。</p><p>&#8194; 而另一个限制则是这些方法无法把数据集里的结构信息利用起来。而在补全缺失的空间数据时，这些结构信息格外重要。【12】例如，淡水湖数据就有强烈的空间结构，因为相邻的湖泊往往有相似的降水量等。【17】如果这些结构信息能够被一个矩阵补全的方法利用起来，它可以显著地提升结果，因为这些结构信息代表了一个子空间，在这个子空间里，不同湖泊之间相似的信息互相传递。</p><p>&#8194; 因为为了解决这两点局限，我们提出了一种利用先验结构信息和生成对抗模型的矩阵分解技术。这个框架找到一个低维的子空间来与数据中的结构信息相符合，因此可以利用同一类中其它数据点的信息来补全某一点的缺失值。而且，估计值的概率分布也尽可能的与已有值相似，这么做的好处是它把缺失值与已有值连接起来了。如果估计值与实际值偏差太大，那么它出现的概率应该很小。然而，实际数据的概率分布往往是未知的，因此我们借鉴了生成对抗网络的思想引入了一个判别器来区分估计值与已有值。我们在合成数据集与显示数据集上均做了实验，来说明这个框架的有效性。</p><h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><p>&#8194; 截断奇异值算法是近年来使用频率较高的一个方法，它在数据矩阵中迭代的使用截断奇异值分解接着通过保持一个较小的奇异值重构整个矩阵。矩阵分解是另一项常用的技术，关于它的过程前面部分已有讲述。</p><p>&#8194; 生成对抗网络（GAN）被广泛地用于生成图像【5】【16】。在【8】【14】中，作者提出了一个想法，利用GAN的思想和整幅图片的结构来推测一幅图片中随机缺失的像素。虽然这个想法在这类问题上效果较好，但它补全图片时是将每张图片看成一个个独立的个体，而空间数据与此相反，它们之间有着强烈的依赖性。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="A-矩阵分解引入"><a href="#A-矩阵分解引入" class="headerlink" title="A.矩阵分解引入"></a>A.矩阵分解引入</h3><p>&#8194; 矩阵分解在推荐系统中十分常用，例如如下的一个评分矩阵，列为用户，行为物品，矩阵中的值为用户对物品的评分，如电影和书籍。现实情况中这个评分矩阵往往很稀疏，许多物品上缺少用户的评分，而推荐系统就是要预估用户在某个物品上的评分来判断用户对它的倾向程度，从而进行推荐。</p><p><img src="https://s2.ax1x.com/2019/04/13/AqRtk4.png" alt=""></p><p>&#8194; 矩阵分解的方法是将原始评分矩阵$R^{m\times n}$分解成两个矩阵$P^{m\times k}$和$Q^{k\times n}$，根据评分矩阵中已有的值来判断分解是否准确，而判别标准常用均方差。如图所示。</p><p><img src="https://s2.ax1x.com/2019/04/13/AqRJ7F.png" alt=""></p><p>&#8194; 分解后的矩阵P和Q可以称为特征因子（latent factor），其中要求分解后$k&lt;&lt;min(m,n)$，即低秩要求，因为如果输入矩阵满秩，则各元素行之间线性无关，如果有线性相关关系，则某个元素行可以通过其他行的线性组合表示，相当于引入了冗余的信息，这样就可以将矩阵投影到更低维的空间，只保留非冗余信息，同时冗余信息可以用来对缺失值进行补全。</p><p>&#8194; 矩阵分解的直观意义为，找出矩阵中的潜在特征，如图2中假设特征为3，特征可以是书籍作者、类型等等，而矩阵P表示用户对某个特征的喜爱程度，而矩阵Q表示某个物品与该特征的关联程度。</p><h3 id="B-低秩补全"><a href="#B-低秩补全" class="headerlink" title="B.低秩补全"></a>B.低秩补全</h3><p>&#8194; 给定一个带有缺失值的矩阵，矩阵补全技术旨在通过已有值的某种潜在的结构来对缺失值进行估计补全。一个常用的潜在结构是矩阵的低秩性，因为它可以将该矩阵投影到一个去除冗余信息的子空间中，低秩意味着矩阵中的值存在线性关系，因此某些值可以通过另外的值来线性表示，如同坐标系中的基底一样。在这类方法中有凸也有非凸的技术。凸方法通过对矩阵迹的约束来保证具有良好理论性的全局最优结果，而诸如矩阵分解的非凸方法进行局部搜索过程并提供更大的灵活性和效率。给定一个矩阵$X\in R^{d\times n}$，n代表样本个数，d代表特征维度，矩阵分解技术通过将X分解为两个矩阵U和V，$U\in R^{d\times n}$，$V\in R^{r\times n}$要求$r &lt; min(d, n)$；U和V的求解可以通过对下列式子运用块坐标下降法求得：</p><p><img src="https://s2.ax1x.com/2019/04/13/AqRG0U.png" alt=""></p><p>&#8194; $\bigodot$代表哈德蒙德内积（即矩阵各元素相乘），M矩阵的大小同X一致，如果$X_{ij}$有值则$M_{ij}$为1，否则为0。局部解用$U^<em>、V^</em>$表示，因此，它们可以通过如下的式子来重构矩阵X：</p><p><img src="https://s2.ax1x.com/2019/04/13/AqR8mT.png" alt=""></p><p>&#8194; 矩阵分解在推荐系统中使用较为普遍，它用来估计一个用户在某项新物品上的评分。</p><p>&#8194; 将此方法应用于空间数据集时，矩阵分解不会包含有关数据集中空间聚类结构的先验知识信息。 然而，这些先验知识通常有助于发现需要的子空间。此外，对于结构化缺失值问题，经典矩阵补全提供较差的结果，因为缺失值不是随机的。</p><h3 id="C-聚类对抗式矩阵分解"><a href="#C-聚类对抗式矩阵分解" class="headerlink" title="C.聚类对抗式矩阵分解"></a>C.聚类对抗式矩阵分解</h3><p>&#8194; 为了解决上一小节中提到的矩阵分解的两个局限性，我们提出了一种新的聚类对抗矩阵分解框架。 在我们的框架中，我们找到整个样本的聚类信息，并将补全值的概率分布与已有值的分布靠近，以得到可靠的补全结果。X为输入矩阵，每一列代表一个数据样本，有些数据点有完整的特征信息，而某些数据点以结构性缺失了某些特征信息。我们将输入矩阵中完整部分记为$X_n$，而缺失部分记为$X_m$。我们假设每个数据点都符合某个概率分布$p_{data(x)}$。接下来的公式中包含两个部分：矩阵重构以及概率分布近似。</p><h4 id="矩阵重构"><a href="#矩阵重构" class="headerlink" title="矩阵重构"></a>矩阵重构</h4><p>&#8194; 为了利用数据的低秩属性和空间聚类结构，我们决定在矩阵分解中使用l2聚类项：</p><p><img src="https://s2.ax1x.com/2019/04/17/AzcSM9.png" alt=""></p><p>&#8194; 式中$v_i$代表矩阵V中第i列，$r_1,r_2,r_3$均为正则化参数，第二项和第三项加的约束是为了防止过拟合，最后一项则用来引入空间数据集中的聚类结构信息。$d_{ij}$是第i个样本和第j个样本的相似度，它可以手动设置，原则为：当$v_i$和$v_j$很靠近即在同一类时，将$d_{ij}$的值设置得较大，反之较小。$r_3$用来调整结构信息在重构时所占的比重，如果$r_3$较大，则对一个样本的缺失数据进行估计补全时会更多的参考同一类其它数据点的信息。因此当$r_3$为0时，结构信息将不被使用，这也使得这个式子变成了常规的矩阵分解方法。而对于UV矩阵直观的理解为，U为特征因子，而V为样本因子，如同推荐系统里的用户因子和物品因子，两者相互独立。</p><h4 id="生成对抗网络思想（GAN）"><a href="#生成对抗网络思想（GAN）" class="headerlink" title="生成对抗网络思想（GAN）"></a>生成对抗网络思想（GAN）</h4><p>&#8194; 在继续讲到使用概率分布近似来优化前，先引入生成对抗网络的基本思想加深理解。GAN的非常的直观，就是生成器和判别器两个极大极小的博弈。</p><p><img src="https://s2.ax1x.com/2019/04/17/AzcULn.png" alt=""></p><p>GAN的目标函数为：</p><p><img src="https://s2.ax1x.com/2019/04/17/AzctMj.png" alt=""></p><p>&#8194; 从判别器D的角度看，它希望自己能尽可能区分真实样本和虚假样本，因此希望 D(x)尽可能大，D(G(z))尽可能小，即 V(D,G)尽可能大。从生成器G的角度看，它希望自己尽可能骗过D，也就是希望 D(G(z))尽可能大，即 V(D,G)V(D,G) 尽可能小。两个模型相对抗，最后达到全局最优。</p><p><img src="https://s2.ax1x.com/2019/04/17/AzcNss.png" alt=""></p><p>&#8194; 图中，黑色曲线是真实样本的概率分布函数，绿色曲线是虚假样本的概率分布函数，蓝色曲线是判别器D的输出，它的值越大表示这个样本越有可能是真实样本。最下方的平行线是噪声z，它映射到了x。</p><p>&#8194; 一开始， 虽然 G(z)和x是在同一个特征空间里的，但它们分布的差异很大，这时，虽然鉴别真实样本和虚假样本的模型 D性能也不强，但它很容易就能把两者区分开来，而随着训练的推进，虚假样本的分布逐渐与真实样本重合，D虽然也在不断更新，但也已经力不从心了。</p><p>&#8194; 最后，黑线和绿线最后几乎重合，模型达到了最优状态，这时 判别器的输出对于任意样本都是 0.5。</p><h4 id="GAN的最优化"><a href="#GAN的最优化" class="headerlink" title="GAN的最优化"></a>GAN的最优化</h4><p>&#8194; 在建立好理论框架后，需要对所需要的生成器G和判别器D进行优化，在此之前先引入交叉熵的概念：它一般用来求目标与预测值之间的差距。</p><p>&#8194; 在信息论与编码中，熵可以用来衡量信息量的多少，而如果我们对于同一个随机变量 x 有两个单独的概率分布 P(x) 和 Q(x)，我们可以使用 KL 散度来衡量这两个分布的差异，计算式如下：</p><p><img src="https://s2.ax1x.com/2019/04/17/Azcho6.png" alt=""></p><p>&#8194; 在机器学习中，P往往用来表示样本的真实分布，比如[1,0,0]表示当前样本属于第一类。Q用来表示模型所预测的分布，比如[0.7,0.2,0.1]，直观的理解就是如果用P来描述样本，那么就非常完美。而用Q来描述样本，虽然可以大致描述，但并不是那么的完美，信息量不足，需要额外的一些“信息增量”才能达到和P一样完美的描述。如果我们的Q通过反复训练，也能完美的描述样本，那么就不再需要额外的“信息增量”，此时Q就等价于P。</p><p>而对KL散度的计算式进行变形，可以得到：</p><p><img src="https://s2.ax1x.com/2019/04/17/AzcIJO.png" alt=""></p><p>等式的前一项即为P的熵，而后一项就是交叉熵的计算式：</p><p><img src="https://s2.ax1x.com/2019/04/17/Azc5FK.png" alt=""></p><p>&#8194; 在机器学习中，我们需要评估labels和predictions之间的差距，可以使用KL散度，即$D_{KL}(y\mid\mid\hat{y})$，由于KL散度中的前一部分−H(y)即P的熵不变，故在优化过程中，只需要关注交叉熵就可以了。所以一般在机器学习中直接用用交叉熵做损失函数，评估模型。</p><p>&#8194; 在引入交叉熵后，就可以定义最优化表达式。首先我们需要定义一个判别器 D以判别样本是不是从$p_{data(x)}$分布中取出来的，因此有:</p><p><img src="https://s2.ax1x.com/2019/04/17/Azg6tf.png" alt=""></p><p>&#8194; 其中E代表取期望。这一项是根据「正类」（即辨别出 x 属于真实数据data）的对数损失函数而构建的。最大化这一项相当于令判别器 D在 x 服从于 data 的概率密度时能准确地预测 D(x)=1，即：</p><p><img src="https://s2.ax1x.com/2019/04/17/Azgch8.png" alt=""></p><p>另外一项是企图欺骗判别器的生成器 G。该项根据「负类」的对数损失函数而构建，即</p><p><img src="https://s2.ax1x.com/2019/04/17/AzgyAP.png" alt=""></p><p>因此目标函数为：</p><p><img src="https://s2.ax1x.com/2019/04/17/Azg29S.png" alt=""></p><p>它的含义是，对于D而言要尽量使公式最大化（识别能力强），而对于G又想使它最小（生成的数据接近实际数据）。整个训练是一个迭代过程。极小极大化博弈可以分开理解，即在给定G的情况下先最大化$V(D,G)$而来得到D，然后固定D，并最小化$V(D,G)$而得到G。其中，给定 G，最大化$V(D,G)$评估了$P_g$和$P_{data}$之间的差异或距离。</p><h4 id="概率分布近似"><a href="#概率分布近似" class="headerlink" title="概率分布近似"></a>概率分布近似</h4><p>&#8194; 接下来，论文中就使用生成对抗网络中的对抗策略来使得推算样本具有与完整数据类似的概率分布。为了实现这一目标，我们使用鉴别器来区分推算和完整样本之间的分布差异：</p><p><img src="https://s2.ax1x.com/2019/04/17/Az29N6.png" alt=""></p><p>&#8194; 其中$p_r(x_r)$代表估计值的概率分布，它将从补全的矩阵Xr中得到；$x_r$代表从$p_r(x_r)$中选取的一个数据点；D为一个鉴别器，我们通过一个以SOFTMAX为输出层的全连接的深度神经网络来实现。D将输出一个概率值，判断输入的数据为已有值还是估计值。我们使用了负交叉熵作为损失函数，通过最大化$l_d$得到一个鉴别器D，能够有效地区分已有值与估计值</p><h4 id="完整公式"><a href="#完整公式" class="headerlink" title="完整公式"></a>完整公式</h4><p>将前节提到的两个部分进行合并，我们得到了如下的公式：</p><p><img src="https://s2.ax1x.com/2019/04/17/Azgvu9.png" alt=""></p><p>&#8194; 其中λ是用来平衡矩阵重构与概率分布近似所占比例的一个参数，因此最小化该式时，不仅使得重构的矩阵与已有值所构成的矩阵的误差尽可能得小，同时通过鉴别器使得这两者的概率分布尽可能相似。这个同时最大最小化的要求就像是进行一场对抗。一方面，鉴别器尽可能地区别重构样本与已有样本的概率分布，而另一方面，重构矩阵又尽可能地逼近已有值的概率分布，以骗过鉴别器。因此当算法收敛时，重构矩阵的概率分布将会近似于已有值，训练出一个有效的鉴别器，同时重构矩阵的值也足够接近实际值以至于可以骗过这个鉴别器。在最小化部分中，我们求解出使得误差最小的矩阵U和V，接着使用它们来进行缺失值的计算。同时，这个部分也尽可能地让估计值去骗过鉴别器。而在最大化部分中，鉴别器通过区分已有值与最小化部分所得的估计值来进行更新，整个框架的流程如图所示。</p><p><img src="https://s2.ax1x.com/2019/04/17/Az2pAx.png" alt=""></p><h4 id="最优化"><a href="#最优化" class="headerlink" title="最优化"></a>最优化</h4><p>然而在实际情况中，输入样本的概率分布往往是未知的，因此，我们使用如下式子来进行近似：在每次的更新迭代中，我们随机从Xn与Xr选取k个样本，来计算概率分布：</p><p><img src="https://s2.ax1x.com/2019/04/17/AzgzH1.png" alt=""><br><img src="https://s2.ax1x.com/2019/04/17/AzgxBR.png" alt=""></p><p>&#8194; 其中r1与rk分别代表从Xn中选取的k个样本中的第一个和最后一个，q1和qk从Xr中选取的k个样本中的第一个和最后一个，$X^i_n$和$X^i_r$分别代表从Xn与Xr中所选取的第i个样本。因此，上面的合成式将变成：</p><p><img src="https://s2.ax1x.com/2019/04/17/Az2l8S.png" alt=""></p><p>算法流程如下所示：</p><p><img src="https://s2.ax1x.com/2019/04/17/Az2QC8.png" alt=""></p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2>]]></content>
    
    <summary type="html">
    
      &lt;font size=&quot;5&quot;&gt;
一种基于对抗模型用于补全带有结构性缺失信息的空间数据的矩阵分解技术
&lt;/font&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://Bithub00.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="GAN" scheme="http://Bithub00.com/tags/GAN/"/>
    
      <category term="矩阵分解" scheme="http://Bithub00.com/tags/%E7%9F%A9%E9%98%B5%E5%88%86%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>数据库设计</title>
    <link href="http://Bithub00.com/2019/04/10/database/"/>
    <id>http://Bithub00.com/2019/04/10/database/</id>
    <published>2019-04-10T08:50:19.836Z</published>
    <updated>2019-04-10T08:52:10.289Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h2><ul><li>以下所有表默认自带一个自增 <code>id</code></li><li>以下所有表默认自带 <code>created_at</code> 和 <code>updated_at</code> 两个字段</li><li>为了方便查询，以下所有下划线命名法在实际设计中可能全部转为驼峰命名法<a id="more"></a></li></ul><h3 id="用户信息"><a href="#用户信息" class="headerlink" title="用户信息"></a>用户信息</h3><h4 id="manager"><a href="#manager" class="headerlink" title="manager"></a>manager</h4><div class="table-container"><table><thead><tr><th>字段</th><th>类型</th><th>描述</th><th>约束</th></tr></thead><tbody><tr><td>name</td><td>varchar</td><td>姓名</td><td>not null</td></tr><tr><td>card_id</td><td>varchar</td><td>校园卡号</td><td>not null</td></tr><tr><td>authorizerId</td><td>int</td><td>授权人 id</td><td>外键，引用自 manager 表的 id 属性</td></tr><tr><td>privilege</td><td>tinyint</td><td>0 为超级管理员，1为普通管理员，其余待定</td><td>not null</td></tr></tbody></table></div><h4 id="student"><a href="#student" class="headerlink" title="student"></a>student</h4><div class="table-container"><table><thead><tr><th>字段</th><th>类型</th><th>描述</th><th>约束</th></tr></thead><tbody><tr><td>card_id</td><td>varchar</td><td>校园卡号</td><td>无</td></tr><tr><td>stu_id</td><td>varchar</td><td>学号</td><td>primary key</td></tr><tr><td>name</td><td>varchar</td><td>姓名</td><td>not null</td></tr><tr><td>college</td><td>varchar</td><td>学院</td><td>无</td></tr></tbody></table></div><h4 id="teacher"><a href="#teacher" class="headerlink" title="teacher"></a>teacher</h4><div class="table-container"><table><thead><tr><th>字段</th><th>类型</th><th>描述</th><th>约束</th></tr></thead><tbody><tr><td>name</td><td>varchar</td><td>讲师名称</td><td>not null</td></tr><tr><td>college</td><td>varchar</td><td>所属单位</td><td>not null</td></tr><tr><td>intro</td><td>text</td><td>老师简介</td><td>无</td></tr><tr><td>phone</td><td>varchar</td><td>手机号码</td><td>无</td></tr><tr><td>office</td><td>varchar</td><td>办公地址</td><td>无</td></tr><tr><td>email</td><td>varchar</td><td>邮箱</td><td>无</td></tr><tr><td>image_url</td><td>varchar</td><td>导师照片 url</td><td>无</td></tr><tr><td>teach_form</td><td>varchar</td><td>授课形式</td><td>无</td></tr></tbody></table></div><h4 id="teach-topic"><a href="#teach-topic" class="headerlink" title="teach_topic"></a>teach_topic</h4><div class="table-container"><table><thead><tr><th>字段</th><th>类型</th><th>描述</th><th>约束</th></tr></thead><tbody><tr><td>teacher_id</td><td>int</td><td>讲师 id</td><td>外键，引用自 teacher 表的 id 属性</td></tr><tr><td>topic</td><td>varchar</td><td>授课专题</td><td>not null</td></tr></tbody></table></div><h3 id="课程信息"><a href="#课程信息" class="headerlink" title="课程信息"></a>课程信息</h3><h4 id="course"><a href="#course" class="headerlink" title="course"></a>course</h4><div class="table-container"><table><thead><tr><th>字段</th><th>类型</th><th>描述</th><th>约束</th></tr></thead><tbody><tr><td>course_name</td><td>varchar</td><td>课程名称</td><td>not null</td></tr><tr><td>teacher_id</td><td>int</td><td>讲师 id</td><td>外键，引用自 teacher 表的 id 属性</td></tr><tr><td>start_time</td><td>datetime</td><td>上课开始时间</td><td>not null</td></tr><tr><td>end_time</td><td>datetime</td><td>上课结束时间</td><td>not null</td></tr><tr><td>course_id</td><td>varchar</td><td>课程编号</td><td>primary key</td></tr><tr><td>location</td><td>varchar</td><td>上课地址</td><td>not null</td></tr></tbody></table></div><h4 id="course-student"><a href="#course-student" class="headerlink" title="course_student"></a>course_student</h4><div class="table-container"><table><thead><tr><th>字段</th><th>类型</th><th>描述</th><th>约束</th></tr></thead><tbody><tr><td>course_id</td><td>varchar</td><td>课程编号</td><td>外键，引用自 course 表的 course_id 属性</td></tr><tr><td>stu_id</td><td>varchar</td><td>学生学号</td><td>外键，引用自 student 表的 stu_id 属性</td></tr></tbody></table></div><h3 id="评价模板"><a href="#评价模板" class="headerlink" title="评价模板"></a>评价模板</h3><h4 id="comment-template"><a href="#comment-template" class="headerlink" title="comment_template"></a>comment_template</h4><div class="table-container"><table><thead><tr><th>字段</th><th>类型</th><th>描述</th><th>约束</th></tr></thead><tbody><tr><td>template_name</td><td>varchar</td><td>模板名称</td><td>not null</td></tr></tbody></table></div><h4 id="template-question"><a href="#template-question" class="headerlink" title="template_question"></a>template_question</h4><div class="table-container"><table><thead><tr><th>字段</th><th>类型</th><th>描述</th><th>约束</th></tr></thead><tbody><tr><td>template_id</td><td>int</td><td>模板 id</td><td>外键，引用自 comment_template 表的 id 属性</td></tr><tr><td>question</td><td>text</td><td>问题</td><td>not null</td></tr><tr><td>_type</td><td>tinyint</td><td>问题类型，0为打分题，1为问答题，其余待定</td><td>not null</td></tr></tbody></table></div><h3 id="评价信息"><a href="#评价信息" class="headerlink" title="评价信息"></a>评价信息</h3><h4 id="course-comment"><a href="#course-comment" class="headerlink" title="course_comment"></a>course_comment</h4><div class="table-container"><table><thead><tr><th>字段</th><th>类型</th><th>描述</th><th>约束</th></tr></thead><tbody><tr><td>course_id</td><td>varchar</td><td>课程编号</td><td>外键，引用自 course 表的 course_id 属性</td></tr><tr><td>template_id</td><td>int</td><td>模板 id</td><td>外键，引用自 comment_template 表的 id 属性</td></tr></tbody></table></div><h4 id="comment"><a href="#comment" class="headerlink" title="comment"></a>comment</h4><div class="table-container"><table><thead><tr><th>字段</th><th>类型</th><th>描述</th><th>约束</th></tr></thead><tbody><tr><td>course_id</td><td>varchar</td><td>课程编号</td><td>外键，引用自 course 表的 course_id 属性</td></tr><tr><td>stu_id</td><td>varchar</td><td>学生学号</td><td>外键，引用自 student 表的 stu_id 属性</td></tr><tr><td>star</td><td>tinyint</td><td>1为精选评论</td><td>无</td></tr></tbody></table></div><h4 id="comment-result"><a href="#comment-result" class="headerlink" title="comment_result"></a>comment_result</h4><div class="table-container"><table><thead><tr><th>字段</th><th>类型</th><th>描述</th><th>约束</th></tr></thead><tbody><tr><td>comment_id</td><td>int</td><td>评价 id</td><td>外键，引用自 comment 表的 id 属性</td></tr><tr><td>question_id</td><td>int</td><td>问题 id</td><td>外键，引用自 template_question 表的 id 属性</td></tr><tr><td>result</td><td>text</td><td>问题结果，根据问题类型来决定存储值类型</td><td>not null</td></tr></tbody></table></div>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;数据库设计&quot;&gt;&lt;a href=&quot;#数据库设计&quot; class=&quot;headerlink&quot; title=&quot;数据库设计&quot;&gt;&lt;/a&gt;数据库设计&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;以下所有表默认自带一个自增 &lt;code&gt;id&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;以下所有表默认自带 &lt;code&gt;created_at&lt;/code&gt; 和 &lt;code&gt;updated_at&lt;/code&gt; 两个字段&lt;/li&gt;
&lt;li&gt;为了方便查询，以下所有下划线命名法在实际设计中可能全部转为驼峰命名法
    
    </summary>
    
    
      <category term="数据库" scheme="http://Bithub00.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>API接口设计</title>
    <link href="http://Bithub00.com/2019/04/10/api/"/>
    <id>http://Bithub00.com/2019/04/10/api/</id>
    <published>2019-04-10T08:50:19.820Z</published>
    <updated>2019-04-10T08:52:14.750Z</updated>
    
    <content type="html"><![CDATA[<h2 id="API-接口设计"><a href="#API-接口设计" class="headerlink" title="API 接口设计"></a>API 接口设计</h2><h3 id="接口地址"><a href="#接口地址" class="headerlink" title="接口地址"></a>接口地址</h3><div class="table-container"><table><thead><tr><th style="text-align:center">环境</th><th style="text-align:center">URL</th></tr></thead><tbody><tr><td style="text-align:center">开发环境</td><td style="text-align:center"><code>http://like.suevily.cn/</code></td></tr><tr><td style="text-align:center">生产环境</td><td style="text-align:center">待定</td></tr></tbody></table></div><h3 id="通用"><a href="#通用" class="headerlink" title="通用"></a>通用</h3><ol><li>以下接口分为开放接口和私有接口<ul><li>开放接口：无需登录校验即可请求</li><li>私有接口：需校验登录 token 方可请求</li></ul></li><li>以下所有接口 url 都默认自带 <code>/api</code> 前缀<a id="more"></a></li><li>token 在使用统一身份验证成功登录后会附带到 redirect url 的 query 参数上，前端需自行存储，开发环境的 redirect url 为 <code>http://localhost:8081/#/</code></li><li><strong>私有接口请求方法</strong>：将 token 附在请求 Headers 中的 Authorization 字段上，value 格式为 <code>Bearer ${token}</code> （PS: 建议使用 postman 进行接口测试）</li><li>前端在拿到返回数据时务必先检查 code 是否为零，如若不为零，需给用户正确的反馈，回传数据遵循以下格式：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  code: <span class="built_in">Number</span>,</span><br><span class="line">  data: <span class="built_in">Object</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>code</th><th>说明</th></tr></thead><tbody><tr><td>0</td><td>成功</td></tr><tr><td>-1</td><td>未知错误，查看 message</td></tr><tr><td>1</td><td>拒绝访问</td></tr><tr><td>2</td><td>无效的请求参数</td></tr><tr><td>3</td><td>上传图片出错</td></tr><tr><td>4</td><td>token 校验失败</td></tr><tr><td>其它</td><td>待定</td></tr></tbody></table></div><hr><h3 id="获取用户信息"><a href="#获取用户信息" class="headerlink" title="获取用户信息"></a>获取用户信息</h3><div class="table-container"><table><thead><tr><th style="text-align:center">method</th><th style="text-align:center">url</th><th style="text-align:center">type</th></tr></thead><tbody><tr><td style="text-align:center">GET</td><td style="text-align:center">/user</td><td style="text-align:center">私有接口</td></tr></tbody></table></div><h4 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h4><p>无</p><h4 id="返回参数"><a href="#返回参数" class="headerlink" title="返回参数"></a>返回参数</h4><div class="table-container"><table><thead><tr><th>参数</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>cardId</td><td>String</td><td>校园卡号</td></tr><tr><td>name</td><td>String</td><td>姓名</td></tr><tr><td>college</td><td>String</td><td>学院</td></tr><tr><td>stuId</td><td>String</td><td>学号</td></tr><tr><td>privilege</td><td>Number</td><td>0 为超级管理员，1为普通管理员，如没有该字段则为普通师生</td></tr></tbody></table></div><hr><h3 id="获取管理人员"><a href="#获取管理人员" class="headerlink" title="获取管理人员"></a>获取管理人员</h3><div class="table-container"><table><thead><tr><th style="text-align:center">method</th><th style="text-align:center">url</th><th style="text-align:center">type</th></tr></thead><tbody><tr><td style="text-align:center">POST</td><td style="text-align:center">/getManagers</td><td style="text-align:center">私有接口</td></tr></tbody></table></div><h4 id="请求参数-1"><a href="#请求参数-1" class="headerlink" title="请求参数"></a>请求参数</h4><div class="table-container"><table><thead><tr><th>参数</th><th>类型</th><th>说明</th><th>必填</th></tr></thead><tbody><tr><td>perPage</td><td>Number</td><td>每页包含元素个数</td><td>是</td></tr><tr><td>page</td><td>Number</td><td>页码，第几页</td><td>是</td></tr></tbody></table></div><h4 id="返回参数-1"><a href="#返回参数-1" class="headerlink" title="返回参数"></a>返回参数</h4><div class="table-container"><table><thead><tr><th>参数</th><th>字段</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>length</td><td>-</td><td>Number</td><td>管理人员总数</td></tr><tr><td>managers</td><td>-</td><td>Array</td><td>一个包含指定页数内所有管理人员的数组</td></tr><tr><td>-</td><td>id</td><td>Number</td><td>该管理员在数据库中的唯一标识</td></tr><tr><td>-</td><td>name</td><td>String</td><td>姓名</td></tr><tr><td>-</td><td>cardId</td><td>String</td><td>校园卡号</td></tr><tr><td>-</td><td>authorizer</td><td>String</td><td>授权人姓名</td></tr><tr><td>-</td><td>createdAt</td><td>Date</td><td>添加时间戳</td></tr><tr><td>-</td><td>privilege</td><td>String</td><td>管理权限，超级管理员或普通管理员</td></tr></tbody></table></div><hr><h3 id="添加管理人员"><a href="#添加管理人员" class="headerlink" title="添加管理人员"></a>添加管理人员</h3><div class="table-container"><table><thead><tr><th style="text-align:center">method</th><th style="text-align:center">url</th><th style="text-align:center">type</th></tr></thead><tbody><tr><td style="text-align:center">POST</td><td style="text-align:center">/addManager</td><td style="text-align:center">私有接口</td></tr></tbody></table></div><h4 id="请求参数-2"><a href="#请求参数-2" class="headerlink" title="请求参数"></a>请求参数</h4><div class="table-container"><table><thead><tr><th>参数</th><th>类型</th><th>说明</th><th>必填</th></tr></thead><tbody><tr><td>name</td><td>String</td><td>姓名</td><td>是</td></tr><tr><td>cardId</td><td>String</td><td>校园卡号</td><td>是</td></tr><tr><td>privilege</td><td>Number</td><td>权限，0 为超级管理员，1为普通管理员</td><td>是</td></tr></tbody></table></div><h4 id="返回参数-2"><a href="#返回参数-2" class="headerlink" title="返回参数"></a>返回参数</h4><div class="table-container"><table><thead><tr><th>参数</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>message</td><td>String</td><td>添加结果</td></tr></tbody></table></div><h4 id="错误代码"><a href="#错误代码" class="headerlink" title="错误代码"></a>错误代码</h4><div class="table-container"><table><thead><tr><th>code</th><th>说明</th></tr></thead><tbody><tr><td>1001</td><td>校园卡号冲突</td></tr></tbody></table></div><hr><h3 id="修改管理人员"><a href="#修改管理人员" class="headerlink" title="修改管理人员"></a>修改管理人员</h3><div class="table-container"><table><thead><tr><th style="text-align:center">method</th><th style="text-align:center">url</th><th style="text-align:center">type</th></tr></thead><tbody><tr><td style="text-align:center">POST</td><td style="text-align:center">/updateManager</td><td style="text-align:center">私有接口</td></tr></tbody></table></div><h4 id="请求参数-3"><a href="#请求参数-3" class="headerlink" title="请求参数"></a>请求参数</h4><div class="table-container"><table><thead><tr><th>参数</th><th>类型</th><th>说明</th><th>必填</th></tr></thead><tbody><tr><td>id</td><td>Number</td><td>要修改的管理员的id</td><td>是</td></tr><tr><td>name</td><td>String</td><td>姓名</td><td>是</td></tr><tr><td>cardId</td><td>String</td><td>校园卡号</td><td>是</td></tr><tr><td>privilege</td><td>Number</td><td>权限，0 为超级管理员，1为普通管理员</td><td>是</td></tr></tbody></table></div><h4 id="返回参数-3"><a href="#返回参数-3" class="headerlink" title="返回参数"></a>返回参数</h4><div class="table-container"><table><thead><tr><th>参数</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>message</td><td>String</td><td>修改结果</td></tr></tbody></table></div><h4 id="错误代码-1"><a href="#错误代码-1" class="headerlink" title="错误代码"></a>错误代码</h4><div class="table-container"><table><thead><tr><th>code</th><th>说明</th></tr></thead><tbody><tr><td>1002</td><td>当你要把最后一个超级管理员更改为普通管理员时会出错</td></tr></tbody></table></div><hr><h3 id="删除管理人员"><a href="#删除管理人员" class="headerlink" title="删除管理人员"></a>删除管理人员</h3><div class="table-container"><table><thead><tr><th style="text-align:center">method</th><th style="text-align:center">url</th><th style="text-align:center">type</th></tr></thead><tbody><tr><td style="text-align:center">POST</td><td style="text-align:center">/deleteManager</td><td style="text-align:center">私有接口</td></tr></tbody></table></div><h4 id="请求参数-4"><a href="#请求参数-4" class="headerlink" title="请求参数"></a>请求参数</h4><div class="table-container"><table><thead><tr><th>参数</th><th>类型</th><th>说明</th><th>必填</th></tr></thead><tbody><tr><td>id</td><td>String</td><td>要删除的管理员的id</td><td>是</td></tr></tbody></table></div><h4 id="返回参数-4"><a href="#返回参数-4" class="headerlink" title="返回参数"></a>返回参数</h4><div class="table-container"><table><thead><tr><th>参数</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>message</td><td>String</td><td>删除结果</td></tr></tbody></table></div><h4 id="错误代码-2"><a href="#错误代码-2" class="headerlink" title="错误代码"></a>错误代码</h4><div class="table-container"><table><thead><tr><th>code</th><th>说明</th></tr></thead><tbody><tr><td>1003</td><td>当你要把最后一个超级管理员删除时会出错</td></tr></tbody></table></div><hr><h3 id="搜索管理人员"><a href="#搜索管理人员" class="headerlink" title="搜索管理人员"></a>搜索管理人员</h3><div class="table-container"><table><thead><tr><th style="text-align:center">method</th><th style="text-align:center">url</th><th style="text-align:center">type</th></tr></thead><tbody><tr><td style="text-align:center">POST</td><td style="text-align:center">/searchManagers</td><td style="text-align:center">私有接口</td></tr></tbody></table></div><h4 id="请求参数-5"><a href="#请求参数-5" class="headerlink" title="请求参数"></a>请求参数</h4><div class="table-container"><table><thead><tr><th>参数</th><th>类型</th><th>说明</th><th>必填</th></tr></thead><tbody><tr><td>keyword</td><td>String</td><td>搜索关键词</td><td>是</td></tr><tr><td>maxLength</td><td>Number</td><td>搜索结果最大返回数目（默认为5）</td><td>否</td></tr></tbody></table></div><h4 id="返回参数-5"><a href="#返回参数-5" class="headerlink" title="返回参数"></a>返回参数</h4><div class="table-container"><table><thead><tr><th>参数</th><th>字段</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>managers</td><td>-</td><td>Array</td><td>满足搜索关键词的管理员数组</td></tr><tr><td>-</td><td>id</td><td>Number</td><td>该管理员在数据库中的唯一标识</td></tr><tr><td>-</td><td>name</td><td>String</td><td>姓名</td></tr><tr><td>-</td><td>cardId</td><td>String</td><td>校园卡号</td></tr><tr><td>-</td><td>authorizer</td><td>String</td><td>授权人姓名</td></tr><tr><td>-</td><td>createdAt</td><td>Date</td><td>添加时间戳</td></tr><tr><td>-</td><td>privilege</td><td>String</td><td>管理权限，超级管理员或普通管理员</td></tr></tbody></table></div><hr><h3 id="获取课程信息"><a href="#获取课程信息" class="headerlink" title="获取课程信息"></a>获取课程信息</h3><div class="table-container"><table><thead><tr><th>method</th><th>url</th><th>type</th></tr></thead><tbody><tr><td>POST</td><td>/getCourses</td><td>私有接口</td></tr></tbody></table></div><h4 id="请求参数-6"><a href="#请求参数-6" class="headerlink" title="请求参数"></a>请求参数</h4><div class="table-container"><table><thead><tr><th>参数</th><th>类型</th><th>说明</th><th>必填</th></tr></thead><tbody><tr><td>perPage</td><td>Number</td><td>每页包含元素个数</td><td>是</td></tr><tr><td>page</td><td>Number</td><td>页码，第几页</td><td>是</td></tr></tbody></table></div><h4 id="返回参数-6"><a href="#返回参数-6" class="headerlink" title="返回参数"></a>返回参数</h4><div class="table-container"><table><thead><tr><th>参数</th><th>字段</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>length</td><td>-</td><td>Number</td><td>课程总数</td></tr><tr><td>courses</td><td>-</td><td>Array</td><td>一个包含指定页数所有课程信息的数组</td></tr><tr><td>-</td><td>courseName</td><td>String</td><td>课程名称</td></tr><tr><td>-</td><td>teacher</td><td>String</td><td>讲师姓名</td></tr><tr><td></td><td>time</td><td>String</td><td>上课时间，前端直接展示即可</td></tr><tr><td></td><td>courseId</td><td>String</td><td>课程编号</td></tr><tr><td></td><td>location</td><td>String</td><td>上课地点</td></tr><tr><td></td><td>studentCount</td><td>Number</td><td>选课人数</td></tr></tbody></table></div><hr><h3 id="根据课程编号获取课程详细信息"><a href="#根据课程编号获取课程详细信息" class="headerlink" title="根据课程编号获取课程详细信息"></a>根据课程编号获取课程详细信息</h3><div class="table-container"><table><thead><tr><th>method</th><th>url</th><th>type</th></tr></thead><tbody><tr><td>POST</td><td>/getCourseInfo</td><td>私有接口</td></tr></tbody></table></div><h4 id="请求参数-7"><a href="#请求参数-7" class="headerlink" title="请求参数"></a>请求参数</h4><div class="table-container"><table><thead><tr><th>参数</th><th>类型</th><th>说明</th><th>必填</th></tr></thead><tbody><tr><td>courseId</td><td>String</td><td>课程编号</td><td>是</td></tr></tbody></table></div><h4 id="返回参数-7"><a href="#返回参数-7" class="headerlink" title="返回参数"></a>返回参数</h4><div class="table-container"><table><thead><tr><th>参数</th><th>字段</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>courseName</td><td>-</td><td>String</td><td>课程名称</td></tr><tr><td>teacherId</td><td>-</td><td>String</td><td>讲师在数据库中的id</td></tr><tr><td>teacherName</td><td>-</td><td>String</td><td>讲师姓名</td></tr><tr><td>startTime</td><td>-</td><td>Date</td><td>上课开始时间戳</td></tr><tr><td>endTime</td><td>-</td><td>Date</td><td>上课结束时间戳</td></tr><tr><td>location</td><td>-</td><td>String</td><td>上课地点</td></tr><tr><td>students</td><td>-</td><td>Array</td><td>一个包含指定课程选课所有学生信息的数组</td></tr><tr><td></td><td>name</td><td>String</td><td>学生姓名</td></tr><tr><td></td><td>stuId</td><td>String</td><td>学生学号</td></tr></tbody></table></div><h4 id="错误代码-3"><a href="#错误代码-3" class="headerlink" title="错误代码"></a>错误代码</h4><div class="table-container"><table><thead><tr><th>code</th><th>说明</th></tr></thead><tbody><tr><td>2003</td><td>课程编号错误</td></tr></tbody></table></div><hr><h3 id="查询选课名单"><a href="#查询选课名单" class="headerlink" title="查询选课名单"></a>查询选课名单</h3><div class="table-container"><table><thead><tr><th>method</th><th>url</th><th>type</th></tr></thead><tbody><tr><td>POST</td><td>/getStudentList</td><td>私有接口</td></tr></tbody></table></div><h4 id="请求参数-8"><a href="#请求参数-8" class="headerlink" title="请求参数"></a>请求参数</h4><div class="table-container"><table><thead><tr><th>参数</th><th>类型</th><th>说明</th><th>必填</th></tr></thead><tbody><tr><td>courseId</td><td>String</td><td>课程编号</td><td>是</td></tr><tr><td>perPage</td><td>Number</td><td>每页包含元素个数</td><td>是</td></tr><tr><td>page</td><td>Number</td><td>页码，第几页</td><td>是</td></tr></tbody></table></div><h4 id="返回参数-8"><a href="#返回参数-8" class="headerlink" title="返回参数"></a>返回参数</h4><div class="table-container"><table><thead><tr><th>参数</th><th>字段</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>length</td><td>-</td><td>Number</td><td>选课总人数</td></tr><tr><td>students</td><td>-</td><td>Array</td><td>一个包含指定课程选课所有学生信息的数组</td></tr><tr><td></td><td>name</td><td>String</td><td>学生姓名</td></tr><tr><td></td><td>stuId</td><td>String</td><td>学生学号</td></tr></tbody></table></div><hr><h3 id="删除课程"><a href="#删除课程" class="headerlink" title="删除课程"></a>删除课程</h3><div class="table-container"><table><thead><tr><th>method</th><th>url</th><th>type</th></tr></thead><tbody><tr><td>POST</td><td>/deleteCourse</td><td>私有接口</td></tr></tbody></table></div><h4 id="请求参数-9"><a href="#请求参数-9" class="headerlink" title="请求参数"></a>请求参数</h4><div class="table-container"><table><thead><tr><th>参数</th><th>类型</th><th>说明</th><th>必填</th></tr></thead><tbody><tr><td>courseId</td><td>String</td><td>要删除的课程的课程编号</td><td>是</td></tr></tbody></table></div><h4 id="返回参数-9"><a href="#返回参数-9" class="headerlink" title="返回参数"></a>返回参数</h4><div class="table-container"><table><thead><tr><th>参数</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>message</td><td>String</td><td>删除结果</td></tr></tbody></table></div><hr><h3 id="搜索课程"><a href="#搜索课程" class="headerlink" title="搜索课程"></a>搜索课程</h3><div class="table-container"><table><thead><tr><th>method</th><th>url</th><th>type</th></tr></thead><tbody><tr><td>POST</td><td>/searchCourses</td><td>私有接口</td></tr></tbody></table></div><h4 id="请求参数-10"><a href="#请求参数-10" class="headerlink" title="请求参数"></a>请求参数</h4><div class="table-container"><table><thead><tr><th>参数</th><th>类型</th><th>说明</th><th>必填</th></tr></thead><tbody><tr><td>keyword</td><td>String</td><td>搜索关键词</td><td>是</td></tr><tr><td>maxLength</td><td>Number</td><td>搜索结果最大返回数目（默认为5）</td><td>否</td></tr></tbody></table></div><h4 id="返回参数-10"><a href="#返回参数-10" class="headerlink" title="返回参数"></a>返回参数</h4><div class="table-container"><table><thead><tr><th>参数</th><th>字段</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>courses</td><td>-</td><td>Array</td><td>满足搜索关键词的课程数组</td></tr><tr><td>-</td><td>courseName</td><td>String</td><td>课程名称</td></tr><tr><td>-</td><td>teacher</td><td>String</td><td>讲师姓名</td></tr><tr><td></td><td>time</td><td>String</td><td>上课时间，前端直接展示即可</td></tr><tr><td></td><td>courseId</td><td>String</td><td>课程编号</td></tr><tr><td></td><td>location</td><td>String</td><td>上课地点</td></tr><tr><td></td><td>studentCount</td><td>Number</td><td>选课人数</td></tr></tbody></table></div><hr><h3 id="生成课程"><a href="#生成课程" class="headerlink" title="生成课程"></a>生成课程</h3><div class="table-container"><table><thead><tr><th>method</th><th>url</th><th>type</th></tr></thead><tbody><tr><td>POST</td><td>/addCourse</td><td>私有接口</td></tr></tbody></table></div><h4 id="请求参数-11"><a href="#请求参数-11" class="headerlink" title="请求参数"></a>请求参数</h4><div class="table-container"><table><thead><tr><th>参数</th><th>字段</th><th>类型</th><th>说明</th><th>必填</th></tr></thead><tbody><tr><td>courseName</td><td>-</td><td>String</td><td>课程名称</td><td>是</td></tr><tr><td>teacherId</td><td>-</td><td>String</td><td>讲师在数据库中的id</td><td>是</td></tr><tr><td>startTime</td><td>-</td><td>Date</td><td>上课开始时间戳</td><td>是</td></tr><tr><td>endTime</td><td>-</td><td>Date</td><td>上课结束时间戳</td><td>是</td></tr><tr><td>location</td><td>-</td><td>String</td><td>上课地点</td><td>是</td></tr><tr><td>students</td><td>-</td><td>Array</td><td>选课学生数组</td><td>是</td></tr><tr><td>-</td><td>name</td><td>String</td><td>学生姓名</td><td>是</td></tr><tr><td>-</td><td>stuId</td><td>String</td><td>学生学号</td><td>是</td></tr></tbody></table></div><h4 id="返回参数-11"><a href="#返回参数-11" class="headerlink" title="返回参数"></a>返回参数</h4><div class="table-container"><table><thead><tr><th>参数</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>courseId</td><td>String</td><td>生成的课程编号</td></tr></tbody></table></div><h4 id="错误代码-4"><a href="#错误代码-4" class="headerlink" title="错误代码"></a>错误代码</h4><div class="table-container"><table><thead><tr><th>code</th><th>说明</th></tr></thead><tbody><tr><td>2001</td><td>讲师不存在</td></tr></tbody></table></div><hr><h3 id="修改课程"><a href="#修改课程" class="headerlink" title="修改课程"></a>修改课程</h3><div class="table-container"><table><thead><tr><th>method</th><th>url</th><th>type</th></tr></thead><tbody><tr><td>POST</td><td>/updateCourse</td><td>私有接口</td></tr></tbody></table></div><h4 id="请求参数-12"><a href="#请求参数-12" class="headerlink" title="请求参数"></a>请求参数</h4><div class="table-container"><table><thead><tr><th>参数</th><th>字段</th><th>类型</th><th>说明</th><th>必填</th></tr></thead><tbody><tr><td>courseId</td><td>-</td><td>String</td><td>课程编号（乱传打爆你▄︻┻═┳一）</td><td>是</td></tr><tr><td>courseName</td><td>-</td><td>String</td><td>课程名称</td><td>是</td></tr><tr><td>teacherId</td><td>-</td><td>String</td><td>讲师在数据库中的id</td><td>是</td></tr><tr><td>startTime</td><td>-</td><td>String</td><td>上课开始时间戳</td><td>是</td></tr><tr><td>endTime</td><td>-</td><td>String</td><td>上课结束时间戳</td><td>是</td></tr><tr><td>location</td><td>-</td><td>String</td><td>上课地点</td><td>是</td></tr><tr><td>students</td><td>-</td><td>Array</td><td>选课学生数组</td><td>是</td></tr><tr><td>-</td><td>name</td><td>String</td><td>学生姓名</td><td>是</td></tr><tr><td>-</td><td>stuId</td><td>String</td><td>学生学号</td><td>是</td></tr></tbody></table></div><h4 id="返回参数-12"><a href="#返回参数-12" class="headerlink" title="返回参数"></a>返回参数</h4><div class="table-container"><table><thead><tr><th>参数</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>message</td><td>String</td><td>修改结果</td></tr></tbody></table></div><h4 id="错误代码-5"><a href="#错误代码-5" class="headerlink" title="错误代码"></a>错误代码</h4><div class="table-container"><table><thead><tr><th>code</th><th>说明</th></tr></thead><tbody><tr><td>2001</td><td>讲师不存在</td></tr><tr><td>2002</td><td>课程编号不存在</td></tr></tbody></table></div><hr><h3 id="获取讲师信息"><a href="#获取讲师信息" class="headerlink" title="获取讲师信息"></a>获取讲师信息</h3><div class="table-container"><table><thead><tr><th>method</th><th>url</th><th>type</th></tr></thead><tbody><tr><td>POST</td><td>/getTeachers</td><td>私有接口</td></tr></tbody></table></div><h4 id="请求参数-13"><a href="#请求参数-13" class="headerlink" title="请求参数"></a>请求参数</h4><div class="table-container"><table><thead><tr><th>参数</th><th>类型</th><th>说明</th><th>必填</th></tr></thead><tbody><tr><td>perPage</td><td>Number</td><td>每页包含元素个数</td><td>是</td></tr><tr><td>page</td><td>Number</td><td>页码，第几页</td><td>是</td></tr></tbody></table></div><h4 id="返回参数-13"><a href="#返回参数-13" class="headerlink" title="返回参数"></a>返回参数</h4><div class="table-container"><table><thead><tr><th>参数</th><th>字段</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>length</td><td>-</td><td>Number</td><td>讲师总数</td></tr><tr><td>teachers</td><td>-</td><td>Array</td><td>一个包含指定页数所有讲师信息的数组</td></tr><tr><td>-</td><td>id</td><td>Number</td><td>该讲师在数据库的唯一标识</td></tr><tr><td>-</td><td>name</td><td>String</td><td>讲师姓名</td></tr><tr><td></td><td>imageUrl</td><td>String</td><td>讲师照片的 url</td></tr></tbody></table></div><hr><h3 id="删除讲师"><a href="#删除讲师" class="headerlink" title="删除讲师"></a>删除讲师</h3><div class="table-container"><table><thead><tr><th>method</th><th>url</th><th>type</th></tr></thead><tbody><tr><td>POST</td><td>/deleteTeacher</td><td>私有接口</td></tr></tbody></table></div><h4 id="请求参数-14"><a href="#请求参数-14" class="headerlink" title="请求参数"></a>请求参数</h4><div class="table-container"><table><thead><tr><th>参数</th><th>类型</th><th>说明</th><th>必填</th></tr></thead><tbody><tr><td>id</td><td>Number</td><td>讲师 id ，在 <code>/getTeachers</code> 接口获取到的</td><td>是</td></tr></tbody></table></div><h4 id="返回参数-14"><a href="#返回参数-14" class="headerlink" title="返回参数"></a>返回参数</h4><div class="table-container"><table><thead><tr><th>参数</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>message</td><td>String</td><td>删除结果</td></tr></tbody></table></div><hr><h3 id="搜索讲师"><a href="#搜索讲师" class="headerlink" title="搜索讲师"></a>搜索讲师</h3><div class="table-container"><table><thead><tr><th>method</th><th>url</th><th>type</th></tr></thead><tbody><tr><td>POST</td><td>/searchTeachers</td><td>私有接口</td></tr></tbody></table></div><h4 id="请求参数-15"><a href="#请求参数-15" class="headerlink" title="请求参数"></a>请求参数</h4><div class="table-container"><table><thead><tr><th>参数</th><th>类型</th><th>说明</th><th>必填</th></tr></thead><tbody><tr><td>keyword</td><td>String</td><td>搜索关键词</td><td>是</td></tr><tr><td>maxLength</td><td>Number</td><td>搜索结果最大返回数目（默认为5）</td><td>否</td></tr></tbody></table></div><h4 id="返回参数-15"><a href="#返回参数-15" class="headerlink" title="返回参数"></a>返回参数</h4><div class="table-container"><table><thead><tr><th>参数</th><th>字段</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>teachers</td><td>-</td><td>Array</td><td>满足搜索关键字的讲师数组</td></tr><tr><td></td><td>id</td><td>Number</td><td>该讲师在数据库的唯一标识</td></tr><tr><td>-</td><td>name</td><td>String</td><td>讲师姓名</td></tr><tr><td></td><td>imageUrl</td><td>String</td><td>讲师照片的 url</td></tr></tbody></table></div><hr><h3 id="查询一个讲师的详细信息"><a href="#查询一个讲师的详细信息" class="headerlink" title="查询一个讲师的详细信息"></a>查询一个讲师的详细信息</h3><div class="table-container"><table><thead><tr><th>method</th><th>url</th><th>type</th></tr></thead><tbody><tr><td>POST</td><td>/getTeacherInfo</td><td>私有接口</td></tr></tbody></table></div><h4 id="请求参数-16"><a href="#请求参数-16" class="headerlink" title="请求参数"></a>请求参数</h4><div class="table-container"><table><thead><tr><th>参数</th><th>类型</th><th>说明</th><th>必填</th></tr></thead><tbody><tr><td>id</td><td>Number</td><td>讲师 id ，在 <code>/getTeachers</code> 接口获取到的</td><td>是</td></tr></tbody></table></div><h4 id="返回参数-16"><a href="#返回参数-16" class="headerlink" title="返回参数"></a>返回参数</h4><div class="table-container"><table><thead><tr><th>参数</th><th>字段</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>name</td><td>-</td><td>String</td><td>讲师姓名</td></tr><tr><td>college</td><td>-</td><td>String</td><td>所属单位</td></tr><tr><td>intro</td><td>-</td><td>String</td><td>老师简介</td></tr><tr><td>phone</td><td>-</td><td>String</td><td>手机号码</td></tr><tr><td>office</td><td>-</td><td>String</td><td>办公地址</td></tr><tr><td>email</td><td>-</td><td>String</td><td>邮箱地址</td></tr><tr><td>imageUrl</td><td>-</td><td>String</td><td>导师照片 url</td></tr><tr><td>teachForm</td><td>-</td><td>String</td><td>授课形式</td></tr><tr><td>teachTopic</td><td>-</td><td>Array</td><td>该讲师授课专题的数组</td></tr><tr><td></td><td>-</td><td>String</td><td>授课专题</td></tr></tbody></table></div><hr><h3 id="图片上传接口"><a href="#图片上传接口" class="headerlink" title="图片上传接口"></a>图片上传接口</h3><div class="table-container"><table><thead><tr><th>method</th><th>url</th><th>type</th></tr></thead><tbody><tr><td>POST</td><td>/upload</td><td>私有接口</td></tr></tbody></table></div><h4 id="请求参数-17"><a href="#请求参数-17" class="headerlink" title="请求参数"></a>请求参数</h4><div class="table-container"><table><thead><tr><th>参数</th><th>类型</th><th>说明</th><th>必填</th></tr></thead><tbody><tr><td>-</td><td>FormData</td><td>图片数据</td><td>是</td></tr></tbody></table></div><h4 id="返回参数-17"><a href="#返回参数-17" class="headerlink" title="返回参数"></a>返回参数</h4><div class="table-container"><table><thead><tr><th>参数</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>url</td><td>String</td><td>图片 url</td></tr></tbody></table></div><hr><h3 id="添加讲师"><a href="#添加讲师" class="headerlink" title="添加讲师"></a>添加讲师</h3><div class="table-container"><table><thead><tr><th>method</th><th>url</th><th>type</th></tr></thead><tbody><tr><td>POST</td><td>/addTeacher</td><td>私有接口</td></tr></tbody></table></div><h4 id="请求参数-18"><a href="#请求参数-18" class="headerlink" title="请求参数"></a>请求参数</h4><div class="table-container"><table><thead><tr><th>参数</th><th>字段</th><th>类型</th><th>说明</th><th>必填</th></tr></thead><tbody><tr><td>name</td><td>-</td><td>String</td><td>讲师姓名</td><td>是</td></tr><tr><td>college</td><td>-</td><td>String</td><td>所属单位</td><td>是</td></tr><tr><td>intro</td><td>-</td><td>String</td><td>老师简介</td><td>是</td></tr><tr><td>phone</td><td>-</td><td>String</td><td>手机号码</td><td>是</td></tr><tr><td>office</td><td>-</td><td>String</td><td>办公地址</td><td>是</td></tr><tr><td>email</td><td>-</td><td>String</td><td>邮箱地址</td><td>是</td></tr><tr><td>imageUrl</td><td>-</td><td>String</td><td>导师照片 url</td><td>是</td></tr><tr><td>teachForm</td><td>-</td><td>String</td><td>授课形式</td><td>是</td></tr><tr><td>teachTopic</td><td>-</td><td>Array</td><td>该讲师授课专题的数组</td><td>是</td></tr><tr><td></td><td>-</td><td>String</td><td>授课专题</td><td>是</td></tr></tbody></table></div><h4 id="返回参数-18"><a href="#返回参数-18" class="headerlink" title="返回参数"></a>返回参数</h4><div class="table-container"><table><thead><tr><th>参数</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>id</td><td>Number</td><td>该讲师在数据库的唯一标识</td></tr></tbody></table></div><hr><h3 id="修改讲师信息"><a href="#修改讲师信息" class="headerlink" title="修改讲师信息"></a>修改讲师信息</h3><div class="table-container"><table><thead><tr><th>method</th><th>url</th><th>type</th></tr></thead><tbody><tr><td>POST</td><td>/updateTeacher</td><td>私有接口</td></tr></tbody></table></div><h4 id="请求参数-19"><a href="#请求参数-19" class="headerlink" title="请求参数"></a>请求参数</h4><div class="table-container"><table><thead><tr><th>参数</th><th>字段</th><th>类型</th><th>说明</th><th>必填</th></tr></thead><tbody><tr><td>id</td><td>-</td><td>Number</td><td>要修改的讲师的 id</td><td>是</td></tr><tr><td>name</td><td>-</td><td>String</td><td>讲师姓名</td><td>是</td></tr><tr><td>college</td><td>-</td><td>String</td><td>所属单位</td><td>是</td></tr><tr><td>intro</td><td>-</td><td>String</td><td>老师简介</td><td>是</td></tr><tr><td>phone</td><td>-</td><td>String</td><td>手机号码</td><td>是</td></tr><tr><td>office</td><td>-</td><td>String</td><td>办公地址</td><td>是</td></tr><tr><td>email</td><td>-</td><td>String</td><td>邮箱地址</td><td>是</td></tr><tr><td>imageUrl</td><td>-</td><td>String</td><td>导师照片 url</td><td>是</td></tr><tr><td>teachForm</td><td>-</td><td>String</td><td>授课形式</td><td>是</td></tr><tr><td>teachTopic</td><td>-</td><td>Array</td><td>该讲师授课专题的数组</td><td>是</td></tr><tr><td></td><td>-</td><td>String</td><td>授课专题</td><td>是</td></tr></tbody></table></div><h4 id="返回参数-19"><a href="#返回参数-19" class="headerlink" title="返回参数"></a>返回参数</h4><div class="table-container"><table><thead><tr><th>参数</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>message</td><td>String</td><td>修改结果</td></tr></tbody></table></div><h4 id="错误代码-6"><a href="#错误代码-6" class="headerlink" title="错误代码"></a>错误代码</h4><div class="table-container"><table><thead><tr><th>code</th><th>说明</th></tr></thead><tbody><tr><td>3001</td><td>指定 id 的老师不存在</td></tr></tbody></table></div>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;API-接口设计&quot;&gt;&lt;a href=&quot;#API-接口设计&quot; class=&quot;headerlink&quot; title=&quot;API 接口设计&quot;&gt;&lt;/a&gt;API 接口设计&lt;/h2&gt;&lt;h3 id=&quot;接口地址&quot;&gt;&lt;a href=&quot;#接口地址&quot; class=&quot;headerlink&quot; title=&quot;接口地址&quot;&gt;&lt;/a&gt;接口地址&lt;/h3&gt;&lt;div class=&quot;table-container&quot;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;环境&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;URL&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;开发环境&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;http://like.suevily.cn/&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;生产环境&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;待定&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;h3 id=&quot;通用&quot;&gt;&lt;a href=&quot;#通用&quot; class=&quot;headerlink&quot; title=&quot;通用&quot;&gt;&lt;/a&gt;通用&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;以下接口分为开放接口和私有接口&lt;ul&gt;
&lt;li&gt;开放接口：无需登录校验即可请求&lt;/li&gt;
&lt;li&gt;私有接口：需校验登录 token 方可请求&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;以下所有接口 url 都默认自带 &lt;code&gt;/api&lt;/code&gt; 前缀
    
    </summary>
    
    
      <category term="API" scheme="http://Bithub00.com/tags/API/"/>
    
      <category term="Node.js" scheme="http://Bithub00.com/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>AWS:S3 + Athena + Glue</title>
    <link href="http://Bithub00.com/2019/04/03/AWS/"/>
    <id>http://Bithub00.com/2019/04/03/AWS/</id>
    <published>2019-04-03T09:52:53.423Z</published>
    <updated>2019-08-07T07:58:35.080Z</updated>
    
    <content type="html"><![CDATA[<p><font size="3"><br>整理一下自己了解的S3、Athena和Glue</font><br><a id="more"></a></p><h2 id="S3"><a href="#S3" class="headerlink" title="S3"></a>S3</h2><p>AWS使用S3（Simple Storage Service）进行存储，它可以存储海量的数据，存储的往往是不常使用的冷数据，而且采取特定的Parquet格式进行列式存储或分区，可以节省存储空间而且提升查询性能。</p><p>使用S3存储动态数据会使得系统依赖于S3本身的可用性，可以通过增加缓存层或CDN(Content Deliver Network)服务来减轻影响。</p><p>S3提供REST接口,两个组成层次是容器(bucket)和对象(object)。容器是S3最上面的分类，所有的对象都放在容器里，因此容器名称必须是唯一的，每个对象都有唯一可识别的URL，应该尽量避免对容器进行操作，使用对象名称就可以实现分层次和分类了.</p><p>存储在S3的对象，除了本身的值以外,还会记录标头、元数据、访问控制列表等等，标头中存储了对象类型等信息，元数据就是用户自己定义的表头，为键值对，访问控制列表就是访问权限。因为S3有所谓偷窥对象的功能，即只读取对象的标头的信息，我们可以先看标头信息，再决定要不要把对象读取下来。</p><p>S3没有目录的概念，是扁平化的存储结构，“photo/1.jpg”和“photo/2.jpg”可能存在于不同的服务器集群。</p><h2 id="Athena"><a href="#Athena" class="headerlink" title="Athena"></a>Athena</h2><p>Athena是一个查询服务，可以使用标准的SQL来对S3上存储的数据进行查询。而且它是一个serverless的服务，不需要去考虑底层的硬件设施，只需要为查询服务付费。同时，Athena使用IAM来管理权限，部分操作需要对应的权限才能进行。</p><p>Athena使用SerDe来与各种数据格式进行交互，包括CSV,JSON和Parquet。在使用时进行指定。</p><h2 id="Glue"><a href="#Glue" class="headerlink" title="Glue"></a>Glue</h2><p>Glue是一个元数据系统，它维护了信息诸如数据具体存储的位置以及数据的结构，它本身还提供了ETL的能力。<br>Glue里面几个关键的概念是Database, Table, Crawler, Classifier, Job:</p><ul><li>Database 跟我们普通理解的数据库的概念是类似的，是一组table的逻辑集合。</li><li>Table 是数据的元数据，它定义数据保存在哪里(比如S3的路径)，有哪些column，怎么分区的。</li><li>Crawler 是元数据的爬虫，你给它一个路径，告诉它每天去爬一次，Crawler就可以及时把更新的元数据，比如新增的分区同步到Glue里面来供计算引擎消费。</li><li>Classifier 是数据结构的解析器，你给Crawler一个S3的路径它怎么就能解析出其中的结构呢，这就是Classifier要干的事情，Glue里面已经内置了一些Classfier, 用户也可以自定义Classifier。</li><li>Job是一个ETL脚本</li></ul><p><img src="https://s2.ax1x.com/2019/04/03/AgAio8.png" alt=""></p><h2 id="Glue与Athena"><a href="#Glue与Athena" class="headerlink" title="Glue与Athena"></a>Glue与Athena</h2><p>AWS Glue 是一项完全托管的 ETL (提取、转换和加载) 服务，能够对数据进行分类、清理和扩充，并在各种数据存储之间可靠地移动数据。AWS Glue 爬网程序自动从源数据推断数据库和表架构，从而将关联的元数据存储在 AWS Glue 数据目录中。在 Athena 中创建表时，可以选择使用 AWS Glue 爬网程序创建表。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><ul><li><p><a href="https://aws.amazon.com/cn/blogs/big-data/build-a-data-lake-foundation-with-aws-glue-and-amazon-s3/" target="_blank" rel="noopener">使用Glue读取csv并转换成Parquet格式随后使用Athena查询</a></p></li><li><p><a href="https://aws.amazon.com/cn/blogs/china/etl-pipeline-for-serverless-architecture-using-glue/" target="_blank" rel="noopener">Glue自定义分类器识别服务器日志</a></p></li><li><p><a href="https://aws.amazon.com/cn/blogs/database/how-to-extract-transform-and-load-data-for-analytic-processing-using-aws-glue-part-2/" target="_blank" rel="noopener">How to extract, transform, and load data for analytic processing using AWS Glue (Part 2)</a></p></li><li><p><a href="https://gorillalogic.com/blog/in-search-of-happiness-a-quick-etl-use-case-with-aws-glue-redshift/" target="_blank" rel="noopener">In Search of Happiness: A Quick ETL Use Case with AWS Glue + Redshift</a></p></li></ul><h2 id="Athena与S3"><a href="#Athena与S3" class="headerlink" title="Athena与S3"></a>Athena与S3</h2><p>Athena 可帮助分析在 Amazon S3 中存储的非结构化、半结构化和结构化数据。包括 CSV、JSON 或列式数据格式，如 Apache Parquet 和 Apache ORC。可以使用 ANSI SQL 通过 Athena 运行临时查询，而无需将数据聚合或加载到 Athena 中。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font size=&quot;3&quot;&gt;&lt;br&gt;整理一下自己了解的S3、Athena和Glue
&lt;/font&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="AWS" scheme="http://Bithub00.com/tags/AWS/"/>
    
  </entry>
  
  <entry>
    <title>L1与L2范数</title>
    <link href="http://Bithub00.com/2019/04/03/%E8%8C%83%E6%95%B0/"/>
    <id>http://Bithub00.com/2019/04/03/范数/</id>
    <published>2019-04-03T04:59:52.310Z</published>
    <updated>2019-08-07T08:00:29.935Z</updated>
    
    <content type="html"><![CDATA[<font size="3">看到的一篇很好的介绍L1与L2范数的文章，mark下来</font><a id="more"></a><p><img src="https://s2.ax1x.com/2019/04/03/Accl6O.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;font size=&quot;3&quot;&gt;
看到的一篇很好的介绍L1与L2范数的文章，mark下来
&lt;/font&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://Bithub00.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>安卓Activity移植</title>
    <link href="http://Bithub00.com/2018/09/07/%E5%AE%89%E5%8D%93Activity%E7%A7%BB%E6%A4%8D/"/>
    <id>http://Bithub00.com/2018/09/07/安卓Activity移植/</id>
    <published>2018-09-07T04:31:55.617Z</published>
    <updated>2019-08-06T04:38:29.791Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章记录一下之前将写的一个Activity加入现有应用时遇到的坑<br><a id="more"></a></p><h2 id="找不到R"><a href="#找不到R" class="headerlink" title="找不到R"></a>找不到R</h2><p>&#8194;这个问题移植完后马上就会遇到，在将layout里的xml文件等都复制过来后，如果问题还存在，直接Android Studio中 Build-Clen Project 一次，问题基本上就解决了</p><h2 id="包名"><a href="#包名" class="headerlink" title="包名"></a>包名</h2><p>&#8194;形如com.package.XXXXX等问题，复制代码文件时IDE会自动帮我们修正，但布局文件中IDE是不会帮我们纠正过来的,例如<center>`"tools:context=".MainActivity""`</center>就要进行修改，或者在标签中出现com.package.XXXX没有修改的情况，只能一个个xml文件去找了</p><h2 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h2><p>&#8194;如果在移植的Activity中继承了Application类创造了自己的，那移植过去后一定要在AndroidManifest.xml文件的\<application>里的android:name中进行修改</application></p><h2 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h2><p>&#8194;最后就是一直过去后要在AndroidManifest.xml文件中添加移植过去的Activity，不然运行时会报错，Logcat中也会给出建议</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章记录一下之前将写的一个Activity加入现有应用时遇到的坑&lt;br&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://Bithub00.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>SIMLR算法论文个人翻译</title>
    <link href="http://Bithub00.com/2018/07/25/SIMLR%E7%AE%97%E6%B3%95/"/>
    <id>http://Bithub00.com/2018/07/25/SIMLR算法/</id>
    <published>2018-07-25T12:00:18.373Z</published>
    <updated>2019-08-07T09:19:27.860Z</updated>
    
    <content type="html"><![CDATA[<font size="5">基于多核函数的单细胞RNA序列分析与可视化算法</font><p>&#8194; </p><font size="3">摘要：我们将要介绍的SIMLR算法，在理论框架和软件应用上已经实现，它从输入的单细胞RNA序列中学习到一种相似度的信息，随后可以用这种信息来实现降维、聚类和可视化等后续处理。在七个公开的数据集上我们对算法进行了检验并于一些常用的算法进行了比较分析。结果证明了SIMLR算法对大规模数据的良好处理以及极大程度上提高了聚类的效果，同时提升了可视化的效果以及对细胞间相似程度的识别。</font><a id="more"></a><font size="3">关键词：多核函数；低秩约束；单细胞RNA序列</font><h2 id="背景介绍及概览"><a href="#背景介绍及概览" class="headerlink" title="背景介绍及概览"></a>背景介绍及概览</h2><p>&#8194; 此前，对单细胞RNA序列的研究揭示了细胞种群间未被洞悉的异构性与功能分化。近期的研究阐释说明了通过对RNA序列的无偏分析，是有可能做到对细胞子群功能特异性的de novo分析的。然而，大部分用来应用的算法都是针对传统的大规模RNA序列数据，而基因的表达结果在一群细胞中被平均化了。这些算法并不能成功地处理如下问题：如噪声数据、离散点以及dropout现象（获取基因表达数据时未能成功识别基因表达结果而标记为0，而实际情况是基因进行了表达）。诸如DropSeq和GemCode的平台已经显著增加了数千个细胞的细胞信息，然而，这类平台产生的多为稀疏数据，其中95%的基因测量结果被标记为0。对于诸如降维、聚类以及数据可视化等无监督学习的方法来说，其中一个关键就是相似度矩阵的学习，而这个矩阵对于不同平台或者生物实验得到的数据并不通用。为了解决上述问题，我们提出了SIMLR算法，一个从输入的单细胞RNA序列数据中学习细胞与细胞之间相似度矩阵的框架。</p><p>&#8194; 相较于传统的算法，SIMLR算法有三个主要的优势：首先，它通过使用多个核函数的方法来学习一个最符合输入数据的结构的相似性矩阵。常规的降维或聚类算法对数据的假设有时并不适用于单细胞RNA序列数据。而多个核函数被证实在描绘数据多角度的信息下有着更好的效果，而且相对于单个核函数具有更好的灵活性。第二，对于高维度下的dropout现象，SIMLR算法通过对学习的相似度矩阵应用秩约束以及使用图扩散的方法来解决。秩约束的应用增强了相似度矩阵的分块对角结构，而图扩散方法提高了对弱相似度的识别。第三，算法习得的相似度矩阵可以被高效的用来后续的数据分析，比如通过SNE算法进行数据在低维空间下的可视化。</p><p>&#8194; 我们通过在四个公开的单细胞数据集上应用SIMLR算法来与传统的算法比较，结果是SIMLR算法习得的相似度矩阵在表现数据相似度上要表现得更好。每个数据集中细胞所属的种类是先验的并且在研究中已经被证实正确。通过输入数据集和细胞的种类数，SIMLR算法就能学习出一个细胞间的相似度矩阵，而不需要输入细胞真实所属类别的标签信息。而且相较于传统的相关系数或欧几里得距离衡量相似度，SIMLR算法的结果要更加接近真实结果。特别的是，Buettner数据集的真实标签是细胞周期的状态，我们在这个数据集上额外应用了SIMLR算法来对基因进行排序。算法输出一个基因网络，来展现不同的基因在细胞各个周期、翻译以及代谢过程中的相关性。</p><p><img src="https://s1.ax1x.com/2018/07/31/PdhleH.png" alt=""></p><p>&#8194; 图表1：SIMLR算法的总览。给定一个基因表达数据的矩阵作为输入，算法构建并学习多个核函数之间的权重，并构建出一个相似度矩阵。给定细胞种类数C作为输入，构建出的相似度矩阵将有一个含C个分块的分块对角矩阵，每个分块中的细胞都更为相似。算法使用得到的相似度矩阵来进行降维、可视化、聚类等后续处理。实心箭头代表了需要被用来构建相似度矩阵的信息，而点线箭头则表明聚类的结果可以与可视化以及基因排序相结合。2D散点图中的每一个点代表一个细胞，而不同的颜色代表细胞所属的不同类别。</p><p>&#8194; 为了分析算法在降维上的效果，我们与8个传统的降维算法进行了比较，包括主成分分析、tSNE以及ZIFA算法。在六种不同的表现算法优劣矩阵中，SIMLE算法在四个公开的数据集上表现出色，并且远远的拉开了与第二名的差距。</p><p>&#8194; 我们还进行了低维数据的可视化实验。结果表明，在各个数据集上SIMLR算法的结果不仅能吻合数据集给出的真实标签，甚至在秩约束有关的参数没有贡献时同样能保持相似度矩阵的分块对角结构。特别地，在Kolodziejczyk这个数据集上，我们还从SIMLR算法的结果上发现，在已知的分类结果上其实还能继续往下细分，这个结果也符合与这个数据集有关的理论研究。</p><p>&#8194; SIMLR算法同样可以用来进行细胞聚类，通过降维后应用k-means算法或者直接对习得的相似度矩阵使用AP近邻算法来实现。后者的表现性要远远超过使用皮尔逊相关系数或欧几里得距离来衡量相似性的方法。而前者的表现性在四个数据集上也比现有的针对单细胞的聚类算法要更好。</p><p>&#8194; 为了检验算法的能力，我们应用了更多更有挑战性的方案。我们分析了一个GemCode平台上提供的周边血液单核球细胞的稀疏数据集，里面包含了2700个细胞且其中95%的基因表达结果被标记为0。通过降维后应用k-means算法，我们识别出八种主要的细胞类别，包括一个只含12个细胞的megakaryocyte种类。除此之外，我们还在不同的已经得到充分研究的数据集上试验了SIMLR算法的表现性。</p><p>&#8194; 为了说明SIMLR算法在大规模数据上的表现性，我们在三个公开的大规模数据集上进行了试验。我们对真实标签与算法输出的预测表情的相关性进行了计算。对于Zeisei数据集，我们应用了一个二级聚类的方法，发现SIMLR算法可以用来进行在对细胞的层次结构的分析。而且，低维可视化的结果也很好的符合了真实的数据标签。即使是大规模数据集中因为噪声和离散点所造成的相似信息被隐藏的情况，SIMLR算法也能学习一个合适的细胞之间的距离。</p><p><img src="https://s1.ax1x.com/2018/07/31/PdhGFI.png" alt=""><br>&#8194; 图表2：在不同数据集上的测试结果。分别给出了SIMLR算法、基于高斯核的欧几里得距离以及皮尔逊相关系数所得到的相似度矩阵。排放的次序基于相似度的高低。矩阵中的细胞都按照真实的种类来进行排列，使得同一种类的细胞排列在一起，坐标轴上的不同颜色代表不同的种类。可以看出，SIMLR算法的相似度矩阵的分块对角结构与真实标签基本符合。&#8194;</p><p>&#8194; 总的来说，SIMLR算法可以基于不同的数据集通用地判断那些细胞更为相似，即判断结果不受特定数据集影响，并应用降维、聚类、数据可视化等分析方法。SIMLR算法在有着清晰分类的数据集上表现出色，而我们预测这个多核学习的框架在分类不明显的数据集上也会同样产生作用。</p><p><img src="https://s1.ax1x.com/2018/07/31/PdhMOe.png" alt=""><br>&#8194; 图表3： 2维可视化结果的比较。坐标轴无实际意义。每个点代表一个细胞，而靠得越近的点代表相似度越高。数据可视化时没有输入真实的标签信息，在算法的输出时才让各个数据点标上真实的颜色以检验算法的效果。</p><h2 id="算法详述："><a href="#算法详述：" class="headerlink" title="算法详述："></a>算法详述：</h2><p>SIMLR算法提供了Matlab和R语言两个版本的实现（<a href="https://github.com/BatzoglouLabSU/SIMLR）" target="_blank" rel="noopener">https://github.com/BatzoglouLabSU/SIMLR）</a></p><p>&#8194; k-means算法的实现我们使用了Matlab和R语言自带的模块。而SNE算法我们修改了两个语言中这一模块的源代码。四个公开的数据集随着源代码一起被提供。而三个大型的数据集可以在相应的平台上得到。输入一个N×M的的基因表达矩阵，N代表细胞个数，M代表基因数。SIMLR算法将输出一个S×S的相似性矩阵。其中Sij表示两个细胞之间的相似度。给定一个细胞种类数C，算法假定输出的相似度矩阵将有一个含C个分块的分块对角矩阵，各个分块中的细胞更为相似。我们对两个细胞之间的距离定义为：</p><p><img src="https://s1.ax1x.com/2018/07/31/PdhuQO.png" alt=""><br>其中wl代表核函数的权重</p><font size="4"> 算法依据如下损失函数来计算细胞与细胞之间的相似性：</font><p><img src="https://s1.ax1x.com/2018/07/31/PdhKyD.png" alt=""><br>&#8194; 其中IN和IC分别为N×N和C×C的单位矩阵，tr(.)代表矩阵的秩，β和γ均为非零值，||S||F为范数表示，L为辅助的用来对S进行低秩约束。因此这个损失函数求解三个参数：相似度矩阵S，核函数权重向量w以及一个结构为N×C的秩约束矩阵L。</p><font size="3">  &#8194; 损失函数的第一项含义为，如果两个细胞间的距离很远，则它们的相似度应该很低。第二项是一个对S的正则化，防止S矩阵过于接近一个单位矩阵。如果细胞可以被划分为C类，则每一类中的细胞更为相似，理想情况下矩阵S的秩为C。因此，损失函数的第三项以及L矩阵的引入增强了S的低秩结构，而矩阵（IN-S）即为拉普拉斯矩阵，在一个相似图中，每个节点代表一个细胞，边衡量节点间的相似性。第四项对核函数的权重进行约束，防止单核函数情况的出现。实践证明，这个正则化项提高了相似矩阵的表现。</font>  <h3 id="核函数的构建"><a href="#核函数的构建" class="headerlink" title="核函数的构建"></a>核函数的构建</h3><p>我们以带有不同超参数的高斯核为基础构建不同的核函数，实践证明相对其它核函数高斯核的表现更好。</p><p><img src="https://s1.ax1x.com/2018/07/31/Pdh1wd.png" alt=""></p><p>式中||ci - cj||表示细胞i和j之间的欧几里得距离。</p><font size="3"> 方差ɛij的定义式如下：</font><p><img src="https://s1.ax1x.com/2018/07/31/Pdh3TA.png" alt=""></p><p>&#8194; 因此，每一个核函数被一对参数(σ，k).我们设定k = 10，12，14,…,30 以及σ = 1.0，1.25，1.5，1.75，2，产生了55个不同的核函数。然而，实践证明，算法对核函数的数量以及参数的选择并不敏感。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ul><li>核函数的权重w被初始化为核函数数量的倒数：</li></ul><p><img src="https://s1.ax1x.com/2018/07/31/PdhTt1.png" alt=""></p><ul><li>相似度矩阵S被初始化为：</li></ul><p><img src="https://s1.ax1x.com/2018/07/31/PdhokR.png" alt=""></p><ul><li>而矩阵L被初始化为拉普拉斯矩阵（IN - S）的前C个特征向量。</li></ul><h3 id="优化算法"><a href="#优化算法" class="headerlink" title="优化算法"></a>优化算法</h3><p>我们对S,L和w进行优化。上文中的优化式非凸，但固定某两个参数得到的目标函数为凸函数。因此我们可以有效的应用凸优化算法来进行求解。</p><ul><li>步骤1：固定L和w对S进行更新。损失函数可以被重写为：</li></ul><p><img src="https://s1.ax1x.com/2018/07/31/Pdhbp6.png" alt=""></p><p>&#8194; 目标函数中第一项求和式以及约束项均为线性，而第二项是一个二次项，它可以在多项式复杂度的时间内计算出来。</p><ul><li>步骤2：固定S和w对L进行更新。损失函数可以被重写为：</li></ul><p><img src="https://s1.ax1x.com/2018/07/31/Pdh579.png" alt=""></p><p>&#8194; 此时对L矩阵的求解就是拉普拉斯矩阵（S-IN）对应的C个最大特征值的特征向量。</p><ul><li>步骤三：固定S和L对w进行更新。同样地，损失函数可以被重写为如下形式：</li></ul><p><img src="https://s1.ax1x.com/2018/07/31/Pdh7fx.png" alt=""></p><p>&#8194; 对于这样一个包含凸函数和线性约束的问题，任何一个凸优化算法都可以进行求解。</p><ul><li>步骤四：基于扩散方法的相似度矩阵优化。我们应用了一种扩散方法来减少噪声和dropout现象对S矩阵的影响。给定矩阵S，我们构建如下形式的过渡矩阵P：</li></ul><p><img src="https://s1.ax1x.com/2018/07/31/Pdhjne.png" alt=""></p><p>&#8194; Ak(i)代表一个集合，里面包含了细胞i的k个近邻细胞的索引。构建出来的过渡矩阵是稀疏的，并且保留了极大部分的相似度结构。算法的更新方法如下所示：</p><p><img src="https://s1.ax1x.com/2018/07/31/Pdhq1K.png" alt=""></p><p>&#8194; H(0)ij = Sij作为输入，而最终迭代出来的结果Hij作为新的相似值Sij。这个额外的扩散方法将会很大程度上避免单细胞RNA序列数据中的噪声值所带来的影响。然而，因为这个算法的高计算复杂度，在面对大规模数据集时它无法发挥有效作用。</p><font size="3">  &#8194; SIMLR算法重复步骤1-4直到算法收敛。随后使用得到的相似度矩阵S进行后续分析：</font><h2 id="后续分析"><a href="#后续分析" class="headerlink" title="后续分析"></a>后续分析</h2><h3 id="降维处理："><a href="#降维处理：" class="headerlink" title="降维处理："></a>降维处理：</h3><p>&#8194; 算法基于SNE算法进行降维，并进行了调整。不同点在于，tSNE算法基于高斯核来计算高维度空间下数据之间的相似度，随后将其映射到低维空间并保留这个相似度信息。我们没有选择直接输入基因表达矩阵而是输入了相似度矩阵S。</p><h3 id="可视化："><a href="#可视化：" class="headerlink" title="可视化："></a>可视化：</h3><p>&#8194; 我们使用降维算法来投影到二维或三维空间进行可视化。如k-means聚类，我们将维度降到B维，得到一个N×B相应的矩阵Z，随后应用k-means算法来对于细胞进行聚类。B的值与输入的C的值相同。C同时也是上文提到的秩约束的参数。</p><h3 id="基于相似度矩阵的基因排序："><a href="#基于相似度矩阵的基因排序：" class="headerlink" title="基于相似度矩阵的基因排序："></a>基于相似度矩阵的基因排序：</h3><p>&#8194; 我们通过计算某个基因在不同细胞中表达的值与习得的相似度的相关程度来对基因进行排序。给定相似度矩阵S和某个基因在所有细胞中的表达结果f，表达式如下：</p><p><img src="https://s1.ax1x.com/2018/07/31/PdhL6O.png" alt=""></p><p>&#8194; 这是一个经典的用来衡量基因和相似度之间相关性的无监督特征排序算法。表达式的值越高，则基因在不同细胞中的表达越重要。然而，表达式对相似度矩阵中的噪声值非常敏感。为了克服这个问题，我们随机选取一定比例的细胞（如细胞总数的80%），随后根据剩余细胞的相似度矩阵来对基因进行排序。</p><h3 id="大规模数据集上的应用："><a href="#大规模数据集上的应用：" class="headerlink" title="大规模数据集上的应用："></a>大规模数据集上的应用：</h3><p>&#8194; 我们在含有数万个细胞的数据集上进行了试验，关键因素在于用KNN相似度来近似于细胞的相似度。第一步，我们采用了目前更为先进的近邻搜索算法<a href="https://github.com/spotify/annoy" target="_blank" rel="noopener">ANNOY</a>，ANNOY算法认为，一个近邻点的近邻也可能是一个近邻点。因此，在构建出KNN图后，算法只更新每个细胞所预先选定的前k个近邻点。因为得到的相似度矩阵是稀疏的，我们使用<a href="http://yixuan.cos.name/spectra/" target="_blank" rel="noopener">Spectra</a>来对L进行求解。当我们按照这种方式而不是进行涉及到矩阵求逆运算的闭式求解，我们只需要在有限次的迭代中就可以得到一个结果。</p><p>&#8194; 在我们得到相似度矩阵后，我们就可以进行细胞可视化和细胞聚类了。聚类时，从t-SNE算法中获得嵌入的低维空间的过程的计算量很大。相反，我们采用了一种谱聚类算法，它基本上等同于我们的SIMLR算法中对矩阵L应用k均值。这种简单的算法对稀疏相似性的聚类非常有效，并可扩展到数以万计的细胞中。对于可视化，由于我们仅将细胞到细胞的相似性映射到二维或三维空间，因此应用t-SNE算法在计算上仍是可行的。我们对tSNE算法中的Barnes–Hut算法进行了调整。</p><h2 id="数据来源"><a href="#数据来源" class="headerlink" title="数据来源"></a>数据来源</h2><p>&#8194; 我们在本文中使用了七个单细胞RNA-seq的数据集。前四个数据集每个包含少于1,000个细胞，而最后三个数据集包含数千到数万个细胞。下面是所有单细胞RNA-seq数据集的详细描述。</p><p>&#8194;（1）11个细胞群，包括神经细胞和血细胞（Pollen数据集）。该数据集旨在测试低覆盖率单细胞RNA-seq在鉴别不同细胞群体方面的效用，因此含有多种细胞类型的混合物：皮肤细胞，多能干细胞，血细胞和神经细胞。该数据集包括在高深度和低深度处测序的样本。我们分析了高深度样本，每个样本的平均测序数为890万。</p><p>&#8194; （2）具有感觉亚型的神经元细胞（Usoskin数据集）。该数据集包含来自小鼠背根神经节的622个细胞，每个细胞平均有114万个读段。作者将细胞分为四种神经元类型：肽能伤害性伤害感受器，非肽能伤害性伤害感受器，含神经丝，含酪氨酸羟化酶。</p><p>&#8194; （3）不同细胞周期阶段的胚胎干细胞（Buettner数据集）。该数据集来自对照研究，该对照研究量化了细胞周期对个体小鼠胚胎干细胞（mESC）中基因表达水平的影响。对于182个细胞中的每一个细胞，获得平均五十万个读数，并且至少20％的读数被定位于mm9小鼠基因组上的已知外显子。使用荧光激活细胞分选将细胞分选为细胞周期的三个阶段，并且使用金标准Hoechst染色对它们进行验证。</p><p>&#8194; （4）不同环境条件下的多能细胞（Kolodziejczyk数据集）。该数据集是从干细胞研究中获得的，研究不同培养条件如何影响mESC的多能状态。该研究从涉及三种不同培养条件的九个不同实验中量化了704个mESC中约10,000个基因的表达水平。每个细胞平均获得900万个读数，超过60％的读数映射到小家鼠基因组上的外显子。</p><p>&#8194; （5）具有39个亚型的小鼠视网膜细胞（Macoskco数据集）。通过基于液滴的高通量技术Drop-seq获得，该数据集包括44,808个单元的UMI（3端）计数（由其定制的计算管道识别）。细胞类型通过PCA和基于密度的聚类进行分类，并且通过差异基因表达进行验证。根据原始处理程序，我们过滤掉少于900个基因的细胞（涉及到11,040个细胞）用于无监督分析。</p><p>&#8194; （6）来自一个健康人类的PBMCs数据集（PBMC68k数据集）。通过GemCode平台生成scRNA-seq文库，这是一种基于液滴的高通量技术，以及具有UMI（3’端）计数的68,560个细胞通过其定制的计算流水线来识别。这种细胞群包括健康人体内的主要免疫细胞类型。</p><p>&#8194; （7）使用独特的分子识别（UMI）分析和3’端计数收集来自小鼠皮质和海马的细胞（Zeisel数据集）。收集来自小鼠脑的3,005个细胞，并且通过分级双聚类鉴定了47个亚型，并通过基因标记进行了验证。</p><p>&#8194;  对于以上涉及到的数据集，我们进行了如下的数据预处理：</p><p><img src="https://s1.ax1x.com/2018/07/31/PdhOXD.png" alt="PdhOXD.png"> </p>]]></content>
    
    <summary type="html">
    
      &lt;font size=&quot;5&quot;&gt;
基于多核函数的单细胞RNA序列分析与可视化算法
&lt;/font&gt;

&lt;p&gt;&amp;#8194; &lt;/p&gt;
&lt;font size=&quot;3&quot;&gt;
摘要：我们将要介绍的SIMLR算法，在理论框架和软件应用上已经实现，它从输入的单细胞RNA序列中学习到一种相似度的信息，随后可以用这种信息来实现降维、聚类和可视化等后续处理。在七个公开的数据集上我们对算法进行了检验并于一些常用的算法进行了比较分析。结果证明了SIMLR算法对大规模数据的良好处理以及极大程度上提高了聚类的效果，同时提升了可视化的效果以及对细胞间相似程度的识别。
&lt;/font&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://Bithub00.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Jupyter Notebook 的快捷键</title>
    <link href="http://Bithub00.com/2018/07/24/jupyter%20notebook%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>http://Bithub00.com/2018/07/24/jupyter notebook快捷键/</id>
    <published>2018-07-24T06:16:20.378Z</published>
    <updated>2018-07-24T06:22:27.766Z</updated>
    
    <content type="html"><![CDATA[<p>Jupyter Notebook 有两种键盘输入模式。编辑模式，允许你往单元中键入代码或文本；这时的单元框线是绿色的。命令模式，键盘输入运行程序命令；这时的单元框线是灰色。<br><a id="more"></a></p><h3 id="命令模式-按键-Esc-开启"><a href="#命令模式-按键-Esc-开启" class="headerlink" title="命令模式 (按键 Esc 开启)"></a>命令模式 (按键 Esc 开启)</h3><ul><li><strong>Enter</strong> : 转入编辑模式</li><li><strong>Shift-Enter</strong> : 运行本单元，选中下个单元</li><li><strong>Ctrl-Enter</strong> : 运行本单元</li><li><strong>Alt-Enter</strong> : 运行本单元，在其下插入新单元</li><li><strong>Y</strong> : 单元转入代码状态</li><li><strong>M</strong> :单元转入markdown状态</li><li><strong>R</strong> : 单元转入raw状态</li><li><strong>1</strong> : 设定 1 级标题</li><li><strong>2</strong> : 设定 2 级标题</li><li><strong>3</strong> : 设定 3 级标题</li><li><strong>4</strong> : 设定 4 级标题</li><li><strong>5</strong> : 设定 5 级标题</li><li><strong>6</strong> : 设定 6 级标题</li><li><strong>Up</strong> : 选中上方单元</li><li><strong>K</strong> : 选中上方单元</li><li><strong>Down</strong> : 选中下方单元</li><li><strong>J</strong> : 选中下方单元</li><li><strong>Shift-K</strong> : 扩大选中上方单元</li><li><strong>Shift-J</strong> : 扩大选中下方单元</li><li><strong>A</strong> : 在上方插入新单元</li><li><strong>B</strong> : 在下方插入新单元</li><li><strong>X</strong> : 剪切选中的单元</li><li><strong>C</strong> : 复制选中的单元</li><li><strong>Shift-V</strong> : 粘贴到上方单元</li><li><strong>V</strong> : 粘贴到下方单元</li><li><strong>Z</strong> : 恢复删除的最后一个单元</li><li><strong>D,D</strong> : 删除选中的单元</li><li><strong>Shift-M</strong> : 合并选中的单元</li><li><strong>Ctrl-S</strong> : 文件存盘</li><li><strong>S</strong> : 文件存盘</li><li><strong>L</strong> : 转换行号</li><li><strong>O</strong> : 转换输出</li><li><strong>Shift-O</strong> : 转换输出滚动</li><li><strong>Esc</strong> : 关闭页面</li><li><strong>Q</strong> : 关闭页面</li><li><strong>H</strong> : 显示快捷键帮助</li><li><strong>I,I</strong> : 中断Notebook内核</li><li><strong>0,0</strong> : 重启Notebook内核</li><li><strong>Shift</strong> : 忽略</li><li><strong>Shift-Space</strong> : 向上滚动</li><li><strong>Space</strong> : 向下滚动</li></ul><h3 id="编辑模式-Enter-键启动"><a href="#编辑模式-Enter-键启动" class="headerlink" title="编辑模式 ( Enter 键启动)"></a>编辑模式 ( Enter 键启动)</h3><ul><li><strong>Tab</strong> : 代码补全或缩进</li><li><strong>Shift-Tab</strong> : 提示</li><li><strong>Ctrl-]</strong> : 缩进</li><li><strong>Ctrl-[</strong> : 解除缩进</li><li><strong>Ctrl-A</strong> : 全选</li><li><strong>Ctrl-Z</strong> : 复原</li><li><strong>Ctrl-Shift-Z</strong> : 再做</li><li><strong>Ctrl-Y</strong> : 再做</li><li><strong>Ctrl-Home</strong> : 跳到单元开头</li><li><strong>Ctrl-Up</strong> : 跳到单元开头</li><li><strong>Ctrl-End</strong> : 跳到单元末尾</li><li><strong>Ctrl-Down</strong> : 跳到单元末尾</li><li><strong>Ctrl-Left</strong> : 跳到左边一个字首</li><li><strong>Ctrl-Right</strong> : 跳到右边一个字首</li><li><strong>Ctrl-Backspace</strong> : 删除前面一个字</li><li><strong>Ctrl-Delete</strong> : 删除后面一个字</li><li><strong>Esc</strong> : 进入命令模式</li><li><strong>Ctrl-M</strong> : 进入命令模式</li><li><strong>Shift-Enter</strong> : 运行本单元，选中下一单元</li><li><strong>Ctrl-Enter</strong> : 运行本单元</li><li><strong>Alt-Enter</strong> : 运行本单元，在下面插入一单元</li><li><strong>Ctrl-Shift—</strong> : 分割单元</li><li><strong>Ctrl-Shift-Subtract</strong> : 分割单元</li><li><strong>Ctrl-S</strong> : 文件存盘</li><li><strong>Shift</strong> : 忽略</li><li><strong>Up</strong> : 光标上移或转入上一单元</li><li><strong>Down</strong> :光标下移或转入下一单元</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Jupyter Notebook 有两种键盘输入模式。编辑模式，允许你往单元中键入代码或文本；这时的单元框线是绿色的。命令模式，键盘输入运行程序命令；这时的单元框线是灰色。&lt;br&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://Bithub00.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>VPN</title>
    <link href="http://Bithub00.com/2018/04/06/vpn/"/>
    <id>http://Bithub00.com/2018/04/06/vpn/</id>
    <published>2018-04-06T11:58:10.712Z</published>
    <updated>2019-08-07T07:59:44.374Z</updated>
    
    <content type="html"><![CDATA[<font size="5">edu.cn的学校邮箱+5美元 = 11个月的境外服务器</font><h3 id="领取github的vps优惠码"><a href="#领取github的vps优惠码" class="headerlink" title="领取github的vps优惠码"></a>领取github的vps优惠码</h3><a id="more"></a><ul><li>教程<br><a href="https://www.ichenfei.com/get-github-students-gift.html" target="_blank" rel="noopener">https://www.ichenfei.com/get-github-students-gift.html</a></li><li>领取优惠码页面<br><a href="https://education.github.com/pack/offers#digitalocean" target="_blank" rel="noopener">https://education.github.com/pack/offers#digitalocean</a></li><li><p>vps开通页面(需要翻墙，学校使用ipv6地址可以直接翻出去)<br><a href="https://www.digitalocean.com/" target="_blank" rel="noopener">https://www.digitalocean.com/</a><br>不要使用一次性邮箱注册账号，因为以后每次登陆都要邮箱验证</p></li><li><p>登陆页面<br><a href="https://cloud.digitalocean.com/login" target="_blank" rel="noopener">https://cloud.digitalocean.com/login</a> (建议翻墙访问)</p></li><li><p>注册paypal账号来支付<br><a href="https://www.paypal.com/c2/home" target="_blank" rel="noopener">https://www.paypal.com/c2/home</a></p><!--more--><p>paypal绑定了银行卡和手机，建议用不常用的银行卡，然后充35块钱进去<br>支付成功后，激活digitalocean账号，填入github的优惠卷，获得50美元</p></li></ul><h3 id="创建自己的服务器"><a href="#创建自己的服务器" class="headerlink" title="创建自己的服务器"></a>创建自己的服务器</h3><p>建议选SFO一区的服务器，不容易被墙，配置的话5美元那种就差不多了，服务器型号建议ubuntu</p><h3 id="连接服务器"><a href="#连接服务器" class="headerlink" title="连接服务器"></a>连接服务器</h3><p>通过console连上服务器后，使用秋水逸冰大大的命令一键安装:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget --no-check-certificate -O shadowsocks-all.sh https:<span class="comment">//raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-all.sh</span></span><br><span class="line"></span><br><span class="line">chmod +x shadowsocks-all.sh &amp;&amp; ./shadowsocks-all.sh <span class="number">2</span>&gt;&amp;<span class="number">1</span> | tee shadowsocks-all.<span class="built_in">log</span></span><br></pre></td></tr></table></figure></p><font size="4">探索新世界吧:)</font>]]></content>
    
    <summary type="html">
    
      &lt;font size=&quot;5&quot;&gt;edu.cn的学校邮箱+5美元 = 11个月的境外服务器&lt;/font&gt;

&lt;h3 id=&quot;领取github的vps优惠码&quot;&gt;&lt;a href=&quot;#领取github的vps优惠码&quot; class=&quot;headerlink&quot; title=&quot;领取github的vps优惠码&quot;&gt;&lt;/a&gt;领取github的vps优惠码&lt;/h3&gt;
    
    </summary>
    
    
      <category term="vpn" scheme="http://Bithub00.com/tags/vpn/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://Bithub00.com/2018/04/05/hello-world/"/>
    <id>http://Bithub00.com/2018/04/05/hello-world/</id>
    <published>2018-04-05T14:57:07.298Z</published>
    <updated>2019-08-07T08:05:31.440Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;Quick Start&quot;&gt;&lt;/a&gt;Quick Start&lt;/h2&gt;&lt;h3 id=&quot;Create-a-new-post&quot;&gt;&lt;a href=&quot;#Create-a-new-post&quot; class=&quot;headerlink&quot; title=&quot;Create a new post&quot;&gt;&lt;/a&gt;Create a new post&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo new &lt;span class=&quot;string&quot;&gt;&quot;My New Post&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
