<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>原力小站</title>
  
  <subtitle>扎导的原版正联出了吗？</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://Bithub00.com/"/>
  <updated>2019-08-27T11:59:51.531Z</updated>
  <id>http://Bithub00.com/</id>
  
  <author>
    <name>Mr.shuan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>阅读点滴</title>
    <link href="http://Bithub00.com/2019/08/27/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://Bithub00.com/2019/08/27/读书笔记/</id>
    <published>2019-08-27T11:41:18.469Z</published>
    <updated>2019-08-27T11:59:51.531Z</updated>
    
    <content type="html"><![CDATA[<p>这里摘录自己看过的书里受启发的一些句子以及自己的所想<br><a id="more"></a></p><h3 id="《扫起落叶好过冬》—-林达"><a href="#《扫起落叶好过冬》—-林达" class="headerlink" title="《扫起落叶好过冬》— 林达"></a>《扫起落叶好过冬》— 林达</h3><ul><li><p>林奇堡：私刑的发源地<br>对于民众激情的过度赞美是危险的。“人民”和“暴民”之间，并没有一条不可逾越的鸿沟。在失控的人群中，“人民法庭”随意蹂躏和消灭一个生命的情况，就很容易发生。聚集的人群在心理上一旦放任自己，就容易在处置罪犯的借口下，忽略个体生命，放大自己的权力。程序自然会迅速简化，刑罚必然就日趋严峻。而契约规定的严格的司法程序正是对草菅人命的有效约束。</p></li><li><p>阿米绪人的故事<br>一个社会要发动成千上百的人并不难，要达到多数人的一致也不难，难的是公正善待只有百分之几的少数。有时候，少数显得如此人微言轻，他们的生死存亡是如此地微不足道，可是，能否保证这微乎其微地少数得到公平地善待，恰恰是检验文明和人道的试金石，也是决定能否长治久安的一个关键。</p></li><li><p>一个历史学家和他的小镇<br>我们在自己短暂的一生里，所看到的社会、所看到的人和人之间的关系，和历史长河里大时段大范围里呈现的图景是有所不同的，甚至会有很大的差别。短暂一生里，更多的机会是看到了人性之恶，是令人失望的现实。即使是在我们的上半辈子，我们也看到不知有多少人是怀着对人类、对国家、对社会的彻底绝望离开这个世界的。这样的事情，自古以来不知发生了多少。只有在读历史的时候，你能在纸页间经历几百年几千年，你才能看到进步、改善，你才会庆幸自己生活在此时此刻。【我们为什么要读历史】</p></li><li><p>各有一番风景<br>美国宪法之父詹姆斯·麦迪逊认为，政治之所以经常败坏人性，和人们在政治中拉帮结派有关。他认为，单独的个人都有一定得道德要求。独立的个人，须对自己的行为主张负责，更容易有道德心。但是，当一些人结成宗派，就会人为制造虚幻正义，把个人的自私，在虚幻正义下掩盖起来，互相提供行为正当性的保证。所以，小宗派的道德水准，通常低于个人道德。单个好人，会在拉帮结派中放任自己的私心，甚至做出坏事来。</p></li><li><p>科尔曼报告<br>它向国会证明，教育机会的平等，不仅要从教育的投入来考察，即考察学生能够获得的公共教育资源，而且更重要的是，要从教育的结果来考察，因为正是对受教育结果的期望，影响了学生的自我评估，决定了学生的学习状态，也造成了种族、肤色、宗教等因素下，弱势人群教育机会的实质不平等。</p></li><li><p>两千年前那个叫西塞罗的老头儿<br>两千年前的时候，罗马人已经有了人类的初始民主，民主决定的法律，总不算错了吧？西塞罗想想觉得还是不对，假如大众通过一项法律说，现在可以抢劫了，难道就真的能出去抢东西了吗？西塞罗琢磨着，人应该有一种“本性”的东西，它不会“屈从愚氓者的意见和命令”。于是他就找到如伊甸园里那种人的最初状态去了。<br>一旦进了伊甸园，我发现西塞罗还是很有道理。仔细打量的话，人和人之间，真的就有非常近似的那一部分。只要这么一想就明白了：所有的人，都有一些绝对不愿意发生在自己身上的事情。比如说，只要是个正常人，就没人愿意自己被杀被抢的，没人愿意别人骑在自己头上作威作福的，这才是人“自然本源”的状态。人要维护自己这样的生存状态，就是维护人的“自然权利”，这权利与生俱来。就刚才那简单的几个“不愿意”，已经隐含了生命的权利、平等的权利、人身自由的权利等等。维护自然权利的法，就是自然法。<br>所以另一个比西塞罗还要早的罗马老头儿狄摩西尼说，“每一种法律都是另一种发现”。法律不是胡编乱造、随心所欲的，正义的法律是对自然法的发现。<br>【柏拉图的理型论】</p></li><li><p>陪审团已经作出了判决<br>法制制度最关键的一步，就是这个文化本身必须建立起绝对尊重司法的传统。因为论“硬件”来说，司法分支是最弱的一环，它在相当程度上是必须依靠社会共识来维持的。宪政国家的产生，就其历史发展来说，是一个社会依据其长期的经验，首先得出对司法之崇高地位的认可。缺少这种文化上的认可，司法是很容易被破坏的。<br>一旦陪审团宣布被告无罪，任何人，即使是总统和最高法院大法官，都没有权力改变。假如不是这样，那就将是一个打不开的死结，就会引出打着伸张正义旗号的民众私刑，就会走向暴力和血腥。假如不是这样，司法就失去权威，整个法制制度都将崩溃。新奥尔良私刑事件中的意大利裔受难者们，用他们的鲜血，用他们被民众的子弹打得残碎的躯体，为后代美国人重申了非常简单却至为重要的道理，这就是今日美国人在法庭大门口经常听到的话：“陪审团已经作出了判决，我们的制度要求我们，必须尊重陪审团。</p></li><li><p>非法之法不是法<br>实际上，美国的领袖们对立法议会的警惕非常容易理解。读读权利法案那短短十条就明白，它要保障的，是民众个人的权利，是一个一个具体的、分散的、个人的权利，听起来是一回事，只是局部和整体的关系，在实际生活中却根本就是两回事。因为所谓人民的权利，在组成政府的时候，就已经委托给了政府，变成了政府之权力。建国领袖们所担心的，是作为这些个人之集合体的人民，通过他们选出的代表，在具体事务上，侵犯一部分民众的个人权利。<br>多数的暴政和绝对个人专权的暴政，可以在顷刻间转换。美国的建国领袖和同时代的法国革命者不同的是，在他们看来，“多数”并不天然地蕴含着“正确”，多数民众对少数人地镇压，并没有想象中地合理性。所以，对当年的宪法起草者来说，保障民众的个人权利，即使是保障少数人甚至一个人的权利，和防止暴政，特别是多数的暴政，就是同一回事。</p></li><li><p>星期日早晨的谋杀案<br>哪怕再合理的推论，也不足以定罪。定罪必须有超越“合理怀疑”的确凿无疑的证据。所以，被告的辩护律师们常常说的一句话是：”合理怀疑“是我们的救星。在一般人看来，假如被告被发现有强烈的作案动机，应该对被告是不利的，但是在律师看来，远非如此。因为作案动机的存在，通常会引出人们逻辑合理的推论。就可能在这种强烈的逻辑力量下忽略证据，甚至自然而然地就以推理取代证据。这个时候，距离辩护取胜、被告被开释，也就不远了。<br>在这里经常出现的、对种族问题的此类不确切描述，起因于人们尤其是知识阶层，有很强烈的、要表达自己对弱者深切同情，以及要挺身为底层代言的倾向。这是知识阶层由来已久、经久不息的一个情结。这也恰恰旁证了知识阶层和底层事实上的本质差异。这种差异给知识阶层带来越多的不安，他们产生这种表达的意向就越趋强烈。无疑，贫穷与恶劣的生活状态导致罪恶。可是，对这张联系的探究，应该引出的是社会学意义上的如何消除贫困、消灭罪恶根源的研究和行动，而不是对已经结出的罪恶之果表达泛滥的同情，不论这个恶果是个别的罪犯或是群体的暴民。道理很简单：任何罪行都是有受害者的。而知识阶层假如放弃面对犯罪行为的道德立场，甚至提供过分的借口和“理解”，不仅无助于弱势群体自身的演进，甚至可能将他们带入更为危险的困惑和歧途。</p></li><li><p>汉娜的手提箱<br>人类历史有大量的负面经验，即使是在和平时期，每个国家也都有大量负面的现实。人们需要历史的传承，汲取历史的教训，需要面对现实。而与此同时，作为儿童和青少年教育，又要警惕大规模的心理伤害。悲和愤等感情，是正义感的基础，可是一旦过度，很容易走向极端，产生对理性的摒弃。历史教育的目的，是带来一个健康的社会，让新的一代有幸福的生活、健康的心态。他们应该是幽默、睿智、快乐、自尊、富有想象力的一代，而不是一代悲壮的愤怒青年。</p></li><li><p>哪怕在奥斯维辛，绘画依然是美丽的<br>历史学家在摸索的，多是粗大的社会走向之脉络；文学艺术在细细解剖的，却是人们在不由自主中刻意藏匿的内心。在一定程度上，后者是理解前者必不可少的依托；前者又是后者无可离弃的基本背景。</p></li><li><p>《野火集》的启示<br>从中华文化圈里出来，很多人能够做到文字优美、内容正确、逻辑严密，可是，也许是我们习惯了这一文化中“士”的特殊位置，即使理解平等的意义，对自己的定位定调往往还是会“开低走高”。做社会批判时，会忘记自己也是社会的一员。批判的烈度越大，自我的位置就不断上升，不能持之以恒地维护和读者对话的平等。因为在我们的文化中，历来缺少平等地概念，我们自己地“低调”往往只是理智的产物，而不是本能的反应。</p></li><li><p>听一次演讲后的随想<br>他们大多是没有名气的，甚至是被误解的。然而，假如没有他们在一片需要改良的土地上默默耕耘，而只有燃野火者，那么当春天来临，也未见得就能够快快长出健康丰润的树苗来。</p></li></ul><h3 id="《刀锋》—-毛姆"><a href="#《刀锋》—-毛姆" class="headerlink" title="《刀锋》— 毛姆"></a>《刀锋》— 毛姆</h3><ul><li><p>你不觉得或许他正在追求一个深藏在一片未知的云朵中的理想——就像一位天文学家寻找某个仅仅通过数学计算才能知道其存在的星球吗？  </p></li><li><p>我们谁也不能两次涉足于同一条河流，然而，河水流去，随即流来的河水依旧沁人心脾。</p></li></ul><h3 id="《娱乐至死》—-尼尔·波兹曼"><a href="#《娱乐至死》—-尼尔·波兹曼" class="headerlink" title="《娱乐至死》— 尼尔·波兹曼"></a>《娱乐至死》— 尼尔·波兹曼</h3><ul><li><p>我时常想起萧伯纳著名的诗句，理智的人适应环境，而世上所有的进步都依赖不理智的人。麦克卢汉是不理智的，兰斯是不理智的，尼尔也是不理智的。因为这样，所有美好的事才发生了。  </p></li><li><p>根据柏拉图的观点，我们应该把焦点放在人类会话的形式上，而且假定我们会话的形式对于要表达的思想有重大的影响，而且容易表达出来的思想自然会成为文化的组成部分。 </p></li><li><p>犹太人的上帝存在于文字中，或者通过文字而存在，这需要人们进行最精妙的抽象思考。运用图像是亵渎神袛的表现，这样就防止了新的上帝进入。</p></li><li><p>随着印刷术影响的减退，政治、宗教、教育和任何其他构成公共事务的领域都要改变其内容，并且用最适用于电视的表达方式去重新定义。</p></li><li><p>如果我们能够意识到，我们创造的每一种工具都蕴含着超越其自身的意义，那么理解这些隐喻就会容易多了。例如，有人指出，12世纪眼镜的发明不仅使矫正视力成为可能，而且还暗示了人类可以不必把天赋或者缺陷视为最终的命运。 </p></li><li><p>马克思《德意志意识形态》：如果印刷机存在，这世上是否还可能有《伊利亚特》？他反问道：”有了印刷机，那些吟唱、传说和思考难道还能继续吗？这些史诗存在的必备条件难道不会消失吗？“</p></li><li><p>道格拉斯：“在讨论这些问题的时候，沉默比掌声更得体，我希望你们能够用自己的评判力、理解力和良知来听我的演讲，而不是用你们的激情或热情。”……，对于读者更是如此，因为作者并不是一直值得信任的。他们撒谎他们陷入迷茫，他们过于笼统，他们滥用逻辑甚至常识。读者对此必须有备而来，用知识武装好自己。</p></li><li><p>这并不是说，印刷术时代发表的文字就一定都是真实的。文字不能保证内容的真实性，而是形成一个语境，让人们可以问“这是真的还是假的”。</p></li><li><p>“阐释年代”：所有成熟话语所拥有的特征，都被偏爱阐释的印刷术发扬光大：富有逻辑的复杂思维，高度的理性和秩序，对于自相矛盾的憎恶，超常的冷静和客观以及等待受众反应的耐心。</p></li><li><p>《瓦尔登湖》：我们匆匆地建起了从缅因州通往德克萨斯州的磁性电报，但是它们可能并没有什么重要的东西需要交流……我们满腔热情地在大西洋下开通隧道，把新旧世界拉近几个星期，但是到达美国人耳朵里的第一条新闻可能却是阿德雷德公主得了百日咳。</p></li><li><p>从此，来路不明、读者对象不定的新闻开始横扫整个国家。战争、犯罪、交通事故、火灾和水灾——大多是阿德莱德公主得百日咳新闻的社会版本和政治版本——开始成为所谓“今日新闻”的主要内容。……电报使脱离语境的信息合法化，也就是说，信息的价值不再取决于其在社会和政治对策和行动中所起的运用，而是取决于它是否新奇有趣。电报把信息变成了一种商品，一种可以置用处或意义于不顾而进行买卖的东西。</p></li><li><p>行为最终产生的结果并不能成为行为最初的目的；人本性就是自私的，只有判断他行为中私己成分的多与少。</p></li><li><p>马歇尔·麦克卢汉所说的”后视镜“思维：认为一种新媒介只是旧媒介的延伸和扩展，比如汽车只是速度更快的马，电灯是功率更大的蜡烛。他们犯的错误就是完全误解了电视如何重新定义公众话语的意义。</p></li><li><p>宗教改革运动的发起者马丁·路德：如果每个家庭的餐桌上都有上帝的文字，基督徒就不需要教皇来为他们释义了。</p></li><li><p>萧伯纳第一次看见百老汇和四十二街上夜间闪烁的霓虹灯时发表的评论：如果你不识字，这些灯光无疑是美丽的。</p></li><li><p>思考不是表演艺术，而电视需要的是表演艺术…….人们看的以及想要看的是有动感的画面—-成千上万的图片，稍纵即逝却斑斓夺目。正是电视本身的这种性质决定了他必须舍弃思想，来迎合人们都视觉快感的需求，适应娱乐业的发展。</p></li><li><p>和他们一样，你要把注意力放在如何最大限度地实现节目的娱乐价值上。例如，你要为节目选择一个音乐主题。所有的电视新闻节目的开始、结束或者中间都要插入一段音乐。我发现很少有美国人会觉得这样的做法奇怪，这足以证明严肃的公众话语和娱乐之间存在的分界线已经荡然无存…….制造一种情绪，为娱乐提供一个主题，提醒观众使用一个合适的情绪。</p></li><li><p>假信息并不意味着错误的信息，而是意味着使人产生误解的信息——没有依据、毫无关联、支离破碎或流于表面的信息——这些信息让人产生错觉，以为自己知道了很多事实，其实却离事实的真相越来越远。当新闻被包装成一种娱乐形式时，它提供给观众的是娱乐而不是信息。</p></li><li><p>电视信息的娱乐化：节目中加入音乐引导观众情绪  | 新闻通常不超过1分钟，几乎不可能报导一个完整的严肃性新闻  |  紧跟着播放的一系列广告会在瞬间消解新闻的重要性 | 电视屏幕上的图像源源不断出现，不留有时间供观众思考 | 播音员播报任何新闻时保持一种固定不变的、得体的热情，不为播报的新闻内容所影响 | 播音员的容貌须得体，以及讲述者的可信度决定了事件的真实性。</p></li><li><p>不论是释迦牟尼、摩西、耶稣还是穆罕默德、路德，从来没有那个伟大的宗教领袖会给人们他们想要的东西，他们给的是人们应该具备的东西。但电视传教士的不成文规则是：“只有给观众他们想要的东西，你才可以得到市场占有率。”</p></li><li><p>真正的危险不在于宗教已经成为电视节目的内容，而在于电视节目可能会成为宗教的内容。</p></li><li><p>那些经营电视的人从来没有限制我们获得信息，而是不断扩大我们获得信息的途径。也就是说，通过制造大量的娱乐性的、无目的性、无意义的信息，来使真正应该被引起注意的新闻被淹没其中。不采用限制的手段却达到了使特定的信息在操纵下无法流通。</p></li><li><p>杜威《经验与教育》：也许人们对于教育最大的错误认识是，一个人学会的只有他当时正在学习的东西。其实，伴随学习的过程形成持久的态度········也许比拼写课或地理历史课更为重要·······因为这些态度才是在未来发挥重要作用的东西。</p></li><li><p>有两种方法可以让文化精神枯萎，一种是奥威尔式的——文化成为一个监狱，另一种是赫胥黎式的——文化成为一种滑稽戏。</p></li><li><p>奥威尔预言的世界比赫胥黎预言的世界更容易辨认，也更有理由去反对。我们的生活经历已经能够让我们认识监狱，并且知道在监狱大门即将关上的时候要奋力反抗。在弥尔顿、培根、伏尔泰、歌德和杰弗逊这些前辈的精神的激励下，我们一定会拿起武器保卫和平。但是，如果我们没有听到痛苦的哭声呢？谁会拿起武器去反对娱乐？</p></li><li><p>那些提出这些问题的人是得出和我一样的答案还是和马歇尔·麦克卢汉一样的答案并不重要，能够提出答案就行了，提出了问题就是破除了禁忌。</p></li></ul><h3 id="《如彗星划过夜空》—-林达"><a href="#《如彗星划过夜空》—-林达" class="headerlink" title="《如彗星划过夜空》— 林达"></a>《如彗星划过夜空》— 林达</h3><ul><li><p>这是一件非常有意思的事情，人类文明可能在一部分人中间先创造出来，而它被称为是“文明”的原因之一，就是它有能力超越自身利益的局限，有了抽象的人道、人权的思维，而且，还在设计“制度”，保障这样的权益。</p></li><li><p>华盛顿将军：“先生们，请等我戴上眼镜。这么些年，我的头发白了，眼神也不济了。”在华盛顿将军心中，“枪杆子”只是带来了追求自由的一个可能。唯有民众的授权，才是政府权力的合法来源。</p></li><li><p>欠债的农夫一多，就群起要求州议会通过立法，允许他们缓偿债务，要求州里加印纸币，还要求立法强立债权人接受纸币作为还款…….欠债的农夫们走投无路，开始造反，最震动的一次冲突是美国历史上有名的谢思暴动。</p></li><li><p>熟悉英国议会制度的代表们，在费城会议中也设立了全体委员会，作用却不一样。它只是一个矛盾的缓冲设置。这时的表决结果，只相当于委员会推荐方案，是对可行方案的试探。</p></li><li><p>今天人们在讨论的民主，往往都是指政治制度。为什么要去牵扯出“民主是一种思维方式”或者非政治领域的“生活方式”呢？我想，政治制度，其实时需要一个相应的社会文明程度去配合的。在民主制度自然生成的国家，是文明的土壤长出了这颗制度之树，而不是相反。</p></li><li><p>费城制宪会议的另一个规则，是一条条地分别表决提案，任何一条通过之后，都可以再返回来提出异议，要求重新表决。</p></li><li><p>民主意识的一个重要来源是人性的觉醒，从而自然地引发出对底层悲惨状况的同情和不平，进而为他们争取权益。正由于这种同情大多发自有比较优越的社会地位、文明程度较高的阶层，或者说发自知识阶层，因此他们的民主意识从起源来说，都是带着原罪负担的。他们非常容易进入的一个误区，就是会不由自主地要美化底层，以平衡自己的原罪意识。他们会在表达对底层苦难同情的时候，在赞美底层的时候，表现得煽情和夸张，以支撑自己的道德感。他们中的一部分，会要求竭力降低自己的文明水准甚至在行为上表现出反文明和粗俗…….这种倾向符合道德出发点的原始冲动。从法国大革命对平民杀贵族的支持，到一代代的民粹倾向，直至现代美国走到极端的“政治正确”，都是源于同样的出发点。在原罪负担之下，承担原罪感的人群往往是不自信的，他们需要他人对自己做出道德上的肯定。结果就是以过激的平民认同和平民倾向，来达到心理和道德需求上的平衡。</p></li><li><p>所以，我以为知识阶层的所谓道德勇气，一部分应该是表现在对强权的批判上，但更为困难更难做到的，是表现在他不迎合、不取悦于民众上。前者是很容易理解也相对更容易做到的。可是，只有非常少的人，能够有智慧有勇气做到，对强权和民众，都保持应有的独立和批判。这和他是否同情弱者，是否保护弱势人群，其实是两回事。</p></li><li><p>这是一个自然形成的利益诉求。个人在人群中非常弱下，可能被强者吃掉。他因此需要一个社会保护层，有法律抵挡强人，有地方可以申诉，有政府力量的保护，如同在身上加一个保护性的外壳。因此，人的联合、政府组织自然形成。</p></li><li><p>麦迪逊认为：结派会导致人的道德水平下降。个人作为个人行动的时候，都会对自己有一定的道德要求，有人之常情，有恻隐之心，会自觉地压抑人性中自私和恶的一面。可是一群人结成一派行动的时候，就会互相提供行为的正当性，提供派别内部的互相暗示，自我道德要求就会下降，甚至做出在一个人的时候不会做的坏事。</p></li><li><p>只有获得充分信息的持批判态度的大众意见，能够保护民主政府的价值体系。所以，警觉的、无所不晓的、自由的新闻界本身，对实现宪法第一修正案的目的是最为重要的。他说：“没有一个自由的、获得了充分信息的新闻界，就不可能有脱离蒙昧的人民。”</p></li><li><p>在这里，人们仍然有一种信念，他们相信，他们可能要走一段弯路，可能有一段倒退，可是任何威胁只能阻碍人们追求自由的道路，却不可能堵死它。也许今夜没有星辰，可是，他们相信，在云霭之上，仍然有群星在太空闪亮。</p></li></ul><h3 id="《美丽新世界》—-赫胥黎"><a href="#《美丽新世界》—-赫胥黎" class="headerlink" title="《美丽新世界》— 赫胥黎"></a>《美丽新世界》— 赫胥黎</h3><ul><li><p>直到最后，孩童的心灵就是这些暗示，而这些暗示的总和也就是孩童的心灵。不仅仅是孩童的心灵而已。成年人的心灵亦复如此······终其一生而不渝。那用来判断、希冀和下决心的心灵——都由这些暗示所组成。而所有这些暗示都是我们的暗示！</p></li><li><p>长久的追悔，是最可厌的一种情绪，这是所有道德家都同意的。如果你犯了错，就忏悔、努力改正，争取下回做好就是了。绝对不要沉溺在自己的错失里。在污泥中打滚可不是最好的净身方法。</p></li></ul><h3 id="《乌合之众》—-古斯塔夫·勒庞"><a href="#《乌合之众》—-古斯塔夫·勒庞" class="headerlink" title="《乌合之众》— 古斯塔夫·勒庞"></a>《乌合之众》— 古斯塔夫·勒庞</h3><ul><li><p>群体不善推理，却急于采取行动。他们目前的组织赋予了他们巨大的力量。我们目睹其诞生的那些教条，很快也会具有旧式教条的威力，也就是说，不容讨论的专横武断的力量。群众的神权就要取代国王的神权了。  </p></li><li><p>只有环境的单一性，才能造成明显的性格单一性。我曾在其它著作中指出，一切精神结构都包含着各种性格的可能性，环境的突变就会使这种可能性表现出来。这解释了法国国民公会中最野蛮的成员为何原来都是些谦和的公民。 </p></li><li><p>他很难约束自己不产生这样的念头：群体是个无名氏，因此也不必承担责任。这样一来，总是约束着个人的责任感便彻底消失了。  </p></li><li><p>群体在智力上总是低于孤立的个人，但是从感情及其激起的行动这个角度看，群体可以比个人表现得更好或更差，这全看环境如何。一切取决于群体所接受的暗示具有什么性质……刺激群体的因素多种多样，群体总是屈从于这些刺激，因此群体也极为多变。群体很容易做出刽子手的举动，同样也很容易慷慨赴义。</p></li><li><p>孤立的个人很清楚，在孤身一人时，他不能焚烧宫殿或洗劫商店，即使受到这样做的诱惑，他也很容易抵制这种诱惑。但是在成为群体的一员时，他就会意识到人数赋予他的力量，这足以让他生出杀人劫掠的念头，并且会立刻屈从于这种诱惑。</p></li><li><p>群体中的某个人对真相的第一次歪曲，是传染性暗示过程的起点……被派往寻找失散巡洋舰的护航舰“贝勒·波拉号”上，执勤兵突然发出了有一艘遇难船只的信号。而下船去营救落难士兵的官员们发现，那只不过是几根长满树叶的树枝。在这个实例中，可以清楚地看到我们已经解释过的集体幻觉的作用机制。一方面，我们看到一个在期待中观望的群体；另一方面，是执勤者发出海上有遇难船只的信号这样一个暗示。</p></li><li><p>群体推理的特点，是把彼此不同、只在表面上相似的事物搅在一起，而且立刻把具体的事物普遍化。知道如何操纵群体的人，给他们提供的也正是这种论证。包含一系列环节的逻辑论证，对群体来说完全是不可理解的。对于演讲家来说，20本滔滔不绝的长篇论证，尽管它们是认真思考的产物，还不如几句对群众有号召力的口号。</p></li><li><p>拿破仑对国会说：“我通过改宗天主教，终止了旺代战争；通过变成一个穆斯林教徒，在埃及站住了脚；通过成为一名信奉教皇至上的人，赢得了意大利神父的支持。如果我去统治一个犹太人的国家，我也会重修所罗门的神庙。”</p></li><li><p>持政府和帝国的具体工作就是用新的名称把大多数过去的制度重新包装一遍，这就是说，用新名称代替那些能够让群众想起不利形象的名称，因为它们的新鲜能防止这种联想。如商号和行会的税款变成了执照费等…名称的威力如此强大，如果选择得当，它足以使最可恶的事情改头换面，变得能被民众所接受。</p></li><li><p>让人们怀抱着那些希望和幻想吧，不然他们是活不下去的。这就是存在着诸神、英雄和诗人的原因。科学承担起这一任务已有50年的时间，但是在渴望理想的心灵里，科学是有所欠缺的，因为它不敢作出过于慷慨的承诺，因为它不能撒谎。</p></li><li><p>然而群众无论付出多大的代价，他们必须拥有自己的幻想，于是他们便像趋光的昆虫一样，本能地转向那些迎合他们需要的巧舌如簧者。</p></li><li><p>群众从来就没有渴望过真理，面对那些不合口味的证据，他们会拂袖而去，假如谬论对他们有诱惑力，他们更容易崇拜谬论。凡是能向他们供应幻觉的，也可以很容易地成为他们的主人。</p></li><li><p>要让群体相信什么，首先得搞清楚让他们兴奋的感情，并且装出自己也有这种感情的样子……那些知道如何影响他们的演说家，总是诉诸他们的感情而不是他们的理性。逻辑定律对群体不起作用……若演讲者遵循的是自己的思路而不是听众的思路，仅仅这一个事实就会使他不可能产生任何影响。</p></li><li><p>一个人占据着某种位置，拥有一定的财富或头衔，仅仅这些事实，就能使他享有名望，不管他本人多么没有价值。帕斯卡尔十分正确地指出，法袍和假发使法官必不可少的行头。没了这些东西，他们的权威就会损失一半。</p></li><li><p>巴特农神庙按其现存的状态，不过是一堆非常没有意思的破败废墟，但是它的巨大名望却使它看起来不是那个样子，而是与所有的历史记忆联系在一起。</p></li><li><p>各民族一直清楚获得普遍信念的好处，他们本能地知道，这种信念的消失是他们衰败的信号。使罗马人能够征服世界的信念，是他们对罗马的狂热崇拜；当这种信念寿终正寝时，罗马也注定衰亡。</p></li><li><p>每个时代的人都是在一个由相似的传统、意见和习惯组成的基本环境中成长，他们不能摆脱这些东西的桎梏。人的行为首先是受他们的信念支配，也受由这些信念所形成的习惯支配。</p></li><li><p>利用密谋可以推翻一个暴君，而反对牢固的信念又有什么可资利用？人类所知道的唯一真正的暴君，历来就是他们对死人的怀念或他们为自己编织出来的幻觉……躺在坟墓深处的摩西、佛祖、耶稣和默罕穆德，对人类实行着更深刻的转制统治。</p></li><li><p>至于过去引导意见的报业，就像政府一样，它在群众势力面前也变得屈尊俯就。当然，它仍然有相当大的影响，然而这不过是因为它只一味反映群众的意见及其不断的变化。报业既然成了仅仅提供信息的部门，它便放弃了让人接受某种观念或学说的努力。它在公众思想的变化中随波逐流，出于竞争的必要，它也只能这样做，因为它害怕失去自己的读者。最有价值的新闻被夹在各种轻松话题、社会见闻和金融谎言之间。</p></li><li><p>人们的意见还大致存在着一般趋势，它们的产生是因为接受了一些基本的信仰，只根据某人是个君主制的拥护者这一事实，即可断定他持有某些明确的历史观和科学观；只根据某人是共和主义者，便可以说他有着完全相反的观点。</p></li><li><p>候选人可以毫无惧色地承诺最重要地改革。这些夸张能够产生巨大的效果，但它们对未来并没有约束力，因为这需要不断地进行观察，而选民绝对不想为这事操心，他并不想知道自己支持的候选人在实行他所赞成的竞选纲领上走了多远，虽然他以为正是这个纲领使他的选择有了保证。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里摘录自己看过的书里受启发的一些句子以及自己的所想&lt;br&gt;
    
    </summary>
    
    
      <category term="读书" scheme="http://Bithub00.com/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>Selenium TypeError  __init__() takes 2 positional arguments but 3 were given_解决方案</title>
    <link href="http://Bithub00.com/2019/08/21/TypeError/"/>
    <id>http://Bithub00.com/2019/08/21/TypeError/</id>
    <published>2019-08-21T07:33:10.543Z</published>
    <updated>2019-08-21T07:51:43.022Z</updated>
    
    <content type="html"><![CDATA[<h3 id="错误描述"><a href="#错误描述" class="headerlink" title="错误描述"></a>错误描述</h3><p>执行以下代码时会报错：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wait = WebDriverWait(browser, <span class="number">10</span>)</span><br><span class="line">input = wait.until</span><br><span class="line">(</span><br><span class="line">    EC.presence_of_element_located</span><br><span class="line">    (</span><br><span class="line">        By.ID, <span class="string">'search'</span> </span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>PyCharm会提示：TypeError: <strong>init</strong>() takes 2 positional arguments but 3 were given。</p><h3 id="问题来源"><a href="#问题来源" class="headerlink" title="问题来源"></a>问题来源</h3><p>在<a href="https://github.com/SeleniumHQ/selenium/blob/80adb709873815b88bb57494a6908f8b86285766/py/selenium/webdriver/support/expected_conditions.py#L53" target="_blank" rel="noopener">expected conditions.py</a>中找到<a href="https://github.com/SeleniumHQ/selenium/blob/80adb709873815b88bb57494a6908f8b86285766/py/selenium/webdriver/support/expected_conditions.py#L53" target="_blank" rel="noopener">presence_of_element_located</a>类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">presence_of_element_located</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">""" An expectation for checking that an element is present on the DOM</span></span><br><span class="line"><span class="string">    of a page. This does not necessarily mean that the element is visible.</span></span><br><span class="line"><span class="string">    locator - used to find the element</span></span><br><span class="line"><span class="string">    returns the WebElement once it is located</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, locator)</span>:</span></span><br><span class="line">        self.locator = locator</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, driver)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> _find_element(driver, self.locator)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EC.presence_of_element_located</span><br><span class="line">    (</span><br><span class="line">        By.ID, <span class="string">'search'</span> </span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p>这里如果不加小括号，相当于输入了三个参数:self、By.ID、’search’，而presence_of_element_located类的_init_方法取的是两个参数self、locator，其中locator调用的是一个tuple(元组)，所以添加小括号后将(By.ID, ‘search’)作为一个整体对应于一个参数</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>添加小括号<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EC.presence_of_element_located</span><br><span class="line">    (</span><br><span class="line">        (By.ID, <span class="string">'search'</span> )</span><br><span class="line">    )</span><br></pre></td></tr></table></figure></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="https://stackoverflow.com/questions/23661734/selenium-visibility-of-element-located-init-takes-exactly-2-arguments" target="_blank" rel="noopener">stackoverflow</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;错误描述&quot;&gt;&lt;a href=&quot;#错误描述&quot; class=&quot;headerlink&quot; title=&quot;错误描述&quot;&gt;&lt;/a&gt;错误描述&lt;/h3&gt;&lt;p&gt;执行以下代码时会报错：&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;wait = WebDriverWait(browser, &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;input = wait.until&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    EC.presence_of_element_located&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        By.ID, &lt;span class=&quot;string&quot;&gt;&#39;search&#39;&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://Bithub00.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>word转pdf图片避免压缩</title>
    <link href="http://Bithub00.com/2019/08/20/pdf/"/>
    <id>http://Bithub00.com/2019/08/20/pdf/</id>
    <published>2019-08-20T03:24:15.386Z</published>
    <updated>2019-08-20T03:48:48.633Z</updated>
    
    <content type="html"><![CDATA[<p>平时生活中经常会需要将word转换成pdf，比如个人简历，然而直接使用word的另存为pdf的话，文字部分虽然清晰，但会造成图像的失真。<br><a id="more"></a><br>如果是简历的话自己的照片就糊成一团了，这第一印象就不好了，即使是用网上所说的调整什么压缩选项也没用，该失真还是失真，今天记录一种可行的方法，需要用到Adobe pdf软件，相信很多人都有安装。</p><ul><li>首先，在编辑好的word中点击文件-打印，打印机选择Adobe pdf：</li></ul><p><img src="https://s2.ax1x.com/2019/08/20/mGKRf0.png" alt="adobe pdf"></p><ul><li>接着，点击打印机属性，默认设置这里选择下拉菜单的第一项印刷质量，然后点击编辑：</li></ul><p><img src="https://s2.ax1x.com/2019/08/20/mGMVc8.png" alt="印刷质量"></p><ul><li>左边列表中选择“图像”，然后将“彩色图像”这一区域的采样和压缩选项关闭：</li></ul><p><img src="https://s2.ax1x.com/2019/08/20/mGMsgK.png" alt="关闭采样和压缩">这里的300可以自己设置，数值越大图像质量越好，当然转换的pdf文件也就越大</p><ul><li>可以选择左下角的另存为保存设置，方便下次使用，或者直接点击确定，也会提示你进行保存：</li></ul><p><img src="https://s2.ax1x.com/2019/08/20/mG1E1x.png" alt="另存为"></p><ul><li><p>保存完后，回到刚刚的窗口，在默认设置中选择刚刚保存的设置，点击确定，然后在打印页面选择打印就可以了，这时候输出的pdf图像就不会失真</p></li><li><p>虽然图像不会失真，但是pdf文件往往也会变大了很多，不便于邮件发送和查看，这时候推荐一个pdf压缩的网站：<a href="https://www.ilovepdf.com/zh-cn" target="_blank" rel="noopener">ilovepdf</a>，对自己的pdf进行压缩就可以了</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;平时生活中经常会需要将word转换成pdf，比如个人简历，然而直接使用word的另存为pdf的话，文字部分虽然清晰，但会造成图像的失真。&lt;br&gt;
    
    </summary>
    
    
      <category term="pdf" scheme="http://Bithub00.com/tags/pdf/"/>
    
  </entry>
  
  <entry>
    <title>RUC与AOC</title>
    <link href="http://Bithub00.com/2019/08/07/ROC%E4%B8%8EAUC/"/>
    <id>http://Bithub00.com/2019/08/07/ROC与AUC/</id>
    <published>2019-08-07T07:38:52.547Z</published>
    <updated>2019-08-07T12:00:22.361Z</updated>
    
    <content type="html"><![CDATA[<p>用本文记录自己对ROC曲线与AUC值的学习和理解<br><a id="more"></a></p><h3 id="ROC曲线定义"><a href="#ROC曲线定义" class="headerlink" title="ROC曲线定义"></a>ROC曲线定义</h3><p>ROC曲线与AUC值常被用来评价一个二分类器的好坏，以下内容出自项亮《推荐系统实践》的“分类问题”一节：</p><blockquote><p>对于二类分类问题常用的评价指标是精确率(precision)和召回率(recall)，通常以关注的类为正类，其他类为负类，分类器可将实例分成正类(positive)和负类(negative)，预测时会出现4种情况：  </p><ul><li>TP (True Positice)——将正类预测为正类数</li><li>FN (False Negative)——将正类预测为负类数</li><li>FP (False Positive)——将负类预测为正类数</li><li>TN (True Negative)——将负类预测为负类数  </li></ul><p>精确率定义为</p><script type="math/tex; mode=display">P =\frac{TP}{TP + FP}</script><p>召回率定义为</p><script type="math/tex; mode=display">R =\frac{TP}{TP + FN}</script></blockquote><p>而ROC曲线与上面的定义有关，FPR(False Positive Rate)为x轴，它以TPR(True Positive Rate)为y轴，它们的定义分别为：</p><script type="math/tex; mode=display">\begin{aligned}TPR & = \frac{TP}{TP+FN} \\FPR & =1-\frac{TN}{TN+FP} \\& = \frac{FP}{TN+FP}\end{aligned}</script><p>可以看到，TPR与召回率的定义是一样的，直观理解是：</p><ul><li>横坐标：伪正类率(False positive rate， FPR)，<strong>预测为正但实际为负</strong>的样本占所有<strong>负例样本</strong>的比例；</li><li>纵坐标：真正类率(True positive rate， TPR)，<strong>预测为正且实际为正</strong>的样本占所有<strong>正例样本</strong>的比例。</li></ul><p>其实ROC的曲线的横坐标和纵坐标是没有相关性的，不能把ROC曲线当成函数曲线来分析，应该把它看成无数个点，每个点都代表一个分类器，其横纵坐标代表了这个分类器的性能。为了更好的理解ROC曲线，引入ROC空间的概念：<br><img src="https://s2.ax1x.com/2019/08/07/eIKD5d.png" alt="ROC空间"></p><p>A,B,C,C’为四个分类器，指标如下：<br><img src="https://s2.ax1x.com/2019/08/07/eI82Mn.png" alt="分类器"></p><p>其中C’的性能最好，B的准确率为0.5，几乎是随即分类，图中左上角的点为完美分类，它代表所有的分类完全正确，分类为1的点完全正确，分类为0的点没有错误。<br>在一个二分类模型中，分类器给出每个实例为正类的概率，那么通过设定一个阈值如0.6，概率大于等于0.6的为正类，小于0.6的为负类。对应的就可以算出一组(FPR,TPR)，在平面中得到对应坐标点。随着阈值的逐渐减小，越来越多的实例被划分为正类，但是这些正类中同样也掺杂着真正的负实例，即TPR和FPR会同时增大。阈值最大时，对应坐标点为(0,0)，阈值最小时，对应坐标点(1,1)</p><p>典型的ROC曲线：<br><img src="https://s2.ax1x.com/2019/08/07/eI8jZ6.png" alt="eI8jZ6.png"></p><p>理想情况下，TPR应该接近1，FPR应该接近0。ROC曲线上的每一个点对应于一个阈值，对于一个分类器，每个阈值下会有一个TPR和FPR。比如阈值最大时，TP=FP=0，对应于原点；阈值最小时，TN=FN=1，对应于右上角的点(1,1)。</p><h3 id="绘制ROC曲线"><a href="#绘制ROC曲线" class="headerlink" title="绘制ROC曲线"></a>绘制ROC曲线</h3><p>对于一个特定的分类器和测试数据集，显然只能得到一个分类结果，即一组FPR和TPR结果，而要得到一个曲线，我们实际上需要一系列FPR和TPR的值，如何得到呢？办法就是从阈值下手。分类器的一个重要功能是“概率输出”，即表示分类器认为某个样本具有多大的概率属于正样本（或负样本）。<br>假如我们已经得到了所有样本的概率输出（属于正样本的概率），现在的问题是如何改变阈值从而得到不同的PPR和TPR结果。根据每个测试样本属于正样本的概率值从大到小排序，下图是一个示例，图中共有20个测试样本，“Class”一栏表示每个测试样本真正的标签（p表示正样本，n表示负样本），“Score”表示每个测试样本属于正样本的概率。</p><p><img src="https://s2.ax1x.com/2019/08/07/eII1PK.png" alt="eII1PK.png"></p><p>接下来从高到低，依次将“Score”值作为阈值，当测试样本属于正样本的概率大于或等于这个阈值时，我们认为它为正样本，否则为负样本。举例来说，对于图中的第4个样本，其“Score”值为0.6，那么样本1，2，3，4都被认为是正样本，因为它们的“Score”值都大于等于0.6，而其他样本则都认为是负样本。每次选取一个不同的阈值，我们就可以得到一组FPR和TPR，即ROC曲线上的一点。这样一来，我们一共得到了20组FPR和TPR的值，将它们画在ROC曲线的结果如下图：</p><p><img src="https://s2.ax1x.com/2019/08/07/eIIdat.png" alt="eIIdat.png"></p><p>当我们将阈值设置为1和0时，分别可以得到ROC曲线上的(0,0)和(1,1)两个点。将这些(FPR,TPR)对连接起来，就得到了ROC曲线。当阈值取值越多，ROC曲线越平滑。<br>其实并不一定要得到每个测试样本是正样本的概率值，只要得到这个分类器对该测试样本的“评分值”即可（评分值并不一定在(0,1)区间）。评分越高，表示分类器越肯定地认为这个测试样本是正样本，而且同时使用各个评分值作为阈值。</p><h3 id="AUC值定义"><a href="#AUC值定义" class="headerlink" title="AUC值定义"></a>AUC值定义</h3><p>AUC (Area Under Curve) 被定义为ROC曲线下的面积，这个面积的数值不会大于1。又由于ROC曲线一般都处于y=x这条直线的上方，所以AUC的取值范围一般在0.5和1之间。使用AUC值作为评价标准是因为很多时候ROC曲线并不能清晰的说明哪个分类器的效果更好，而作为一个数值，对应AUC更大的分类器效果更好。<br>将AUC值看成一个概率值，当你随机挑选一个正样本以及一个负样本，当前的分类算法根据计算得到的Score值将这个正样本排在负样本前面的概率就是AUC值。当然，AUC值越大，当前的分类算法越有可能将正样本排在负样本前面，即能够更好的分类。<br>从AUC判断分类器（预测模型）优劣的标准：  </p><ul><li>AUC = 1，完美分类器，采用这个预测模型时，存在至少一个阈值能得出完美预测。绝大多数预测的场合，不存在完美分类器。</li><li>0.5 &lt; AUC &lt; 1，优于随机猜测。这个分类器（模型）妥善设定阈值的话，能有预测价值。</li><li>AUC = 0.5，跟随机猜测一样（例：丢铜板），模型没有预测价值。</li><li>AUC &lt; 0.5，比随机猜测还差；对预测结果取反之后就优于随机猜测。</li></ul><p>三种AUC值示例：<br><img src="https://s2.ax1x.com/2019/08/07/eIILZR.png" alt="eIILZR.png"></p><h3 id="为什么用ROC曲线"><a href="#为什么用ROC曲线" class="headerlink" title="为什么用ROC曲线"></a>为什么用ROC曲线</h3><p>既然已经这么多评价标准，为什么还要使用ROC和AUC呢？因为ROC曲线有个很好的特性：当测试集中的正负样本的分布变化的时候，ROC曲线能够保持不变。在实际的数据集中经常会出现类不平衡（class imbalance）现象，即负样本比正样本多很多（或者相反），而且测试数据中的正负样本的分布也可能随着时间变化。下图是ROC曲线和Precision-Recall曲线的对比：</p><p><img src="https://s2.ax1x.com/2019/08/07/eIokdI.png" alt="eIokdI.png"></p><p>在上图中，(a)和(c)为ROC曲线，(b)和(d)为Precision-Recall曲线。(a)和(b)展示的是分类其在原始测试集（正负样本分布平衡）的结果，(c)和(d)是将测试集中负样本的数量增加到原来的10倍后，分类器的结果。可以明显的看出，ROC曲线基本保持原貌，而Precision-Recall曲线则变化较大。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://en.wikipedia.org/wiki/Receiver_operating_characteristic" target="_blank" rel="noopener">维基百科</a></li><li><a href="http://alexkong.net/2013/06/introduction-to-auc-and-roc/" target="_blank" rel="noopener">孔明的博客</a></li><li><a href="https://blog.csdn.net/abcjennifer/article/details/7359370" target="_blank" rel="noopener">ROC曲线-阈值评价标准</a></li><li><a href="https://www.jianshu.com/p/c61ae11cc5f6" target="_blank" rel="noopener">简书</a></li><li><a href="http://www.cnblogs.com/dlml/p/4403482.html" target="_blank" rel="noopener">博客园</a></li><li><a href="https://www.zhihu.com/question/30643044" target="_blank" rel="noopener">知乎问答</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用本文记录自己对ROC曲线与AUC值的学习和理解&lt;br&gt;
    
    </summary>
    
    
      <category term="评价指标" scheme="http://Bithub00.com/tags/%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/"/>
    
  </entry>
  
  <entry>
    <title>推荐系统学习记录</title>
    <link href="http://Bithub00.com/2019/08/05/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"/>
    <id>http://Bithub00.com/2019/08/05/推荐系统/</id>
    <published>2019-08-05T11:40:06.163Z</published>
    <updated>2019-08-13T08:09:34.226Z</updated>
    
    <content type="html"><![CDATA[<p>用本文记录学习推荐系统的过程，以及一些实用的资料与资源。<br><a id="more"></a></p><h2 id="推荐系统数据集"><a href="#推荐系统数据集" class="headerlink" title="推荐系统数据集"></a>推荐系统数据集</h2><ol><li><a href="http://cseweb.ucsd.edu/~jmcauley/datasets.html" target="_blank" rel="noopener">UCSD</a></li><li><a href="https://gist.github.com/entaroadun/1653794" target="_blank" rel="noopener">github</a></li></ol><h2 id="基于隐式反馈数据的推荐系统【理论及python实践】"><a href="#基于隐式反馈数据的推荐系统【理论及python实践】" class="headerlink" title="基于隐式反馈数据的推荐系统【理论及python实践】"></a>基于隐式反馈数据的推荐系统【理论及python实践】</h2><blockquote><p>Yifan Hu,Yehuda Koren,Chris Volinsky.<a href="http://yifanhu.net/PUB/cf.pdf" target="_blank" rel="noopener">Collaborative Filtering for Implicit Feedback Datasets</a>[J].IEEE International Conference on Data Mining，2008</p></blockquote><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>隐式反馈(Implict)数据就是用户的行为数据，包括点击，浏览和停留等，它不像评分和点赞一样直观地表示了用户的喜好。实际情况中像评分这种显式数据往往很难获得，因为它输入用户额外的进行操作，而像点击这种隐式反馈的数据，是随着用户的行为自然产生的，不需要额外的获取成本，因此实际情况中隐式反馈的数据规模要远大于显式反馈，因此很有必要研究基于隐式反馈数据的推荐系统</p><p>隐式反馈数据的特征：</p><ol><li>没有负样本。不同于评分，用户可以通过打低分来表达对某个物品的厌恶，我们只能通过点击猜测用户可能对某个物品有偏好，而不能通过没有点击来说明用户不喜欢，可能只是他还没接触过这个物品。处理显式数据时，缺失的评分项可以当作缺失值处理，而处理隐式数据时，为了避免只得到正向反馈，必须要对数据整体进行分析。</li><li>隐含很多的噪声数据。例如用户购买某个物品，不代表他一定喜欢这个物品，可能只是作为礼物或者其它原因，而给一个物品打高分可以很大程度上表示他偏好这个用品。</li><li>数值含义不同。在显式数据里，数值的含义代表偏好程度，如评分；而隐式数据里，数值代表置信度，往往表现为行为的频率，例如观看次数等等。频率越高，我们越能确定它与用户的偏好相关联，而不是一个偶然性情况。</li><li>评价指标不同。传统的推荐系统可以使用如均方根误差(Mean Square Error)来判断预测的好坏，而隐式数据上会有不同。</li></ol><h3 id="符号定义"><a href="#符号定义" class="headerlink" title="符号定义"></a>符号定义</h3><p>$r_{ui}$定义为用户$u$对物品$i$的一次观测值，例如购买物品的次数或浏览网页的次数，在电视节目推荐中，它代表完整观看某个节目的次数，0.7表示观看了节目的70%。区别于显式数据将空缺数据当作缺失值处理，我们将缺失值置为0，表示没有此观测记录。</p><h3 id="隐语义模型"><a href="#隐语义模型" class="headerlink" title="隐语义模型"></a>隐语义模型</h3><p>隐语义模型通过用户特征向量$x_u\in R^f$和物品特征向量$y_i\in R^f$来进行预测，预测评分用上面两个向量的内积形式表示：$\hat{r}_{ui}=x_u^Ty_i$，具体细节可见另一篇博客的<a href="http://www.bithub00.com/2019/04/12/imputing%20structured%20missing%20values%20in%20spatial%20data%20with%20clsutered%20adversarial%20matrix%20factorization/" target="_blank" rel="noopener">矩阵分解引入</a>部分。目标函数表示为：</p><script type="math/tex; mode=display">min_{x_*,y_*}\sum_{r_{ui}\ is\ known}(r_{ui}-x_u^Ty_i)^2+\lambda(\mid\mid x_u \mid\mid^2+\mid\mid y_i \mid\mid^2)</script><p>公式中的$\lambda$作为正则化参数，用于<a href="http://www.bithub00.com/2019/04/03/%E8%8C%83%E6%95%B0/" target="_blank" rel="noopener">约束</a>模型，参数的求解常使用随机梯度下降。然而这种方法在应用于隐式反馈数据时需要做调整</p><h3 id="论文提出的模型"><a href="#论文提出的模型" class="headerlink" title="论文提出的模型"></a>论文提出的模型</h3><p>首先引入一个二值变量$p_{ui}$来标识用户对物品是否产生过行为如购买、观看等等：</p><script type="math/tex; mode=display">p_{ui} =\begin{cases}1, &r_{ui} > 0\\0, &r_{ui} = 0\end{cases}</script><p>注意，$p_{ui}=1$只是暗示了用户喜欢某个物品的可能，而且$r_{ui}$的数值越大应该表示喜欢的可能性越大，因此再引入变量表示这种可能性：</p><script type="math/tex; mode=display">c_{ui}=1+\alpha r_{ui}</script><p>引入$c_{ui}$后，对于每一个观测值，我们有一个最小的可能性1，随着观测值的增大，可能性也在逐渐增大，这里的可能性与概率的含义不同，论文中将常数$\alpha$设为40<br>我们的目标是为每一个用户和物品分别得到一个用户特征向量$x_u\in R^f$和物品特征向量$y_i\in R^f$，则预测值可以通过两个向量的内积表示：$p_{ui}=x^T_uy_i$，即预测用户是否会对某个物品产生行为，则目标函数可表示为：</p><script type="math/tex; mode=display">min_{x_*,y_*}L(X,Y)=min_{x_*,y_*}\sum_{u,i}c_{ui}(p_{ui}-x_u^Ty_i)^2+\lambda(\sum_u\mid\mid x_u \mid\mid^2+\sum_i\mid\mid y_i \mid\mid^2)</script><p>同理，第二项为约束项，防止过拟合于训练数据。下一步就是根据目标函数进行求解，因为原始表达式计算复杂度太高，输入的数据集为$m\ast n$的矩阵，m为用户数，n为物品数，规模很容易达到百万级，需要进行相应的优化。<br>我们引入交替最小二乘法(Alternate Least Sqaures)， 目标函数需要优化用户和物品两个维度，可以先固定物品这个维度，对用户唯独进行优化，我的推导过程（论文只给了结果表达式）：<br>对$x_u$求导，可得：</p><script type="math/tex; mode=display">\begin{aligned}\frac{\partial L}{\partial x_u} & = -2\sum_i(p_{ui}-x^T_uy_i)y_ic_{ui}+2\lambda x_u \\& = -2\sum_i(p_{ui}-y_i^Tx_u)y_ic_{ui} + 2\lambda x_u \\& = -2Y^TC_up(u)+2Y^TC_uYx_u+2\lambda x_u\end{aligned}</script><p>其中$Y_{n\ast f}$为含有所有物品特征向量的矩阵，f类似隐语义模型中的隐含特征，可见<a href="http://www.bithub00.com/2019/04/12/imputing%20structured%20missing%20values%20in%20spatial%20data%20with%20clsutered%20adversarial%20matrix%20factorization/" target="_blank" rel="noopener">矩阵分解引入</a>中的解释。令求导结果为0，则有：</p><script type="math/tex; mode=display">\begin{aligned}Y^TC_uYx_u+\lambda Ix_u & = Y^TC_uP_u \\x_u & = (Y^TC_uY+\lambda I)^{-1}Y^TC_up(u)\end{aligned}</script><p>观察表达式，计算复杂度的瓶颈在于计算$Y^TC^uY$这一部分，计算每一个用户的时间复杂度为$O(f^2n)$，我们使用线性代数的知识进行简单的变形：$Y^TC^uY=Y^TY+Y^T(C^u-I)Y$，其中$Y^TY$与用户u无关，可以在迭代开始时预先计算，而$Y^T(C^u-I)Y$中的$C^u-I$只有$n_u$个非零值，其中$n_u$是用户u$r_{ui}&gt;0$的个数，很明显$n_u\ll n$。同样地，$C^up(u)$也只含有$n_u$个非零值，则此时对于单个用户$x_u$的计算复杂度为$O(f^2n_u+f^3)$，其中$O(f^3)$求逆的时间复杂度，总共有m个用户，所以总的时间复杂度为$O(f^2N+f^3m)$，N为总的非零值的个数，隐含特征f的个数通常设置为$20-200$。则$y_i$的表达式同理：</p><script type="math/tex; mode=display">y_i=(X^TC^iX+\lambda I)^{-1}X^TC^ip(i)</script><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>理解完论文框架后，使用一个<a href="http://archive.ics.uci.edu/ml/machine-learning-databases/00352" target="_blank" rel="noopener">数据集</a>进行实践，自己构建一个基于隐式反馈数据的推荐系统。数据集来源于UCI大学的机器学习资源库，它包含了一个位于英国的网上零售商时间跨度为八个月的所以购买记录，数据集中包含了InvoiceNo StockCode Description Quantity InvoiceDate UnitPrice CustomID Country这些字段。</p><h4 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h4><ul><li>下载数据并读取<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">retail_data = pd.read_excel(<span class="string">'Online Retail.xlsx'</span>)</span><br><span class="line">print(retail_data.info())</span><br><span class="line"></span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">pandas</span>.<span class="title">core</span>.<span class="title">frame</span>.<span class="title">DataFrame</span>'&gt;</span></span><br><span class="line"><span class="class"><span class="title">RangeIndex</span>:</span> <span class="number">541909</span> entries, <span class="number">0</span> to <span class="number">541908</span></span><br><span class="line">Data columns (total <span class="number">8</span> columns):</span><br><span class="line">InvoiceNo      <span class="number">541909</span> non-null object</span><br><span class="line">StockCode      <span class="number">541909</span> non-null object</span><br><span class="line">Description    <span class="number">540455</span> non-null object</span><br><span class="line">Quantity       <span class="number">541909</span> non-null int64</span><br><span class="line">InvoiceDate    <span class="number">541909</span> non-null datetime64[ns]</span><br><span class="line">UnitPrice      <span class="number">541909</span> non-null float64</span><br><span class="line">CustomerID     <span class="number">406829</span> non-null float64</span><br><span class="line">Country        <span class="number">541909</span> non-null object</span><br><span class="line">dtypes: datetime64[ns](<span class="number">1</span>), float64(<span class="number">2</span>), int64(<span class="number">1</span>), object(<span class="number">4</span>)</span><br><span class="line">memory usage: <span class="number">33.1</span>+ MB</span><br></pre></td></tr></table></figure></li></ul><p>可以看到，除了CustomerID这一字段外，其它字段几乎没有缺失值，但如果CustomerID未知，我们就无法知道购买记录中是谁购买了某个商品，因此需要将CustomerID未知的记录去除：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">cleaned_retail = retail_data.loc[pd.isnull(retail_data.CustomerID) == <span class="keyword">False</span>]</span><br><span class="line">print(cleaned_retail.info())</span><br><span class="line"></span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">pandas</span>.<span class="title">core</span>.<span class="title">frame</span>.<span class="title">DataFrame</span>'&gt;</span></span><br><span class="line"><span class="class"><span class="title">Int64Index</span>:</span> <span class="number">406829</span> entries, <span class="number">0</span> to <span class="number">541908</span></span><br><span class="line">Data columns (total <span class="number">8</span> columns):</span><br><span class="line">InvoiceNo      <span class="number">406829</span> non-null object</span><br><span class="line">StockCode      <span class="number">406829</span> non-null object</span><br><span class="line">Description    <span class="number">406829</span> non-null object</span><br><span class="line">Quantity       <span class="number">406829</span> non-null int64</span><br><span class="line">InvoiceDate    <span class="number">406829</span> non-null datetime64[ns]</span><br><span class="line">UnitPrice      <span class="number">406829</span> non-null float64</span><br><span class="line">CustomerID     <span class="number">406829</span> non-null float64</span><br><span class="line">Country        <span class="number">406829</span> non-null object</span><br><span class="line">dtypes: datetime64[ns](<span class="number">1</span>), float64(<span class="number">2</span>), int64(<span class="number">1</span>), object(<span class="number">4</span>)</span><br><span class="line">memory usage: <span class="number">27.9</span>+ MB</span><br></pre></td></tr></table></figure></p><p>这样所有的购买记录都可以对应到唯一的顾客了。接下来我们生成一个商品的描述表，方便查看某个商品编号对应的商品是什么：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">item_lookup = cleaned_retail[[<span class="string">'StockCode'</span>, <span class="string">'Description'</span>]].drop_duplicates()</span><br><span class="line">item_lookup[<span class="string">'StockCode'</span>] = item_lookup.StockCode.astype(str)</span><br><span class="line">print(item_lookup.info()) </span><br><span class="line"></span><br><span class="line">        StockCodeDescription</span><br><span class="line"><span class="number">0</span><span class="number">85123</span>AWHITE HANGING HEART T-LIGHT HOLDER</span><br><span class="line"><span class="number">1</span><span class="number">71053</span>WHITE METAL LANTERN</span><br><span class="line"><span class="number">2</span><span class="number">84406</span>BCREAM CUPID HEARTS COAT HANGER</span><br><span class="line"><span class="number">3</span><span class="number">84029</span>GKNITTED UNION FLAG HOT WATER BOTTLE</span><br><span class="line"><span class="number">4</span><span class="number">84029</span>ERED WOOLLY HOTTIE WHITE HEART.</span><br></pre></td></tr></table></figure></p><p>接下来需要做的是</p><ul><li><p>对于某个用户，将他购买的相同物品的数目进行求和</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cleaned_retail[<span class="string">'CustomerID'</span>] = cleaned_retail.CustomerID.astype(int)</span><br><span class="line">cleaned_retail = cleaned_retail[[<span class="string">'StockCode'</span>, <span class="string">'Quantity'</span>, <span class="string">'CustomerID'</span>]]</span><br><span class="line">grouped_cleaned = cleaned_retail.groupby([<span class="string">'CustomerID'</span>, <span class="string">'StockCode'</span>]).sum().reset_index()</span><br></pre></td></tr></table></figure></li><li><p>将求和结果中的0置为1，数目为0的情况往往是顾客进行了退货，这种情况我们也当作顾客购买了商品，而不是当作没购买的情况处理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grouped_cleaned.Quantity.loc[grouped_cleaned.Quantity == <span class="number">0</span>] = <span class="number">1</span></span><br></pre></td></tr></table></figure></li><li><p>去除求和结果中小于0的记录</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grouped_purchased = grouped_cleaned.query(<span class="string">'Quantity &gt; 0'</span>)</span><br></pre></td></tr></table></figure></li><li><p>建立ALS算法中输入的数据矩阵</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">customers = list(np.sort(grouped_purchased.CustomerID.unique()))  </span><br><span class="line">products = list(grouped_purchased.StockCode.unique())</span><br><span class="line">quantity = list(grouped_purchased.Quantity)</span><br><span class="line">rows = grouped_purchased.CustomerID.astype(<span class="string">'category'</span>, categories=customers).cat.codes</span><br><span class="line">cols = grouped_purchased.StockCode.astype(<span class="string">'category'</span>, categories=products).cat.codes</span><br><span class="line">purchases_sparse = sparse.csr_matrix((quantity, (rows, cols)), shape=(len(customers), len(products)))</span><br><span class="line"></span><br><span class="line">&lt;<span class="number">4338</span>x3664 sparse matrix of type <span class="string">'&lt;class '</span>numpy.int64<span class="string">'&gt;'</span></span><br><span class="line"><span class="keyword">with</span> <span class="number">266723</span> stored elements <span class="keyword">in</span> Compressed Sparse Row format&gt;</span><br></pre></td></tr></table></figure></li></ul><p>构建的输入矩阵维度是$4338\ast 3664$，其中有266723个非空值。</p><h4 id="划分数据集"><a href="#划分数据集" class="headerlink" title="划分数据集"></a>划分数据集</h4><p>接下来需要把输入数据划分为训练集和测试集，传统的划分方式如图所示：</p><p><img src="https://s2.ax1x.com/2019/08/07/e5hMTK.png" alt="划分数据"></p><p>然而这种方式对于推荐系统是不适用的，因为矩阵分解时需要用上所有的用户-物品数据，更好的方法是随机隐藏输入矩阵中的某些观测值，将隐藏好的矩阵作为训练数据，将完整的矩阵作为测试矩阵，来判断推荐的物品用户是否会购买。</p><p><img src="https://s2.ax1x.com/2019/08/07/e54m9g.png" alt="划分数据"></p><p>为了对比推荐的效果，我们可以和另一种推荐方法作对比，即只推荐最流行的物品。</p><ul><li>划分数据集<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_train</span><span class="params">(ratings, pct_test)</span>:</span></span><br><span class="line">        test_set = ratings.copy()</span><br><span class="line">        test_set[test_set != <span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        training_set = ratings.copy()</span><br><span class="line">        nonzero_inds = training_set.nonzero()</span><br><span class="line">        nonzero_pairs = list(zip(nonzero_inds[<span class="number">0</span>], nonzero_inds[<span class="number">1</span>]))</span><br><span class="line">        random.seed(<span class="number">0</span>)</span><br><span class="line">        num_samples = int(np.ceil(pct_test * len(nonzero_pairs)))</span><br><span class="line">        samples = random.sample(nonzero_pairs, num_samples)</span><br><span class="line">        user_inds = [index[<span class="number">0</span>] <span class="keyword">for</span> index <span class="keyword">in</span> samples]</span><br><span class="line">        item_inds = [index[<span class="number">1</span>] <span class="keyword">for</span> index <span class="keyword">in</span> samples]</span><br><span class="line">        training_set[user_inds, item_inds] = <span class="number">0</span></span><br><span class="line">        training_set.eliminate_zeros()</span><br><span class="line">        <span class="keyword">return</span> training_set, test_set, list(set(user_inds))</span><br></pre></td></tr></table></figure></li></ul><h4 id="ALS算法"><a href="#ALS算法" class="headerlink" title="ALS算法"></a>ALS算法</h4><p>下一步就是实现论文所用的ALS算法，具体数学公式见上面的推导：</p><ul><li>ALS算法<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">implicit_weighted_ALS</span><span class="params">(training_set, lambda_val=<span class="number">0.1</span>, alpha=<span class="number">40</span>, iterations=<span class="number">10</span>, rank_size=<span class="number">20</span>, seed=<span class="number">0</span>)</span>:</span></span><br><span class="line">    conf = (alpha * training_set)</span><br><span class="line">    num_user = conf.shape[<span class="number">0</span>]</span><br><span class="line">    num_item = conf.shape[<span class="number">1</span>]</span><br><span class="line">    rstate = np.random.RandomState(seed)</span><br><span class="line">    X = sparse.csr_matrix(rstate.normal(size=(num_user, rank_size)))</span><br><span class="line">    Y = sparse.csr_matrix(rstate.normal(size=(num_item, rank_size)))</span><br><span class="line">    X_eye = sparse.eye(num_user)</span><br><span class="line">    Y_eye = sparse.eye(num_item)</span><br><span class="line">    lambda_eye = lambda_val * sparse.eye(rank_size)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> iter_step <span class="keyword">in</span> range(iterations):  </span><br><span class="line">        yTy = Y.T.dot(Y)</span><br><span class="line">        xTx = X.T.dot(X)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> u <span class="keyword">in</span> range(num_user):</span><br><span class="line">            conf_samp = conf[u, :].toarray()</span><br><span class="line">            pref = conf_samp.copy()</span><br><span class="line">            pref[pref != <span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">            CuI = sparse.diags(conf_samp, [<span class="number">0</span>])</span><br><span class="line">            yTCuIY = Y.T.dot(CuI).dot(Y)  </span><br><span class="line">            yTCupu = Y.T.dot(CuI + Y_eye).dot(pref.T)</span><br><span class="line">            X[u] = spsolve(yTy + yTCuIY + lambda_eye, yTCupu)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(num_item):</span><br><span class="line">            conf_samp = conf[:, i].T.toarray()</span><br><span class="line">            pref = conf_samp.copy()</span><br><span class="line">            pref[pref != <span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">            CiI = sparse.diags(conf_samp, [<span class="number">0</span>])</span><br><span class="line">            xTCiIX = X.T.dot(CiI).dot(X)  </span><br><span class="line">            xTCiPi = X.T.dot(CiI + X_eye).dot(pref.T)</span><br><span class="line">            Y[i] = spsolve(xTx + xTCiIX + lambda_eye, xTCiPi)</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> X, Y.T</span><br></pre></td></tr></table></figure></li></ul><p>我们可以举一个例子来看看效果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">user_vecs, item_vecs = implicit_weighted_ALS(product_train, lambda_val = <span class="number">0.1</span>, alpha = <span class="number">15</span>, iterations = <span class="number">1</span>, rank_size = <span class="number">20</span>)</span><br><span class="line">print(user_vecs[<span class="number">0</span>,:].dot(item_vecs).toarray()[<span class="number">0</span>,:<span class="number">5</span>])</span><br><span class="line">[ <span class="number">0.00644811</span>, <span class="number">-0.0014369</span> ,  <span class="number">0.00494281</span>,  <span class="number">0.00027502</span>,  <span class="number">0.01275582</span> ]</span><br></pre></td></tr></table></figure></p><p>对第一个用户来说，前五个物品中第五个物品的得分最高，因此会被用于推荐，这只是一次迭代的结果，迭代多次效果会更好，但原始ALS的算法计算过程太慢，我们需要对它加速，可以使用github上star数上千的python ALS加速版本，所用时间要少得多：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> implict</span><br><span class="line">alpha = <span class="number">15</span></span><br><span class="line">product_train, product_test, product_users_altered = make_train(purchases_sparse, pct_test=<span class="number">0.2</span>)</span><br><span class="line">user_vecs, item_vecs = implicit.alternating_least_squares((product_train * alpha).astype(<span class="string">'double'</span>), factors=<span class="number">20</span>, regularization=<span class="number">0.1</span>, iterations=<span class="number">50</span>)</span><br></pre></td></tr></table></figure></p><p>可以直观地感觉到计算速度大大加快了，用兴趣的可以去github上看看<a href="https://github.com/benfred/implicit" target="_blank" rel="noopener">源代码</a></p><h4 id="效果评估"><a href="#效果评估" class="headerlink" title="效果评估"></a>效果评估</h4><p>数据集有了，推荐系统也搭好了，那下一步就是对我们的推荐系统进行评估，看看它的表现。在划分训练集和测试集时，有这么一步：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test_set[test_set != <span class="number">0</span>] = <span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>于是推荐就变成了一个二分类问题，购买1或不购买0，这时就可以引入分类系统的评测指标：ROC(Receiver Operating Characteristic)曲线与AUC(Area Under the Curve)值。它的介绍可以看另一篇博客<a href="http://www.bithub00.com/2019/08/07/ROC%E4%B8%8EAUC/" target="_blank" rel="noopener">ROC与AUC</a>。接下来是编写一个函数计算AUC值以进行比较：</p><ul><li>AUC<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> metrics</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">auc_score</span><span class="params">(predictions, test)</span>:</span></span><br><span class="line">    fpr, tpr, thresholds = metrics.roc_curve(test, predictions)</span><br><span class="line">    <span class="keyword">return</span> metrics.auc(fpr, tpr)</span><br></pre></td></tr></table></figure></li></ul><p>基于上面这个函数，我们为训练集中每一个被隐藏了至少一条记录的用户计算AUC值，随后求平均值并与“推荐最流行物品”的策略进行比较：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc_mean_auc</span><span class="params">(training_set, altered_users, predictions, test_set)</span>:</span></span><br><span class="line">    store_auc = []</span><br><span class="line">    popularity_auc = []</span><br><span class="line">    pop_items = np.array(test_set.sum(axis=<span class="number">0</span>)).reshape(<span class="number">-1</span>)</span><br><span class="line">    item_vecs = predictions[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> user <span class="keyword">in</span> altered_users:</span><br><span class="line">        training_row = training_set[user, :].toarray().reshape(<span class="number">-1</span>) </span><br><span class="line">        zero_inds = np.where(training_row == <span class="number">0</span>)</span><br><span class="line">        user_vec = predictions[<span class="number">0</span>][user, :]</span><br><span class="line">        pred = user_vec.dot(item_vecs).toarray()[<span class="number">0</span>, zero_inds].reshape(<span class="number">-1</span>)</span><br><span class="line">        actual = test_set[user, :].toarray()[<span class="number">0</span>, zero_inds].reshape(<span class="number">-1</span>)</span><br><span class="line">        pop = pop_items[zero_inds]</span><br><span class="line">        store_auc.append(auc_score(pred, actual))</span><br><span class="line">        popularity_auc.append(auc_score(pop, actual))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> float(<span class="string">'%.3f'</span> % np.mean(store_auc)), float(<span class="string">'%.3f'</span> % np.mean(popularity_auc))</span><br><span class="line"></span><br><span class="line">print(calc_mean_auc(product_train, product_users_altered,[sparse.csr_matrix(user_vecs), sparse.csr_matrix(item_vecs.T)], product_test))</span><br><span class="line">(<span class="number">0.87</span>, <span class="number">0.814</span>)</span><br></pre></td></tr></table></figure></p><p>从结果可以看出，使用论文提出的推荐模型的效果是比单纯推荐最流行物品的效果要好的。</p><h4 id="实例观察"><a href="#实例观察" class="headerlink" title="实例观察"></a>实例观察</h4><p>AUC值的大小比较还是比较抽象不够直观，下一步选取一个用户查看他购买过的物品，以及模型所推荐的物品来直观地感受推荐的效果。首先编写一个函数，根据customer_id来获得他所购买的商品的一个列表：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_items_purchased</span><span class="params">(customer_id, mf_train, customers_list, products_list, item_lookup)</span>:</span></span><br><span class="line">    cust_ind = np.where(customers_list == customer_id)[<span class="number">0</span>][<span class="number">0</span></span><br><span class="line">    purchased_ind = mf_train[cust_ind,:].nonzero()[<span class="number">1</span>]</span><br><span class="line">    prod_codes = products_list[purchased_ind]</span><br><span class="line">    <span class="keyword">return</span> item_lookup.loc[item_lookup.StockCode.isin(prod_codes)]</span><br><span class="line"></span><br><span class="line">customers_arr = np.array(customers)</span><br><span class="line">products_arr = np.array(products)</span><br><span class="line">print(get_items_purchased(<span class="number">12346</span>, product_train, customers_arr, products_arr, item_lookup))</span><br><span class="line"></span><br><span class="line">StockCodeDescription</span><br><span class="line"><span class="number">61619</span><span class="number">23166</span>MEDIUM CERAMIC TOP STORAGE JAR</span><br></pre></td></tr></table></figure></p><p>根据结果显示，这位顾客曾经购买了一个中等大小的陶瓷罐用于装东西，我们的推荐系统会推荐什么样的物品给他呢？<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> MinMaxScaler</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rec_items</span><span class="params">(customer_id, mf_train, user_vecs, item_vecs, customer_list, item_list, item_lookup, num_items=<span class="number">10</span>)</span>:</span></span><br><span class="line">    cust_ind = np.where(customer_list == customer_id)[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">    pref_vec = mf_train[cust_ind, :].toarray()</span><br><span class="line">    pref_vec = pref_vec.reshape(<span class="number">-1</span>) + <span class="number">1</span> </span><br><span class="line">    pref_vec[pref_vec &gt; <span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">    rec_vector = user_vecs[cust_ind, :].dot(item_vecs.T)</span><br><span class="line">    min_max = MinMaxScaler()</span><br><span class="line">    rec_vector_scaled = min_max.fit_transform(rec_vector.reshape(<span class="number">-1</span>, <span class="number">1</span>))[:, <span class="number">0</span>]</span><br><span class="line">    recommend_vector = pref_vec * rec_vector_scaled</span><br><span class="line">    product_idx = np.argsort(recommend_vector)[::<span class="number">-1</span>][:num_items]</span><br><span class="line">    rec_list = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> product_idx:</span><br><span class="line">        code = item_list[index]</span><br><span class="line">        rec_list.append([code, item_lookup.Description.loc[item_lookup.StockCode == code].iloc[<span class="number">0</span>]])</span><br><span class="line"></span><br><span class="line">    codes = [item[<span class="number">0</span>] <span class="keyword">for</span> item <span class="keyword">in</span> rec_list]</span><br><span class="line">    descriptions = [item[<span class="number">1</span>] <span class="keyword">for</span> item <span class="keyword">in</span> rec_list]</span><br><span class="line">    final_frame = pd.DataFrame(&#123;<span class="string">'StockCode'</span>: codes, <span class="string">'Description'</span>: descriptions&#125;)</span><br><span class="line">    <span class="keyword">return</span> final_frame[[<span class="string">'StockCode'</span>, <span class="string">'Description'</span>]]</span><br><span class="line"></span><br><span class="line">print(rec_items(<span class="number">12353</span>, product_train, user_vecs, item_vecs, customers_arr,products_arr, item_lookup, num_items=<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line">      StockCode       Description</span><br><span class="line"><span class="number">0</span><span class="number">23167</span>SMALL CERAMIC TOP STORAGE JAR</span><br><span class="line"><span class="number">1</span><span class="number">23165</span>LARGE CERAMIC TOP STORAGE JAR</span><br><span class="line"><span class="number">2</span><span class="number">22963</span>JAM JAR WITH GREEN LID</span><br><span class="line"><span class="number">3</span><span class="number">23294</span>SET OF <span class="number">6</span> SNACK LOAF BAKING CASES</span><br><span class="line"><span class="number">4</span><span class="number">22980</span>PANTRY SCRUBBING BRUSH</span><br><span class="line"><span class="number">5</span><span class="number">23296</span>SET OF <span class="number">6</span> TEA TIME BAKING CASES</span><br><span class="line"><span class="number">6</span><span class="number">23293</span>SET OF <span class="number">12</span> FAIRY CAKE BAKING CASES</span><br><span class="line"><span class="number">7</span><span class="number">22978</span>PANTRY ROLLING PIN</span><br><span class="line"><span class="number">8</span><span class="number">23295</span>SET OF <span class="number">12</span> MINI LOAF BAKING CASES</span><br><span class="line"><span class="number">9</span><span class="number">22962</span>JAM JAR WITH PINK LID</span><br></pre></td></tr></table></figure></p><p>从推荐结果中选取了前10个得分最高的物品，它们看起来和这个顾客购买的商品都比较相关，可解释性好，要知道推荐系统是完全不知道陶瓷罐代表什么含义的，而可解释性有时会让顾客更加信服得到的推荐结果。可以选另外的customer_id来继续验证。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>引申阅读：</p><ul><li>显式反馈推荐系统：</li></ul><ol><li><a href="http://bugra.github.io/work/notes/2014-04-19/alternating-least-squares-method-for-collaborative-filtering/" target="_blank" rel="noopener">Alternating Least Squares Method for Collaborative Filtering</a></li><li><a href="http://blog.ethanrosenthal.com/2016/01/09/explicit-matrix-factorization-sgd-als/" target="_blank" rel="noopener">Explicit Matrix Factorization: ALS, SGD, and All That Jazz</a></li></ol><ul><li>混合推荐系统(显式/隐式)</li></ul><ol><li><a href="https://github.com/lyst/lightfm" target="_blank" rel="noopener">LightFM</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用本文记录学习推荐系统的过程，以及一些实用的资料与资源。&lt;br&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://Bithub00.com/tags/python/"/>
    
      <category term="推荐系统" scheme="http://Bithub00.com/tags/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>宝贝陈列室</title>
    <link href="http://Bithub00.com/2019/07/25/%E5%AE%BF%E8%88%8D%E4%B8%80%E8%A7%92/"/>
    <id>http://Bithub00.com/2019/07/25/宿舍一角/</id>
    <published>2019-07-25T03:30:57.778Z</published>
    <updated>2019-07-25T03:40:57.406Z</updated>
    
    <content type="html"><![CDATA[<p><font size="3">展示一下自己收来的各种雕像和CD~</font><br><a id="more"></a></p><p><img src="https://s2.ax1x.com/2019/07/25/eZDA6x.jpg" alt="全览"></p><p><img src="https://s2.ax1x.com/2019/07/25/eZDk11.jpg" alt="致远星贵族小队"></p><p><img src="https://s2.ax1x.com/2019/07/25/eZDFpR.jpg" alt="不义联盟"></p><p><img src="https://s2.ax1x.com/2019/07/25/eZDEX6.jpg" alt="阿卡姆起源限定"></p><p><img src="https://s2.ax1x.com/2019/07/25/eZDPh9.jpg" alt="电视墙背景点亮"></p><p><img src="https://s2.ax1x.com/2019/07/25/eZDcHU.jpg" alt="全览"></p><p><img src="https://s2.ax1x.com/2019/07/25/eZDyuV.jpg" alt="自制老爷场景"></p><p><img src="https://s2.ax1x.com/2019/07/25/eZD2EF.jpg" alt="杰洛特"></p><p><img src="https://s2.ax1x.com/2019/07/25/eZD6BT.jpg" alt="老爷与丑爷"></p><p><img src="https://s2.ax1x.com/2019/07/25/eZDW4J.jpg" alt="雕像与CD"></p><p><img src="https://s2.ax1x.com/2019/07/25/eZDRN4.jpg" alt="正联星战与魔戒"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font size=&quot;3&quot;&gt;展示一下自己收来的各种雕像和CD~&lt;/font&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="宿舍" scheme="http://Bithub00.com/tags/%E5%AE%BF%E8%88%8D/"/>
    
  </entry>
  
  <entry>
    <title>Youtube爬虫</title>
    <link href="http://Bithub00.com/2019/07/25/Youtube%E7%88%AC%E8%99%AB/"/>
    <id>http://Bithub00.com/2019/07/25/Youtube爬虫/</id>
    <published>2019-07-25T02:31:32.337Z</published>
    <updated>2019-08-21T08:41:11.440Z</updated>
    
    <content type="html"><![CDATA[<h3 id="爬取相关频道Related-Channels"><a href="#爬取相关频道Related-Channels" class="headerlink" title="爬取相关频道Related Channels"></a>爬取相关频道Related Channels</h3><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="comment"># scrapy crawl related_channel_spider 命令行启动爬虫</span></span><br><span class="line"></span><br><span class="line">youtube_url = <span class="string">'https://www.youtube.com'</span></span><br><span class="line">kol = collections.OrderedDict()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RelatedChannelsSpider</span><span class="params">(scrapy.Spider)</span>:</span></span><br><span class="line">    name = <span class="string">'related_channel_spider'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close</span><span class="params">(spider, reason)</span>:</span></span><br><span class="line">        <span class="comment"># 爬虫结束后将爬取结果写入json文件</span></span><br><span class="line">        file_kol = open(<span class="string">'RelatedChannels_new.json'</span>, <span class="string">'a'</span>)</span><br><span class="line">        json.dump(kol, file_kol, sort_keys=<span class="keyword">True</span>, indent=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start_requests</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 爬虫数据来源:Youtube 频道链接</span></span><br><span class="line">        file_name = <span class="string">'kol_utm_campaign_ad.xlsx'</span></span><br><span class="line">        Channels = pd.read_excel(file_name, sheet_name=<span class="string">'ad_channel_new'</span>, header=<span class="number">0</span>, </span><br><span class="line">        usecols=[<span class="string">'Channel'</span>])</span><br><span class="line">        Titles = pd.read_excel(file_name, sheet_name=<span class="string">'ad_channel_new'</span>, header=<span class="number">0</span>, </span><br><span class="line">        usecols=[<span class="string">'KolName'</span>])</span><br><span class="line">        length = len(Channels)</span><br><span class="line">        start_urls = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, length):</span><br><span class="line">            url = &#123;&#125;</span><br><span class="line">            url[<span class="string">'url'</span>] = Channels[i:i + <span class="number">1</span>].values.item()</span><br><span class="line">            url[<span class="string">'title'</span>] = Titles[i:i + <span class="number">1</span>].values.item()</span><br><span class="line">            start_urls.append(url)</span><br><span class="line">        <span class="keyword">for</span> url <span class="keyword">in</span> start_urls:</span><br><span class="line">            request = scrapy.Request(url[<span class="string">'url'</span>], callback=self.parse)</span><br><span class="line">            request.meta[<span class="string">'title'</span>] = url[<span class="string">'title'</span>]</span><br><span class="line">            <span class="keyword">yield</span> request</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></span><br><span class="line">        related = collections.OrderedDict()</span><br><span class="line">        meta = response.meta</span><br><span class="line">        channel_title = meta[<span class="string">'title'</span>]</span><br><span class="line">        channel_url = response.url</span><br><span class="line">        <span class="keyword">yield</span> &#123;</span><br><span class="line">            <span class="string">'channel_title'</span>: channel_title,</span><br><span class="line">            <span class="string">'channel_url'</span>: channel_url</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment"># xpath解析网页</span></span><br><span class="line">        channel_item_lis = response.xpath(</span><br><span class="line">            <span class="string">'//li[contains(@class,</span></span><br><span class="line"><span class="string">            "branded-page-related-channels-item")]'</span></span><br><span class="line">            )</span><br><span class="line">        <span class="keyword">for</span> channel_item_li <span class="keyword">in</span> channel_item_lis:</span><br><span class="line">            related_channel_title = channel_item_li.xpath(</span><br><span class="line">                <span class="string">'span/div[contains(@class, </span></span><br><span class="line"><span class="string">                "yt-lockup-content")]/h3/a/text()'</span></span><br><span class="line">                ).extract()[<span class="number">0</span>]</span><br><span class="line">            relative_url = channel_item_li.xpath(</span><br><span class="line">                <span class="string">'span/div[contains(@class, </span></span><br><span class="line"><span class="string">                "yt-lockup-content")]/h3/a/@href'</span></span><br><span class="line">                ).extract()[<span class="number">0</span>]</span><br><span class="line">            related[related_channel_title] = youtube_url</span><br><span class="line">             + relative_url</span><br><span class="line">            print(related_channel_title, youtube_url</span><br><span class="line">             + relative_url)</span><br><span class="line">        <span class="keyword">if</span> related:</span><br><span class="line">            kol[channel_title] = related</span><br></pre></td></tr></table></figure><h3 id="爬取视频评论-包含评论内容、评论日期等"><a href="#爬取视频评论-包含评论内容、评论日期等" class="headerlink" title="爬取视频评论(包含评论内容、评论日期等)"></a>爬取视频评论(包含评论内容、评论日期等)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> lxml.html</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> lxml.cssselect <span class="keyword">import</span> CSSSelector</span><br><span class="line"></span><br><span class="line">YOUTUBE_COMMENTS_URL = </span><br><span class="line"><span class="string">'https://www.youtube.com/all_comments?v=&#123;youtube_id&#125;'</span></span><br><span class="line">YOUTUBE_COMMENTS_AJAX_URL = </span><br><span class="line"><span class="string">'https://www.youtube.com/comment_ajax'</span></span><br><span class="line">youtube_video_url = </span><br><span class="line"><span class="string">'https://www.youtube.com/watch?v='</span></span><br><span class="line"></span><br><span class="line">USER_AGENT = <span class="string">'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/48.0.2564.116 Safari/537.36'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_value</span><span class="params">(html, key, num_chars=<span class="number">2</span>)</span>:</span></span><br><span class="line">    pos_begin = html.find(key) + len(key) + num_chars</span><br><span class="line">    pos_end = html.find(<span class="string">'"'</span>, pos_begin)</span><br><span class="line">    <span class="keyword">return</span> html[pos_begin: pos_end]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract_comments</span><span class="params">(html)</span>:</span></span><br><span class="line">    tree = lxml.html.fromstring(html)</span><br><span class="line">    item_sel = CSSSelector(<span class="string">'.comment-item'</span>)</span><br><span class="line">    text_sel = CSSSelector(<span class="string">'.comment-text-content'</span>)</span><br><span class="line">    time_sel = CSSSelector(<span class="string">'.time'</span>)</span><br><span class="line">    author_sel = CSSSelector(<span class="string">'.user-name'</span>)</span><br><span class="line">    <span class="comment"># vote_sel = CSSSelector('.like-count') 是否爬取评论点赞数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> item_sel(tree):</span><br><span class="line">        <span class="keyword">yield</span> &#123;</span><br><span class="line">            <span class="string">'cid'</span>: item.get(<span class="string">'data-cid'</span>),</span><br><span class="line">            <span class="string">'text'</span>: text_sel(item)[<span class="number">0</span>].text_content(),</span><br><span class="line">            <span class="string">'time'</span>: time_sel(item)[<span class="number">0</span>].text_content().strip(),</span><br><span class="line">            <span class="string">'author'</span>: author_sel(item)[<span class="number">0</span>].text_content()</span><br><span class="line">          <span class="comment"># 'like-count': vote_sel(item)[0].text_content()</span></span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract_reply_cids</span><span class="params">(html)</span>:</span></span><br><span class="line">    tree = lxml.html.fromstring(html)</span><br><span class="line">    sel = CSSSelector(<span class="string">'.comment-replies-header &gt; .load-comments'</span>)</span><br><span class="line">    <span class="keyword">return</span> [i.get(<span class="string">'data-cid'</span>) <span class="keyword">for</span> i <span class="keyword">in</span> sel(tree)]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ajax_request</span><span class="params">(session, url, params, data, retries=<span class="number">10</span>, sleep=<span class="number">20</span>)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(retries):</span><br><span class="line">        response = session.post(url, params=params, data=data)</span><br><span class="line">        <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">            response_dict = json.loads(response.text)</span><br><span class="line">            <span class="keyword">return</span> response_dict.get(<span class="string">'page_token'</span>, <span class="keyword">None</span>),</span><br><span class="line">            response_dict[<span class="string">'html_content'</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            time.sleep(sleep)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_comments</span><span class="params">(youtube_id, sleep=<span class="number">1</span>)</span>:</span></span><br><span class="line">    session = requests.Session()</span><br><span class="line">    session.headers[<span class="string">'User-Agent'</span>] = USER_AGENT</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取初始页面的评论</span></span><br><span class="line">    response = session.get(YOUTUBE_COMMENTS_URL.format(youtube_id=youtube_id))</span><br><span class="line">    html = response.text</span><br><span class="line">    reply_cids = extract_reply_cids(html)</span><br><span class="line"></span><br><span class="line">    ret_cids = []</span><br><span class="line">    <span class="keyword">for</span> comment <span class="keyword">in</span> extract_comments(html):</span><br><span class="line">        ret_cids.append(comment[<span class="string">'cid'</span>])</span><br><span class="line">        <span class="keyword">yield</span> comment</span><br><span class="line"></span><br><span class="line">    page_token = find_value(html, <span class="string">'data-token'</span>)</span><br><span class="line">    session_token = find_value(html, <span class="string">'XSRF_TOKEN'</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    first_iteration = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取剩下的评论(等同于点击'show more')</span></span><br><span class="line">    <span class="keyword">while</span> page_token:</span><br><span class="line">        data = &#123;</span><br><span class="line">            <span class="string">'video_id'</span>: youtube_id,</span><br><span class="line">            <span class="string">'session_token'</span>: session_token</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        params = &#123;</span><br><span class="line">            <span class="string">'action_load_comments'</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="string">'order_by_time'</span>: <span class="keyword">True</span>,</span><br><span class="line">            <span class="string">'filter'</span>: youtube_id</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> first_iteration:</span><br><span class="line">            params[<span class="string">'order_menu'</span>] = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            data[<span class="string">'page_token'</span>] = page_token</span><br><span class="line"></span><br><span class="line">        response = ajax_request(session, YOUTUBE_COMMENTS_AJAX_URL, params, data)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> response:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        page_token, html = response</span><br><span class="line"></span><br><span class="line">        reply_cids += extract_reply_cids(html)</span><br><span class="line">        <span class="keyword">for</span> comment <span class="keyword">in</span> extract_comments(html):</span><br><span class="line">            <span class="keyword">if</span> comment[<span class="string">'cid'</span>] <span class="keyword">not</span> <span class="keyword">in</span> ret_cids:</span><br><span class="line">                ret_cids.append(comment[<span class="string">'cid'</span>])</span><br><span class="line">                <span class="keyword">yield</span> comment</span><br><span class="line"></span><br><span class="line">        first_iteration = <span class="keyword">False</span></span><br><span class="line">        time.sleep(sleep)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取评论回复</span></span><br><span class="line">    <span class="keyword">for</span> cid <span class="keyword">in</span> reply_cids:</span><br><span class="line">        data = &#123;<span class="string">'comment_id'</span>: cid,</span><br><span class="line">                <span class="string">'video_id'</span>: youtube_id,</span><br><span class="line">                <span class="string">'can_reply'</span>: <span class="number">1</span>,</span><br><span class="line">                <span class="string">'session_token'</span>: session_token&#125;</span><br><span class="line"></span><br><span class="line">        params = &#123;<span class="string">'action_load_replies'</span>: <span class="number">1</span>,</span><br><span class="line">                  <span class="string">'order_by_time'</span>: <span class="keyword">False</span>,</span><br><span class="line">                  <span class="string">'filter'</span>: youtube_id,</span><br><span class="line">                  <span class="string">'tab'</span>: <span class="string">'inbox'</span>&#125;</span><br><span class="line"></span><br><span class="line">        response = ajax_request(session, YOUTUBE_COMMENTS_AJAX_URL, params, data)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> response:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        _, html = response</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> comment <span class="keyword">in</span> extract_comments(html):</span><br><span class="line">            <span class="keyword">if</span> comment[<span class="string">'cid'</span>] <span class="keyword">not</span> <span class="keyword">in</span> ret_cids:</span><br><span class="line">                ret_cids.append(comment[<span class="string">'cid'</span>])</span><br><span class="line">                <span class="keyword">yield</span> comment</span><br><span class="line">        time.sleep(sleep)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span> <span class="comment"># 使用</span></span><br><span class="line">    <span class="keyword">for</span> comment <span class="keyword">in</span> download_comments(videoId):</span><br><span class="line">    ···</span><br></pre></td></tr></table></figure><h3 id="爬取某个视频主所有的视频"><a href="#爬取某个视频主所有的视频" class="headerlink" title="爬取某个视频主所有的视频"></a>爬取某个视频主所有的视频</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用Selenium</span></span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line">Channel_videos = <span class="string">'https://www.youtube.com/channel/UCGK0RMoHboOVUbdxDhLD1xw/videos'</span></span><br><span class="line">Video_Lists = []</span><br><span class="line">option = webdriver.ChromeOptions()</span><br><span class="line">option.add_argument(<span class="string">'headless'</span>)</span><br><span class="line">youtube_url = <span class="string">'https://www.youtube.com'</span></span><br><span class="line">browser = webdriver.Chrome(chrome_options=option, executable_path=<span class="string">'D:\Tool\Software\chromedriver_win32\\chromedriver.exe'</span>)</span><br><span class="line"><span class="comment"># 去掉option选项可以让chrome在前台显示，看看模拟的效果</span></span><br><span class="line">browser = webdriver.Chrome(executable_path=<span class="string">'D:\Tool\Software\chromedriver_win32\\chromedriver.exe'</span>)</span><br><span class="line">browser.get(Channel_videos)</span><br><span class="line">time.sleep(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">old_height = browser.execute_script(<span class="string">"return document.documentElement.scrollHeight;"</span>)</span><br><span class="line">browser.execute_script(<span class="string">"window.scrollTo(0, document.documentElement.scrollHeight);"</span>)</span><br><span class="line">time.sleep(<span class="number">5</span>)</span><br><span class="line">new_height = browser.execute_script(<span class="string">"return document.documentElement.scrollHeight;"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模拟浏览器向下滚动页面，直到所有视频都被加载出来</span></span><br><span class="line"><span class="keyword">while</span> new_height != old_height:</span><br><span class="line">    old_height = new_height</span><br><span class="line">    browser.execute_script(<span class="string">"window.scrollTo(0, document.documentElement.scrollHeight);"</span>)</span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">    new_height = browser.execute_script(<span class="string">"return document.documentElement.scrollHeight;"</span>)</span><br><span class="line"></span><br><span class="line">    html = browser.page_source</span><br><span class="line">    soup = BeautifulSoup(html, <span class="string">'lxml'</span>)</span><br><span class="line">    videoList = soup.findAll(<span class="string">"a"</span>, &#123;<span class="string">"class"</span>: <span class="string">"yt-simple-endpoint style-scope ytd-grid-video-renderer"</span>&#125;)</span><br><span class="line">    <span class="keyword">for</span> video <span class="keyword">in</span> videoList:</span><br><span class="line">        ···</span><br></pre></td></tr></table></figure><h3 id="获取视频的播放量和发布日期"><a href="#获取视频的播放量和发布日期" class="headerlink" title="获取视频的播放量和发布日期"></a>获取视频的播放量和发布日期</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 因为Youtube API每日有访问限制，超过它的配额后就无法再使用接口获取某个视频的播放量和发布日期了，使用爬虫就没有这种限制</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">youtube_video_url = <span class="string">'https://www.youtube.com/watch?v='</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">viewCount</span><span class="params">()</span>:</span></span><br><span class="line">        videoId = <span class="string">'P4ItC6jWN0s'</span></span><br><span class="line">        url = <span class="string">"https://www.youtube.com/watch"</span></span><br><span class="line">        querystring = &#123;<span class="string">"v"</span>: videoId&#125;</span><br><span class="line">        payload = <span class="string">""</span></span><br><span class="line">        headers = &#123;</span><br><span class="line">            <span class="string">'Content-Type'</span>: <span class="string">"application/json"</span>,</span><br><span class="line">            <span class="string">'User-Agent'</span>: <span class="string">"PostmanRuntime/7.15.0"</span>,</span><br><span class="line">            <span class="string">'Accept'</span>: <span class="string">"*/*"</span>,</span><br><span class="line">            <span class="string">'Cache-Control'</span>: <span class="string">"no-cache"</span>,</span><br><span class="line">            <span class="string">'Postman-Token'</span>: <span class="string">"296c1155-2adc-4028-95c2-26cffec91784,f5c8088f-432f-4a67-a815-13464bfca373"</span>,</span><br><span class="line">            <span class="string">'Host'</span>: <span class="string">"www.youtube.com"</span>,</span><br><span class="line">            <span class="string">'cookie'</span>: <span class="string">"YSC=nwR5fai12Kg; VISITOR_INFO1_LIVE=gAl5VFO7Gjo; PREF=f1=50000000; GPS=1"</span>,</span><br><span class="line">            <span class="string">'accept-encoding'</span>: <span class="string">"gzip, deflate"</span>,</span><br><span class="line">            <span class="string">'Connection'</span>: <span class="string">"keep-alive"</span>,</span><br><span class="line">            <span class="string">'cache-control'</span>: <span class="string">"no-cache"</span></span><br><span class="line">        &#125;</span><br><span class="line">        response = requests.request(<span class="string">"GET"</span>, url, data=payload, headers=headers, params=querystring)</span><br><span class="line">        html = etree.HTML(response.text)</span><br><span class="line">        datePublished = html.xpath(<span class="string">'//meta[@itemprop="datePublished"]/@content'</span>)</span><br><span class="line">        <span class="keyword">if</span> datePublished:</span><br><span class="line">            datePublished = datePublished[<span class="number">0</span>]</span><br><span class="line">            view_count = html.xpath(<span class="string">'//meta[@itemprop="interactionCount"]/@content'</span>)</span><br><span class="line">            <span class="keyword">if</span> view_count:</span><br><span class="line">                view_count = int(view_count[<span class="number">0</span>])</span><br><span class="line">                print(datePublished, view_count)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'Not Exist:'</span>,videoId)</span><br><span class="line"></span><br><span class="line">    file = open(<span class="string">'video_statstics.json'</span>, <span class="string">'a'</span>)</span><br><span class="line">    json.dump(video_statstics, file, indent=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    viewCount()</span><br></pre></td></tr></table></figure><h3 id="使用Selenium模拟搜索"><a href="#使用Selenium模拟搜索" class="headerlink" title="使用Selenium模拟搜索"></a>使用Selenium模拟搜索</h3><blockquote><p>避免Youtube API对/search接口的使用限制，根据官方文档，一个项目每日的配额是10000，而/search接口调用一次就至少是100</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span> WebDriverWait</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</span><br><span class="line">Campaign = campaign_phase(GA.loc[i, <span class="string">'Campaign'</span>])</span><br><span class="line">option = webdriver.ChromeOptions()</span><br><span class="line">option.add_argument(<span class="string">'headless'</span>)</span><br><span class="line">youtube_url = <span class="string">'https://www.youtube.com'</span></span><br><span class="line"><span class="comment"># 添加option后程序启动时就不会弹出chrome窗口，减少资源调用，提供效率，如果需要直观地观看程序的流程就用下面一行注释的不带option调用的命令</span></span><br><span class="line">browser = webdriver.Chrome(chrome_options=option,</span><br><span class="line">executable_path=<span class="string">'XXX\\chromedriver.exe'</span>)</span><br><span class="line"><span class="comment"># browser = webdriver.Chrome(executable_path='XXX\\chromedriver.exe') </span></span><br><span class="line">browser.get(<span class="string">'https://www.youtube.com/'</span>)</span><br><span class="line">wait = WebDriverWait(browser, <span class="number">10</span>)</span><br><span class="line">input = wait.until</span><br><span class="line">(</span><br><span class="line">    EC.presence_of_element_located</span><br><span class="line">    (</span><br><span class="line">        (By.ID, <span class="string">'search'</span>) <span class="comment">#这里一定要加一个括号，详情见另外一篇博客</span></span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><a href="http://www.bithub00.com/2019/08/21/TypeError/" target="_blank" rel="noopener">Selenium TypeError  <strong>init</strong>() takes 2 positional arguments but 3 were given_解决方案</a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">submit = wait.until</span><br><span class="line">(</span><br><span class="line">    EC.element_to_be_clickable</span><br><span class="line">    (</span><br><span class="line">        (By.ID, <span class="string">'search-icon-legacy'</span>)</span><br><span class="line">    )</span><br><span class="line">)</span><br><span class="line">input.send_keys(Campaign)</span><br><span class="line">submit.click()</span><br><span class="line"><span class="comment"># 到这里就完成了模拟youtube输入关键词搜索的过程，下面是获取搜索结果中与关键词最匹配的频道</span></span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">5</span>)</span><br><span class="line">html = browser.page_source</span><br><span class="line">soup = BeautifulSoup(html, <span class="string">'html.parser'</span>)</span><br><span class="line"></span><br><span class="line">searchResults = soup.findAll(<span class="string">"a"</span>, &#123;</span><br><span class="line">    <span class="string">"class"</span>: <span class="string">"yt-simple-endpoint style-scope ytd-channel-renderer"</span></span><br><span class="line">&#125;)</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line"><span class="keyword">if</span> searchResults:</span><br><span class="line">    <span class="keyword">for</span> result <span class="keyword">in</span> searchResults:</span><br><span class="line">        channel_url = youtube_url + result[<span class="string">'href'</span>]</span><br><span class="line">        title = result.find(<span class="string">"span"</span>, &#123;</span><br><span class="line">            <span class="string">"class"</span>: <span class="string">"style-scope ytd-channel-renderer"</span></span><br><span class="line">        &#125;)</span><br><span class="line">        channel_title = title.text</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;爬取相关频道Related-Channels&quot;&gt;&lt;a href=&quot;#爬取相关频道Related-Channels&quot; class=&quot;headerlink&quot; title=&quot;爬取相关频道Related Channels&quot;&gt;&lt;/a&gt;爬取相关频道Related Channels&lt;/h3&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://Bithub00.com/tags/python/"/>
    
      <category term="爬虫" scheme="http://Bithub00.com/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>python常用操作</title>
    <link href="http://Bithub00.com/2019/07/25/python%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
    <id>http://Bithub00.com/2019/07/25/python常用操作/</id>
    <published>2019-07-25T02:13:08.319Z</published>
    <updated>2019-08-22T11:17:38.180Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>读取excel文件某一列</p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">names = pd.read_excel(</span><br><span class="line">    <span class="string">'NOT_EXIST_List.xlsx'</span>,</span><br><span class="line">    sheet_name=<span class="string">'NOT EXIST'</span>, </span><br><span class="line">    header=<span class="number">0</span>, </span><br><span class="line">    usecols=[<span class="string">'KolName'</span>])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(names)):</span><br><span class="line">    name = names[i:i + <span class="number">1</span>].values.item()</span><br></pre></td></tr></table></figure></li><li><p>List去重</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">List = pd.unique(List).tolist()</span><br></pre></td></tr></table></figure></li><li><p>将接口返回值解析成json格式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> request</span><br><span class="line">response = requests.request(</span><br><span class="line">    <span class="string">"GET"</span>, url,</span><br><span class="line">    data=payload, </span><br><span class="line">    headers=headers,</span><br><span class="line">    params=querystring)</span><br><span class="line">json_response = json.loads(response.text)</span><br></pre></td></tr></table></figure></li><li><p>移除字符串中的标点符号</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removePunctuation</span><span class="params">(text)</span>:</span></span><br><span class="line">    str = <span class="string">''</span>.join(c <span class="keyword">for</span> c <span class="keyword">in</span> text <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> string.punctuation)</span><br><span class="line">    <span class="keyword">return</span> str</span><br></pre></td></tr></table></figure></li><li><p>读取和写入json文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">file = open(<span class="string">'XXX.json'</span>, <span class="string">'r'</span>)</span><br><span class="line">XXX = json.loads(file.read())</span><br><span class="line">file = open(<span class="string">'XXX.json'</span>, <span class="string">'a'</span>)</span><br><span class="line">json.dump(XXX, file, indent=<span class="number">2</span>)</span><br></pre></td></tr></table></figure></li><li><p>将List写入excel文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">df = pd.DataFrame(List, columns=[<span class="string">'name'</span>, <span class="string">'url'</span>])</span><br><span class="line">writer = pd.ExcelWriter(<span class="string">'remain.xlsx'</span>)</span><br><span class="line">df.to_excel(writer, <span class="string">'remain'</span>)</span><br><span class="line">writer.save()</span><br></pre></td></tr></table></figure></li><li><p>dict根据key排序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sortdict</span><span class="params">(data)</span>:</span></span><br><span class="line">    result = collections.OrderedDict()</span><br><span class="line">    dict = sorted(data.items(), key=<span class="keyword">lambda</span> d: d[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(dict)):</span><br><span class="line">        result[dict[i][<span class="number">0</span>]] = dict[i][<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></li><li><p>以追加方式写入excel</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">rexcel = open_workbook(<span class="string">"ad_match_new.xls"</span>)</span><br><span class="line">rows = rexcel.sheets()[<span class="number">0</span>].nrows</span><br><span class="line">excel = copy(rexcel)</span><br><span class="line">table = excel.get_sheet(<span class="number">0</span>)</span><br><span class="line">row = rows</span><br><span class="line">table.write(row, <span class="number">0</span>, title)</span><br><span class="line">table.write(row, <span class="number">1</span>, channel)</span><br><span class="line">table.write(row, <span class="number">2</span>, video_url)</span><br><span class="line">table.write(row, <span class="number">3</span>, url)</span><br><span class="line">row += <span class="number">1</span></span><br><span class="line">excel.save(<span class="string">"ad_match_new.xls"</span>)</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>好处是在爬取数据或者使用接口时可以动态保存数据，不需要全部爬取完后再一次性存储，避免中途出错导致前功尽弃</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;读取excel文件某一列&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://Bithub00.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>imputing structured missing values in spatial data with clsutered adversarial matrix factorization</title>
    <link href="http://Bithub00.com/2019/04/12/imputing%20structured%20missing%20values%20in%20spatial%20data%20with%20clsutered%20adversarial%20matrix%20factorization/"/>
    <id>http://Bithub00.com/2019/04/12/imputing structured missing values in spatial data with clsutered adversarial matrix factorization/</id>
    <published>2019-04-12T15:55:11.077Z</published>
    <updated>2019-08-07T07:59:01.419Z</updated>
    
    <content type="html"><![CDATA[<font size="5">一种基于对抗模型用于补全带有结构性缺失信息的空间数据的矩阵分解技术</font><a id="more"></a><p>&#8194; </p><font size="3">摘要：在数据分析时，缺失的数据总是会成为一个重大的挑战，因为它带来了不确定性。在许多领域中，矩阵补全技术有着出色的表现。然而，在特定的空间数据集如地理坐标点时，这种传统的矩阵补全技术有着两个主要的限制：第一，这些方法往往假设缺失的数据是随机产生的，而这种假设对于空间数据集可能并不总是成立；第二，它们可能无法运用这些空间数据集中的结构信息。为了解决这些局限性，本论文提出了一种利用先验结构信息和生成对抗模型的矩阵分解技术。这个模型使用一个对抗网络通过学习数据集的概率分布来改善补全的结果。</font><font size="3">关键词：缺失数据估计；深度对抗网络；空间数据</font><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&#8194; 很多现实生活中的应用容易面临数据缺失的问题。而对于空间数据集，造成这种情况的原因有很多种。例如，在森林监测中，因为收集成本的原因，数据的缺失很普遍。【3】过去十年许多针对数据补全的工作在开展，从基本的统计方法到复杂的模型使用。后者的典例低秩矩阵补全技术为许多领域如推荐系统或图像重构带来了可观的改善【9】。这些方法通过发现并利用数据矩阵的低秩属性来建立已有值与缺失值的联系。而在这些矩阵补全方法里，矩阵分解是最为常用的方法之一，它将输入的数据矩阵分解成两个低秩矩阵的乘积，称为“特征因子”，接着通过最小化这个乘积与已有值的误差来学习这两个特征因子，随后利用它们来补全缺失的信息。【18】其它方法还有如带门槛的矩阵奇异值分解，核心思想是迭代地使用截断奇异值分解来补全。</p><p>&#8194; 这些矩阵补全的方法，往往假设缺失的数据是随机产生的。【2】然而，这个假设在空间数据上可能并不成立，因为它往往带有空间结构。例如，一项针对加拿大青少年的研究指出，家庭收入这一栏数据空缺的青少年有更低的可能性居住在富人区。【15】因此，当数据并不是随机缺失时，只是单纯地最小化两个特征因子的乘积与已有值的误差并不能保证补全数据的有效性。</p><p>&#8194; 而另一个限制则是这些方法无法把数据集里的结构信息利用起来。而在补全缺失的空间数据时，这些结构信息格外重要。【12】例如，淡水湖数据就有强烈的空间结构，因为相邻的湖泊往往有相似的降水量等。【17】如果这些结构信息能够被一个矩阵补全的方法利用起来，它可以显著地提升结果，因为这些结构信息代表了一个子空间，在这个子空间里，不同湖泊之间相似的信息互相传递。</p><p>&#8194; 因为为了解决这两点局限，我们提出了一种利用先验结构信息和生成对抗模型的矩阵分解技术。这个框架找到一个低维的子空间来与数据中的结构信息相符合，因此可以利用同一类中其它数据点的信息来补全某一点的缺失值。而且，估计值的概率分布也尽可能的与已有值相似，这么做的好处是它把缺失值与已有值连接起来了。如果估计值与实际值偏差太大，那么它出现的概率应该很小。然而，实际数据的概率分布往往是未知的，因此我们借鉴了生成对抗网络的思想引入了一个判别器来区分估计值与已有值。我们在合成数据集与显示数据集上均做了实验，来说明这个框架的有效性。</p><h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><p>&#8194; 截断奇异值算法是近年来使用频率较高的一个方法，它在数据矩阵中迭代的使用截断奇异值分解接着通过保持一个较小的奇异值重构整个矩阵。矩阵分解是另一项常用的技术，关于它的过程前面部分已有讲述。</p><p>&#8194; 生成对抗网络（GAN）被广泛地用于生成图像【5】【16】。在【8】【14】中，作者提出了一个想法，利用GAN的思想和整幅图片的结构来推测一幅图片中随机缺失的像素。虽然这个想法在这类问题上效果较好，但它补全图片时是将每张图片看成一个个独立的个体，而空间数据与此相反，它们之间有着强烈的依赖性。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="A-矩阵分解引入"><a href="#A-矩阵分解引入" class="headerlink" title="A.矩阵分解引入"></a>A.矩阵分解引入</h3><p>&#8194; 矩阵分解在推荐系统中十分常用，例如如下的一个评分矩阵，列为用户，行为物品，矩阵中的值为用户对物品的评分，如电影和书籍。现实情况中这个评分矩阵往往很稀疏，许多物品上缺少用户的评分，而推荐系统就是要预估用户在某个物品上的评分来判断用户对它的倾向程度，从而进行推荐。</p><p><img src="https://s2.ax1x.com/2019/04/13/AqRtk4.png" alt=""></p><p>&#8194; 矩阵分解的方法是将原始评分矩阵$R^{m\times n}$分解成两个矩阵$P^{m\times k}$和$Q^{k\times n}$，根据评分矩阵中已有的值来判断分解是否准确，而判别标准常用均方差。如图所示。</p><p><img src="https://s2.ax1x.com/2019/04/13/AqRJ7F.png" alt=""></p><p>&#8194; 分解后的矩阵P和Q可以称为特征因子（latent factor），其中要求分解后$k&lt;&lt;min(m,n)$，即低秩要求，因为如果输入矩阵满秩，则各元素行之间线性无关，如果有线性相关关系，则某个元素行可以通过其他行的线性组合表示，相当于引入了冗余的信息，这样就可以将矩阵投影到更低维的空间，只保留非冗余信息，同时冗余信息可以用来对缺失值进行补全。</p><p>&#8194; 矩阵分解的直观意义为，找出矩阵中的潜在特征，如图2中假设特征为3，特征可以是书籍作者、类型等等，而矩阵P表示用户对某个特征的喜爱程度，而矩阵Q表示某个物品与该特征的关联程度。</p><h3 id="B-低秩补全"><a href="#B-低秩补全" class="headerlink" title="B.低秩补全"></a>B.低秩补全</h3><p>&#8194; 给定一个带有缺失值的矩阵，矩阵补全技术旨在通过已有值的某种潜在的结构来对缺失值进行估计补全。一个常用的潜在结构是矩阵的低秩性，因为它可以将该矩阵投影到一个去除冗余信息的子空间中，低秩意味着矩阵中的值存在线性关系，因此某些值可以通过另外的值来线性表示，如同坐标系中的基底一样。在这类方法中有凸也有非凸的技术。凸方法通过对矩阵迹的约束来保证具有良好理论性的全局最优结果，而诸如矩阵分解的非凸方法进行局部搜索过程并提供更大的灵活性和效率。给定一个矩阵$X\in R^{d\times n}$，n代表样本个数，d代表特征维度，矩阵分解技术通过将X分解为两个矩阵U和V，$U\in R^{d\times n}$，$V\in R^{r\times n}$要求$r &lt; min(d, n)$；U和V的求解可以通过对下列式子运用块坐标下降法求得：</p><p><img src="https://s2.ax1x.com/2019/04/13/AqRG0U.png" alt=""></p><p>&#8194; $\bigodot$代表哈德蒙德内积（即矩阵各元素相乘），M矩阵的大小同X一致，如果$X_{ij}$有值则$M_{ij}$为1，否则为0。局部解用$U^<em>、V^</em>$表示，因此，它们可以通过如下的式子来重构矩阵X：</p><p><img src="https://s2.ax1x.com/2019/04/13/AqR8mT.png" alt=""></p><p>&#8194; 矩阵分解在推荐系统中使用较为普遍，它用来估计一个用户在某项新物品上的评分。</p><p>&#8194; 将此方法应用于空间数据集时，矩阵分解不会包含有关数据集中空间聚类结构的先验知识信息。 然而，这些先验知识通常有助于发现需要的子空间。此外，对于结构化缺失值问题，经典矩阵补全提供较差的结果，因为缺失值不是随机的。</p><h3 id="C-聚类对抗式矩阵分解"><a href="#C-聚类对抗式矩阵分解" class="headerlink" title="C.聚类对抗式矩阵分解"></a>C.聚类对抗式矩阵分解</h3><p>&#8194; 为了解决上一小节中提到的矩阵分解的两个局限性，我们提出了一种新的聚类对抗矩阵分解框架。 在我们的框架中，我们找到整个样本的聚类信息，并将补全值的概率分布与已有值的分布靠近，以得到可靠的补全结果。X为输入矩阵，每一列代表一个数据样本，有些数据点有完整的特征信息，而某些数据点以结构性缺失了某些特征信息。我们将输入矩阵中完整部分记为$X_n$，而缺失部分记为$X_m$。我们假设每个数据点都符合某个概率分布$p_{data(x)}$。接下来的公式中包含两个部分：矩阵重构以及概率分布近似。</p><h4 id="矩阵重构"><a href="#矩阵重构" class="headerlink" title="矩阵重构"></a>矩阵重构</h4><p>&#8194; 为了利用数据的低秩属性和空间聚类结构，我们决定在矩阵分解中使用l2聚类项：</p><p><img src="https://s2.ax1x.com/2019/04/17/AzcSM9.png" alt=""></p><p>&#8194; 式中$v_i$代表矩阵V中第i列，$r_1,r_2,r_3$均为正则化参数，第二项和第三项加的约束是为了防止过拟合，最后一项则用来引入空间数据集中的聚类结构信息。$d_{ij}$是第i个样本和第j个样本的相似度，它可以手动设置，原则为：当$v_i$和$v_j$很靠近即在同一类时，将$d_{ij}$的值设置得较大，反之较小。$r_3$用来调整结构信息在重构时所占的比重，如果$r_3$较大，则对一个样本的缺失数据进行估计补全时会更多的参考同一类其它数据点的信息。因此当$r_3$为0时，结构信息将不被使用，这也使得这个式子变成了常规的矩阵分解方法。而对于UV矩阵直观的理解为，U为特征因子，而V为样本因子，如同推荐系统里的用户因子和物品因子，两者相互独立。</p><h4 id="生成对抗网络思想（GAN）"><a href="#生成对抗网络思想（GAN）" class="headerlink" title="生成对抗网络思想（GAN）"></a>生成对抗网络思想（GAN）</h4><p>&#8194; 在继续讲到使用概率分布近似来优化前，先引入生成对抗网络的基本思想加深理解。GAN的非常的直观，就是生成器和判别器两个极大极小的博弈。</p><p><img src="https://s2.ax1x.com/2019/04/17/AzcULn.png" alt=""></p><p>GAN的目标函数为：</p><p><img src="https://s2.ax1x.com/2019/04/17/AzctMj.png" alt=""></p><p>&#8194; 从判别器D的角度看，它希望自己能尽可能区分真实样本和虚假样本，因此希望 D(x)尽可能大，D(G(z))尽可能小，即 V(D,G)尽可能大。从生成器G的角度看，它希望自己尽可能骗过D，也就是希望 D(G(z))尽可能大，即 V(D,G)V(D,G) 尽可能小。两个模型相对抗，最后达到全局最优。</p><p><img src="https://s2.ax1x.com/2019/04/17/AzcNss.png" alt=""></p><p>&#8194; 图中，黑色曲线是真实样本的概率分布函数，绿色曲线是虚假样本的概率分布函数，蓝色曲线是判别器D的输出，它的值越大表示这个样本越有可能是真实样本。最下方的平行线是噪声z，它映射到了x。</p><p>&#8194; 一开始， 虽然 G(z)和x是在同一个特征空间里的，但它们分布的差异很大，这时，虽然鉴别真实样本和虚假样本的模型 D性能也不强，但它很容易就能把两者区分开来，而随着训练的推进，虚假样本的分布逐渐与真实样本重合，D虽然也在不断更新，但也已经力不从心了。</p><p>&#8194; 最后，黑线和绿线最后几乎重合，模型达到了最优状态，这时 判别器的输出对于任意样本都是 0.5。</p><h4 id="GAN的最优化"><a href="#GAN的最优化" class="headerlink" title="GAN的最优化"></a>GAN的最优化</h4><p>&#8194; 在建立好理论框架后，需要对所需要的生成器G和判别器D进行优化，在此之前先引入交叉熵的概念：它一般用来求目标与预测值之间的差距。</p><p>&#8194; 在信息论与编码中，熵可以用来衡量信息量的多少，而如果我们对于同一个随机变量 x 有两个单独的概率分布 P(x) 和 Q(x)，我们可以使用 KL 散度来衡量这两个分布的差异，计算式如下：</p><p><img src="https://s2.ax1x.com/2019/04/17/Azcho6.png" alt=""></p><p>&#8194; 在机器学习中，P往往用来表示样本的真实分布，比如[1,0,0]表示当前样本属于第一类。Q用来表示模型所预测的分布，比如[0.7,0.2,0.1]，直观的理解就是如果用P来描述样本，那么就非常完美。而用Q来描述样本，虽然可以大致描述，但并不是那么的完美，信息量不足，需要额外的一些“信息增量”才能达到和P一样完美的描述。如果我们的Q通过反复训练，也能完美的描述样本，那么就不再需要额外的“信息增量”，此时Q就等价于P。</p><p>而对KL散度的计算式进行变形，可以得到：</p><p><img src="https://s2.ax1x.com/2019/04/17/AzcIJO.png" alt=""></p><p>等式的前一项即为P的熵，而后一项就是交叉熵的计算式：</p><p><img src="https://s2.ax1x.com/2019/04/17/Azc5FK.png" alt=""></p><p>&#8194; 在机器学习中，我们需要评估labels和predictions之间的差距，可以使用KL散度，即$D_{KL}(y\mid\mid\hat{y})$，由于KL散度中的前一部分−H(y)即P的熵不变，故在优化过程中，只需要关注交叉熵就可以了。所以一般在机器学习中直接用用交叉熵做损失函数，评估模型。</p><p>&#8194; 在引入交叉熵后，就可以定义最优化表达式。首先我们需要定义一个判别器 D以判别样本是不是从$p_{data(x)}$分布中取出来的，因此有:</p><p><img src="https://s2.ax1x.com/2019/04/17/Azg6tf.png" alt=""></p><p>&#8194; 其中E代表取期望。这一项是根据「正类」（即辨别出 x 属于真实数据data）的对数损失函数而构建的。最大化这一项相当于令判别器 D在 x 服从于 data 的概率密度时能准确地预测 D(x)=1，即：</p><p><img src="https://s2.ax1x.com/2019/04/17/Azgch8.png" alt=""></p><p>另外一项是企图欺骗判别器的生成器 G。该项根据「负类」的对数损失函数而构建，即</p><p><img src="https://s2.ax1x.com/2019/04/17/AzgyAP.png" alt=""></p><p>因此目标函数为：</p><p><img src="https://s2.ax1x.com/2019/04/17/Azg29S.png" alt=""></p><p>它的含义是，对于D而言要尽量使公式最大化（识别能力强），而对于G又想使它最小（生成的数据接近实际数据）。整个训练是一个迭代过程。极小极大化博弈可以分开理解，即在给定G的情况下先最大化$V(D,G)$而来得到D，然后固定D，并最小化$V(D,G)$而得到G。其中，给定 G，最大化$V(D,G)$评估了$P_g$和$P_{data}$之间的差异或距离。</p><h4 id="概率分布近似"><a href="#概率分布近似" class="headerlink" title="概率分布近似"></a>概率分布近似</h4><p>&#8194; 接下来，论文中就使用生成对抗网络中的对抗策略来使得推算样本具有与完整数据类似的概率分布。为了实现这一目标，我们使用鉴别器来区分推算和完整样本之间的分布差异：</p><p><img src="https://s2.ax1x.com/2019/04/17/Az29N6.png" alt=""></p><p>&#8194; 其中$p_r(x_r)$代表估计值的概率分布，它将从补全的矩阵Xr中得到；$x_r$代表从$p_r(x_r)$中选取的一个数据点；D为一个鉴别器，我们通过一个以SOFTMAX为输出层的全连接的深度神经网络来实现。D将输出一个概率值，判断输入的数据为已有值还是估计值。我们使用了负交叉熵作为损失函数，通过最大化$l_d$得到一个鉴别器D，能够有效地区分已有值与估计值</p><h4 id="完整公式"><a href="#完整公式" class="headerlink" title="完整公式"></a>完整公式</h4><p>将前节提到的两个部分进行合并，我们得到了如下的公式：</p><p><img src="https://s2.ax1x.com/2019/04/17/Azgvu9.png" alt=""></p><p>&#8194; 其中λ是用来平衡矩阵重构与概率分布近似所占比例的一个参数，因此最小化该式时，不仅使得重构的矩阵与已有值所构成的矩阵的误差尽可能得小，同时通过鉴别器使得这两者的概率分布尽可能相似。这个同时最大最小化的要求就像是进行一场对抗。一方面，鉴别器尽可能地区别重构样本与已有样本的概率分布，而另一方面，重构矩阵又尽可能地逼近已有值的概率分布，以骗过鉴别器。因此当算法收敛时，重构矩阵的概率分布将会近似于已有值，训练出一个有效的鉴别器，同时重构矩阵的值也足够接近实际值以至于可以骗过这个鉴别器。在最小化部分中，我们求解出使得误差最小的矩阵U和V，接着使用它们来进行缺失值的计算。同时，这个部分也尽可能地让估计值去骗过鉴别器。而在最大化部分中，鉴别器通过区分已有值与最小化部分所得的估计值来进行更新，整个框架的流程如图所示。</p><p><img src="https://s2.ax1x.com/2019/04/17/Az2pAx.png" alt=""></p><h4 id="最优化"><a href="#最优化" class="headerlink" title="最优化"></a>最优化</h4><p>然而在实际情况中，输入样本的概率分布往往是未知的，因此，我们使用如下式子来进行近似：在每次的更新迭代中，我们随机从Xn与Xr选取k个样本，来计算概率分布：</p><p><img src="https://s2.ax1x.com/2019/04/17/AzgzH1.png" alt=""><br><img src="https://s2.ax1x.com/2019/04/17/AzgxBR.png" alt=""></p><p>&#8194; 其中r1与rk分别代表从Xn中选取的k个样本中的第一个和最后一个，q1和qk从Xr中选取的k个样本中的第一个和最后一个，$X^i_n$和$X^i_r$分别代表从Xn与Xr中所选取的第i个样本。因此，上面的合成式将变成：</p><p><img src="https://s2.ax1x.com/2019/04/17/Az2l8S.png" alt=""></p><p>算法流程如下所示：</p><p><img src="https://s2.ax1x.com/2019/04/17/Az2QC8.png" alt=""></p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2>]]></content>
    
    <summary type="html">
    
      &lt;font size=&quot;5&quot;&gt;
一种基于对抗模型用于补全带有结构性缺失信息的空间数据的矩阵分解技术
&lt;/font&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://Bithub00.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="GAN" scheme="http://Bithub00.com/tags/GAN/"/>
    
      <category term="矩阵分解" scheme="http://Bithub00.com/tags/%E7%9F%A9%E9%98%B5%E5%88%86%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>数据库设计</title>
    <link href="http://Bithub00.com/2019/04/10/database/"/>
    <id>http://Bithub00.com/2019/04/10/database/</id>
    <published>2019-04-10T08:50:19.836Z</published>
    <updated>2019-04-10T08:52:10.289Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h2><ul><li>以下所有表默认自带一个自增 <code>id</code></li><li>以下所有表默认自带 <code>created_at</code> 和 <code>updated_at</code> 两个字段</li><li>为了方便查询，以下所有下划线命名法在实际设计中可能全部转为驼峰命名法<a id="more"></a></li></ul><h3 id="用户信息"><a href="#用户信息" class="headerlink" title="用户信息"></a>用户信息</h3><h4 id="manager"><a href="#manager" class="headerlink" title="manager"></a>manager</h4><div class="table-container"><table><thead><tr><th>字段</th><th>类型</th><th>描述</th><th>约束</th></tr></thead><tbody><tr><td>name</td><td>varchar</td><td>姓名</td><td>not null</td></tr><tr><td>card_id</td><td>varchar</td><td>校园卡号</td><td>not null</td></tr><tr><td>authorizerId</td><td>int</td><td>授权人 id</td><td>外键，引用自 manager 表的 id 属性</td></tr><tr><td>privilege</td><td>tinyint</td><td>0 为超级管理员，1为普通管理员，其余待定</td><td>not null</td></tr></tbody></table></div><h4 id="student"><a href="#student" class="headerlink" title="student"></a>student</h4><div class="table-container"><table><thead><tr><th>字段</th><th>类型</th><th>描述</th><th>约束</th></tr></thead><tbody><tr><td>card_id</td><td>varchar</td><td>校园卡号</td><td>无</td></tr><tr><td>stu_id</td><td>varchar</td><td>学号</td><td>primary key</td></tr><tr><td>name</td><td>varchar</td><td>姓名</td><td>not null</td></tr><tr><td>college</td><td>varchar</td><td>学院</td><td>无</td></tr></tbody></table></div><h4 id="teacher"><a href="#teacher" class="headerlink" title="teacher"></a>teacher</h4><div class="table-container"><table><thead><tr><th>字段</th><th>类型</th><th>描述</th><th>约束</th></tr></thead><tbody><tr><td>name</td><td>varchar</td><td>讲师名称</td><td>not null</td></tr><tr><td>college</td><td>varchar</td><td>所属单位</td><td>not null</td></tr><tr><td>intro</td><td>text</td><td>老师简介</td><td>无</td></tr><tr><td>phone</td><td>varchar</td><td>手机号码</td><td>无</td></tr><tr><td>office</td><td>varchar</td><td>办公地址</td><td>无</td></tr><tr><td>email</td><td>varchar</td><td>邮箱</td><td>无</td></tr><tr><td>image_url</td><td>varchar</td><td>导师照片 url</td><td>无</td></tr><tr><td>teach_form</td><td>varchar</td><td>授课形式</td><td>无</td></tr></tbody></table></div><h4 id="teach-topic"><a href="#teach-topic" class="headerlink" title="teach_topic"></a>teach_topic</h4><div class="table-container"><table><thead><tr><th>字段</th><th>类型</th><th>描述</th><th>约束</th></tr></thead><tbody><tr><td>teacher_id</td><td>int</td><td>讲师 id</td><td>外键，引用自 teacher 表的 id 属性</td></tr><tr><td>topic</td><td>varchar</td><td>授课专题</td><td>not null</td></tr></tbody></table></div><h3 id="课程信息"><a href="#课程信息" class="headerlink" title="课程信息"></a>课程信息</h3><h4 id="course"><a href="#course" class="headerlink" title="course"></a>course</h4><div class="table-container"><table><thead><tr><th>字段</th><th>类型</th><th>描述</th><th>约束</th></tr></thead><tbody><tr><td>course_name</td><td>varchar</td><td>课程名称</td><td>not null</td></tr><tr><td>teacher_id</td><td>int</td><td>讲师 id</td><td>外键，引用自 teacher 表的 id 属性</td></tr><tr><td>start_time</td><td>datetime</td><td>上课开始时间</td><td>not null</td></tr><tr><td>end_time</td><td>datetime</td><td>上课结束时间</td><td>not null</td></tr><tr><td>course_id</td><td>varchar</td><td>课程编号</td><td>primary key</td></tr><tr><td>location</td><td>varchar</td><td>上课地址</td><td>not null</td></tr></tbody></table></div><h4 id="course-student"><a href="#course-student" class="headerlink" title="course_student"></a>course_student</h4><div class="table-container"><table><thead><tr><th>字段</th><th>类型</th><th>描述</th><th>约束</th></tr></thead><tbody><tr><td>course_id</td><td>varchar</td><td>课程编号</td><td>外键，引用自 course 表的 course_id 属性</td></tr><tr><td>stu_id</td><td>varchar</td><td>学生学号</td><td>外键，引用自 student 表的 stu_id 属性</td></tr></tbody></table></div><h3 id="评价模板"><a href="#评价模板" class="headerlink" title="评价模板"></a>评价模板</h3><h4 id="comment-template"><a href="#comment-template" class="headerlink" title="comment_template"></a>comment_template</h4><div class="table-container"><table><thead><tr><th>字段</th><th>类型</th><th>描述</th><th>约束</th></tr></thead><tbody><tr><td>template_name</td><td>varchar</td><td>模板名称</td><td>not null</td></tr></tbody></table></div><h4 id="template-question"><a href="#template-question" class="headerlink" title="template_question"></a>template_question</h4><div class="table-container"><table><thead><tr><th>字段</th><th>类型</th><th>描述</th><th>约束</th></tr></thead><tbody><tr><td>template_id</td><td>int</td><td>模板 id</td><td>外键，引用自 comment_template 表的 id 属性</td></tr><tr><td>question</td><td>text</td><td>问题</td><td>not null</td></tr><tr><td>_type</td><td>tinyint</td><td>问题类型，0为打分题，1为问答题，其余待定</td><td>not null</td></tr></tbody></table></div><h3 id="评价信息"><a href="#评价信息" class="headerlink" title="评价信息"></a>评价信息</h3><h4 id="course-comment"><a href="#course-comment" class="headerlink" title="course_comment"></a>course_comment</h4><div class="table-container"><table><thead><tr><th>字段</th><th>类型</th><th>描述</th><th>约束</th></tr></thead><tbody><tr><td>course_id</td><td>varchar</td><td>课程编号</td><td>外键，引用自 course 表的 course_id 属性</td></tr><tr><td>template_id</td><td>int</td><td>模板 id</td><td>外键，引用自 comment_template 表的 id 属性</td></tr></tbody></table></div><h4 id="comment"><a href="#comment" class="headerlink" title="comment"></a>comment</h4><div class="table-container"><table><thead><tr><th>字段</th><th>类型</th><th>描述</th><th>约束</th></tr></thead><tbody><tr><td>course_id</td><td>varchar</td><td>课程编号</td><td>外键，引用自 course 表的 course_id 属性</td></tr><tr><td>stu_id</td><td>varchar</td><td>学生学号</td><td>外键，引用自 student 表的 stu_id 属性</td></tr><tr><td>star</td><td>tinyint</td><td>1为精选评论</td><td>无</td></tr></tbody></table></div><h4 id="comment-result"><a href="#comment-result" class="headerlink" title="comment_result"></a>comment_result</h4><div class="table-container"><table><thead><tr><th>字段</th><th>类型</th><th>描述</th><th>约束</th></tr></thead><tbody><tr><td>comment_id</td><td>int</td><td>评价 id</td><td>外键，引用自 comment 表的 id 属性</td></tr><tr><td>question_id</td><td>int</td><td>问题 id</td><td>外键，引用自 template_question 表的 id 属性</td></tr><tr><td>result</td><td>text</td><td>问题结果，根据问题类型来决定存储值类型</td><td>not null</td></tr></tbody></table></div>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;数据库设计&quot;&gt;&lt;a href=&quot;#数据库设计&quot; class=&quot;headerlink&quot; title=&quot;数据库设计&quot;&gt;&lt;/a&gt;数据库设计&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;以下所有表默认自带一个自增 &lt;code&gt;id&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;以下所有表默认自带 &lt;code&gt;created_at&lt;/code&gt; 和 &lt;code&gt;updated_at&lt;/code&gt; 两个字段&lt;/li&gt;
&lt;li&gt;为了方便查询，以下所有下划线命名法在实际设计中可能全部转为驼峰命名法
    
    </summary>
    
    
      <category term="数据库" scheme="http://Bithub00.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>API接口设计</title>
    <link href="http://Bithub00.com/2019/04/10/api/"/>
    <id>http://Bithub00.com/2019/04/10/api/</id>
    <published>2019-04-10T08:50:19.820Z</published>
    <updated>2019-04-10T08:52:14.750Z</updated>
    
    <content type="html"><![CDATA[<h2 id="API-接口设计"><a href="#API-接口设计" class="headerlink" title="API 接口设计"></a>API 接口设计</h2><h3 id="接口地址"><a href="#接口地址" class="headerlink" title="接口地址"></a>接口地址</h3><div class="table-container"><table><thead><tr><th style="text-align:center">环境</th><th style="text-align:center">URL</th></tr></thead><tbody><tr><td style="text-align:center">开发环境</td><td style="text-align:center"><code>http://like.suevily.cn/</code></td></tr><tr><td style="text-align:center">生产环境</td><td style="text-align:center">待定</td></tr></tbody></table></div><h3 id="通用"><a href="#通用" class="headerlink" title="通用"></a>通用</h3><ol><li>以下接口分为开放接口和私有接口<ul><li>开放接口：无需登录校验即可请求</li><li>私有接口：需校验登录 token 方可请求</li></ul></li><li>以下所有接口 url 都默认自带 <code>/api</code> 前缀<a id="more"></a></li><li>token 在使用统一身份验证成功登录后会附带到 redirect url 的 query 参数上，前端需自行存储，开发环境的 redirect url 为 <code>http://localhost:8081/#/</code></li><li><strong>私有接口请求方法</strong>：将 token 附在请求 Headers 中的 Authorization 字段上，value 格式为 <code>Bearer ${token}</code> （PS: 建议使用 postman 进行接口测试）</li><li>前端在拿到返回数据时务必先检查 code 是否为零，如若不为零，需给用户正确的反馈，回传数据遵循以下格式：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  code: <span class="built_in">Number</span>,</span><br><span class="line">  data: <span class="built_in">Object</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>code</th><th>说明</th></tr></thead><tbody><tr><td>0</td><td>成功</td></tr><tr><td>-1</td><td>未知错误，查看 message</td></tr><tr><td>1</td><td>拒绝访问</td></tr><tr><td>2</td><td>无效的请求参数</td></tr><tr><td>3</td><td>上传图片出错</td></tr><tr><td>4</td><td>token 校验失败</td></tr><tr><td>其它</td><td>待定</td></tr></tbody></table></div><hr><h3 id="获取用户信息"><a href="#获取用户信息" class="headerlink" title="获取用户信息"></a>获取用户信息</h3><div class="table-container"><table><thead><tr><th style="text-align:center">method</th><th style="text-align:center">url</th><th style="text-align:center">type</th></tr></thead><tbody><tr><td style="text-align:center">GET</td><td style="text-align:center">/user</td><td style="text-align:center">私有接口</td></tr></tbody></table></div><h4 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h4><p>无</p><h4 id="返回参数"><a href="#返回参数" class="headerlink" title="返回参数"></a>返回参数</h4><div class="table-container"><table><thead><tr><th>参数</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>cardId</td><td>String</td><td>校园卡号</td></tr><tr><td>name</td><td>String</td><td>姓名</td></tr><tr><td>college</td><td>String</td><td>学院</td></tr><tr><td>stuId</td><td>String</td><td>学号</td></tr><tr><td>privilege</td><td>Number</td><td>0 为超级管理员，1为普通管理员，如没有该字段则为普通师生</td></tr></tbody></table></div><hr><h3 id="获取管理人员"><a href="#获取管理人员" class="headerlink" title="获取管理人员"></a>获取管理人员</h3><div class="table-container"><table><thead><tr><th style="text-align:center">method</th><th style="text-align:center">url</th><th style="text-align:center">type</th></tr></thead><tbody><tr><td style="text-align:center">POST</td><td style="text-align:center">/getManagers</td><td style="text-align:center">私有接口</td></tr></tbody></table></div><h4 id="请求参数-1"><a href="#请求参数-1" class="headerlink" title="请求参数"></a>请求参数</h4><div class="table-container"><table><thead><tr><th>参数</th><th>类型</th><th>说明</th><th>必填</th></tr></thead><tbody><tr><td>perPage</td><td>Number</td><td>每页包含元素个数</td><td>是</td></tr><tr><td>page</td><td>Number</td><td>页码，第几页</td><td>是</td></tr></tbody></table></div><h4 id="返回参数-1"><a href="#返回参数-1" class="headerlink" title="返回参数"></a>返回参数</h4><div class="table-container"><table><thead><tr><th>参数</th><th>字段</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>length</td><td>-</td><td>Number</td><td>管理人员总数</td></tr><tr><td>managers</td><td>-</td><td>Array</td><td>一个包含指定页数内所有管理人员的数组</td></tr><tr><td>-</td><td>id</td><td>Number</td><td>该管理员在数据库中的唯一标识</td></tr><tr><td>-</td><td>name</td><td>String</td><td>姓名</td></tr><tr><td>-</td><td>cardId</td><td>String</td><td>校园卡号</td></tr><tr><td>-</td><td>authorizer</td><td>String</td><td>授权人姓名</td></tr><tr><td>-</td><td>createdAt</td><td>Date</td><td>添加时间戳</td></tr><tr><td>-</td><td>privilege</td><td>String</td><td>管理权限，超级管理员或普通管理员</td></tr></tbody></table></div><hr><h3 id="添加管理人员"><a href="#添加管理人员" class="headerlink" title="添加管理人员"></a>添加管理人员</h3><div class="table-container"><table><thead><tr><th style="text-align:center">method</th><th style="text-align:center">url</th><th style="text-align:center">type</th></tr></thead><tbody><tr><td style="text-align:center">POST</td><td style="text-align:center">/addManager</td><td style="text-align:center">私有接口</td></tr></tbody></table></div><h4 id="请求参数-2"><a href="#请求参数-2" class="headerlink" title="请求参数"></a>请求参数</h4><div class="table-container"><table><thead><tr><th>参数</th><th>类型</th><th>说明</th><th>必填</th></tr></thead><tbody><tr><td>name</td><td>String</td><td>姓名</td><td>是</td></tr><tr><td>cardId</td><td>String</td><td>校园卡号</td><td>是</td></tr><tr><td>privilege</td><td>Number</td><td>权限，0 为超级管理员，1为普通管理员</td><td>是</td></tr></tbody></table></div><h4 id="返回参数-2"><a href="#返回参数-2" class="headerlink" title="返回参数"></a>返回参数</h4><div class="table-container"><table><thead><tr><th>参数</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>message</td><td>String</td><td>添加结果</td></tr></tbody></table></div><h4 id="错误代码"><a href="#错误代码" class="headerlink" title="错误代码"></a>错误代码</h4><div class="table-container"><table><thead><tr><th>code</th><th>说明</th></tr></thead><tbody><tr><td>1001</td><td>校园卡号冲突</td></tr></tbody></table></div><hr><h3 id="修改管理人员"><a href="#修改管理人员" class="headerlink" title="修改管理人员"></a>修改管理人员</h3><div class="table-container"><table><thead><tr><th style="text-align:center">method</th><th style="text-align:center">url</th><th style="text-align:center">type</th></tr></thead><tbody><tr><td style="text-align:center">POST</td><td style="text-align:center">/updateManager</td><td style="text-align:center">私有接口</td></tr></tbody></table></div><h4 id="请求参数-3"><a href="#请求参数-3" class="headerlink" title="请求参数"></a>请求参数</h4><div class="table-container"><table><thead><tr><th>参数</th><th>类型</th><th>说明</th><th>必填</th></tr></thead><tbody><tr><td>id</td><td>Number</td><td>要修改的管理员的id</td><td>是</td></tr><tr><td>name</td><td>String</td><td>姓名</td><td>是</td></tr><tr><td>cardId</td><td>String</td><td>校园卡号</td><td>是</td></tr><tr><td>privilege</td><td>Number</td><td>权限，0 为超级管理员，1为普通管理员</td><td>是</td></tr></tbody></table></div><h4 id="返回参数-3"><a href="#返回参数-3" class="headerlink" title="返回参数"></a>返回参数</h4><div class="table-container"><table><thead><tr><th>参数</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>message</td><td>String</td><td>修改结果</td></tr></tbody></table></div><h4 id="错误代码-1"><a href="#错误代码-1" class="headerlink" title="错误代码"></a>错误代码</h4><div class="table-container"><table><thead><tr><th>code</th><th>说明</th></tr></thead><tbody><tr><td>1002</td><td>当你要把最后一个超级管理员更改为普通管理员时会出错</td></tr></tbody></table></div><hr><h3 id="删除管理人员"><a href="#删除管理人员" class="headerlink" title="删除管理人员"></a>删除管理人员</h3><div class="table-container"><table><thead><tr><th style="text-align:center">method</th><th style="text-align:center">url</th><th style="text-align:center">type</th></tr></thead><tbody><tr><td style="text-align:center">POST</td><td style="text-align:center">/deleteManager</td><td style="text-align:center">私有接口</td></tr></tbody></table></div><h4 id="请求参数-4"><a href="#请求参数-4" class="headerlink" title="请求参数"></a>请求参数</h4><div class="table-container"><table><thead><tr><th>参数</th><th>类型</th><th>说明</th><th>必填</th></tr></thead><tbody><tr><td>id</td><td>String</td><td>要删除的管理员的id</td><td>是</td></tr></tbody></table></div><h4 id="返回参数-4"><a href="#返回参数-4" class="headerlink" title="返回参数"></a>返回参数</h4><div class="table-container"><table><thead><tr><th>参数</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>message</td><td>String</td><td>删除结果</td></tr></tbody></table></div><h4 id="错误代码-2"><a href="#错误代码-2" class="headerlink" title="错误代码"></a>错误代码</h4><div class="table-container"><table><thead><tr><th>code</th><th>说明</th></tr></thead><tbody><tr><td>1003</td><td>当你要把最后一个超级管理员删除时会出错</td></tr></tbody></table></div><hr><h3 id="搜索管理人员"><a href="#搜索管理人员" class="headerlink" title="搜索管理人员"></a>搜索管理人员</h3><div class="table-container"><table><thead><tr><th style="text-align:center">method</th><th style="text-align:center">url</th><th style="text-align:center">type</th></tr></thead><tbody><tr><td style="text-align:center">POST</td><td style="text-align:center">/searchManagers</td><td style="text-align:center">私有接口</td></tr></tbody></table></div><h4 id="请求参数-5"><a href="#请求参数-5" class="headerlink" title="请求参数"></a>请求参数</h4><div class="table-container"><table><thead><tr><th>参数</th><th>类型</th><th>说明</th><th>必填</th></tr></thead><tbody><tr><td>keyword</td><td>String</td><td>搜索关键词</td><td>是</td></tr><tr><td>maxLength</td><td>Number</td><td>搜索结果最大返回数目（默认为5）</td><td>否</td></tr></tbody></table></div><h4 id="返回参数-5"><a href="#返回参数-5" class="headerlink" title="返回参数"></a>返回参数</h4><div class="table-container"><table><thead><tr><th>参数</th><th>字段</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>managers</td><td>-</td><td>Array</td><td>满足搜索关键词的管理员数组</td></tr><tr><td>-</td><td>id</td><td>Number</td><td>该管理员在数据库中的唯一标识</td></tr><tr><td>-</td><td>name</td><td>String</td><td>姓名</td></tr><tr><td>-</td><td>cardId</td><td>String</td><td>校园卡号</td></tr><tr><td>-</td><td>authorizer</td><td>String</td><td>授权人姓名</td></tr><tr><td>-</td><td>createdAt</td><td>Date</td><td>添加时间戳</td></tr><tr><td>-</td><td>privilege</td><td>String</td><td>管理权限，超级管理员或普通管理员</td></tr></tbody></table></div><hr><h3 id="获取课程信息"><a href="#获取课程信息" class="headerlink" title="获取课程信息"></a>获取课程信息</h3><div class="table-container"><table><thead><tr><th>method</th><th>url</th><th>type</th></tr></thead><tbody><tr><td>POST</td><td>/getCourses</td><td>私有接口</td></tr></tbody></table></div><h4 id="请求参数-6"><a href="#请求参数-6" class="headerlink" title="请求参数"></a>请求参数</h4><div class="table-container"><table><thead><tr><th>参数</th><th>类型</th><th>说明</th><th>必填</th></tr></thead><tbody><tr><td>perPage</td><td>Number</td><td>每页包含元素个数</td><td>是</td></tr><tr><td>page</td><td>Number</td><td>页码，第几页</td><td>是</td></tr></tbody></table></div><h4 id="返回参数-6"><a href="#返回参数-6" class="headerlink" title="返回参数"></a>返回参数</h4><div class="table-container"><table><thead><tr><th>参数</th><th>字段</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>length</td><td>-</td><td>Number</td><td>课程总数</td></tr><tr><td>courses</td><td>-</td><td>Array</td><td>一个包含指定页数所有课程信息的数组</td></tr><tr><td>-</td><td>courseName</td><td>String</td><td>课程名称</td></tr><tr><td>-</td><td>teacher</td><td>String</td><td>讲师姓名</td></tr><tr><td></td><td>time</td><td>String</td><td>上课时间，前端直接展示即可</td></tr><tr><td></td><td>courseId</td><td>String</td><td>课程编号</td></tr><tr><td></td><td>location</td><td>String</td><td>上课地点</td></tr><tr><td></td><td>studentCount</td><td>Number</td><td>选课人数</td></tr></tbody></table></div><hr><h3 id="根据课程编号获取课程详细信息"><a href="#根据课程编号获取课程详细信息" class="headerlink" title="根据课程编号获取课程详细信息"></a>根据课程编号获取课程详细信息</h3><div class="table-container"><table><thead><tr><th>method</th><th>url</th><th>type</th></tr></thead><tbody><tr><td>POST</td><td>/getCourseInfo</td><td>私有接口</td></tr></tbody></table></div><h4 id="请求参数-7"><a href="#请求参数-7" class="headerlink" title="请求参数"></a>请求参数</h4><div class="table-container"><table><thead><tr><th>参数</th><th>类型</th><th>说明</th><th>必填</th></tr></thead><tbody><tr><td>courseId</td><td>String</td><td>课程编号</td><td>是</td></tr></tbody></table></div><h4 id="返回参数-7"><a href="#返回参数-7" class="headerlink" title="返回参数"></a>返回参数</h4><div class="table-container"><table><thead><tr><th>参数</th><th>字段</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>courseName</td><td>-</td><td>String</td><td>课程名称</td></tr><tr><td>teacherId</td><td>-</td><td>String</td><td>讲师在数据库中的id</td></tr><tr><td>teacherName</td><td>-</td><td>String</td><td>讲师姓名</td></tr><tr><td>startTime</td><td>-</td><td>Date</td><td>上课开始时间戳</td></tr><tr><td>endTime</td><td>-</td><td>Date</td><td>上课结束时间戳</td></tr><tr><td>location</td><td>-</td><td>String</td><td>上课地点</td></tr><tr><td>students</td><td>-</td><td>Array</td><td>一个包含指定课程选课所有学生信息的数组</td></tr><tr><td></td><td>name</td><td>String</td><td>学生姓名</td></tr><tr><td></td><td>stuId</td><td>String</td><td>学生学号</td></tr></tbody></table></div><h4 id="错误代码-3"><a href="#错误代码-3" class="headerlink" title="错误代码"></a>错误代码</h4><div class="table-container"><table><thead><tr><th>code</th><th>说明</th></tr></thead><tbody><tr><td>2003</td><td>课程编号错误</td></tr></tbody></table></div><hr><h3 id="查询选课名单"><a href="#查询选课名单" class="headerlink" title="查询选课名单"></a>查询选课名单</h3><div class="table-container"><table><thead><tr><th>method</th><th>url</th><th>type</th></tr></thead><tbody><tr><td>POST</td><td>/getStudentList</td><td>私有接口</td></tr></tbody></table></div><h4 id="请求参数-8"><a href="#请求参数-8" class="headerlink" title="请求参数"></a>请求参数</h4><div class="table-container"><table><thead><tr><th>参数</th><th>类型</th><th>说明</th><th>必填</th></tr></thead><tbody><tr><td>courseId</td><td>String</td><td>课程编号</td><td>是</td></tr><tr><td>perPage</td><td>Number</td><td>每页包含元素个数</td><td>是</td></tr><tr><td>page</td><td>Number</td><td>页码，第几页</td><td>是</td></tr></tbody></table></div><h4 id="返回参数-8"><a href="#返回参数-8" class="headerlink" title="返回参数"></a>返回参数</h4><div class="table-container"><table><thead><tr><th>参数</th><th>字段</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>length</td><td>-</td><td>Number</td><td>选课总人数</td></tr><tr><td>students</td><td>-</td><td>Array</td><td>一个包含指定课程选课所有学生信息的数组</td></tr><tr><td></td><td>name</td><td>String</td><td>学生姓名</td></tr><tr><td></td><td>stuId</td><td>String</td><td>学生学号</td></tr></tbody></table></div><hr><h3 id="删除课程"><a href="#删除课程" class="headerlink" title="删除课程"></a>删除课程</h3><div class="table-container"><table><thead><tr><th>method</th><th>url</th><th>type</th></tr></thead><tbody><tr><td>POST</td><td>/deleteCourse</td><td>私有接口</td></tr></tbody></table></div><h4 id="请求参数-9"><a href="#请求参数-9" class="headerlink" title="请求参数"></a>请求参数</h4><div class="table-container"><table><thead><tr><th>参数</th><th>类型</th><th>说明</th><th>必填</th></tr></thead><tbody><tr><td>courseId</td><td>String</td><td>要删除的课程的课程编号</td><td>是</td></tr></tbody></table></div><h4 id="返回参数-9"><a href="#返回参数-9" class="headerlink" title="返回参数"></a>返回参数</h4><div class="table-container"><table><thead><tr><th>参数</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>message</td><td>String</td><td>删除结果</td></tr></tbody></table></div><hr><h3 id="搜索课程"><a href="#搜索课程" class="headerlink" title="搜索课程"></a>搜索课程</h3><div class="table-container"><table><thead><tr><th>method</th><th>url</th><th>type</th></tr></thead><tbody><tr><td>POST</td><td>/searchCourses</td><td>私有接口</td></tr></tbody></table></div><h4 id="请求参数-10"><a href="#请求参数-10" class="headerlink" title="请求参数"></a>请求参数</h4><div class="table-container"><table><thead><tr><th>参数</th><th>类型</th><th>说明</th><th>必填</th></tr></thead><tbody><tr><td>keyword</td><td>String</td><td>搜索关键词</td><td>是</td></tr><tr><td>maxLength</td><td>Number</td><td>搜索结果最大返回数目（默认为5）</td><td>否</td></tr></tbody></table></div><h4 id="返回参数-10"><a href="#返回参数-10" class="headerlink" title="返回参数"></a>返回参数</h4><div class="table-container"><table><thead><tr><th>参数</th><th>字段</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>courses</td><td>-</td><td>Array</td><td>满足搜索关键词的课程数组</td></tr><tr><td>-</td><td>courseName</td><td>String</td><td>课程名称</td></tr><tr><td>-</td><td>teacher</td><td>String</td><td>讲师姓名</td></tr><tr><td></td><td>time</td><td>String</td><td>上课时间，前端直接展示即可</td></tr><tr><td></td><td>courseId</td><td>String</td><td>课程编号</td></tr><tr><td></td><td>location</td><td>String</td><td>上课地点</td></tr><tr><td></td><td>studentCount</td><td>Number</td><td>选课人数</td></tr></tbody></table></div><hr><h3 id="生成课程"><a href="#生成课程" class="headerlink" title="生成课程"></a>生成课程</h3><div class="table-container"><table><thead><tr><th>method</th><th>url</th><th>type</th></tr></thead><tbody><tr><td>POST</td><td>/addCourse</td><td>私有接口</td></tr></tbody></table></div><h4 id="请求参数-11"><a href="#请求参数-11" class="headerlink" title="请求参数"></a>请求参数</h4><div class="table-container"><table><thead><tr><th>参数</th><th>字段</th><th>类型</th><th>说明</th><th>必填</th></tr></thead><tbody><tr><td>courseName</td><td>-</td><td>String</td><td>课程名称</td><td>是</td></tr><tr><td>teacherId</td><td>-</td><td>String</td><td>讲师在数据库中的id</td><td>是</td></tr><tr><td>startTime</td><td>-</td><td>Date</td><td>上课开始时间戳</td><td>是</td></tr><tr><td>endTime</td><td>-</td><td>Date</td><td>上课结束时间戳</td><td>是</td></tr><tr><td>location</td><td>-</td><td>String</td><td>上课地点</td><td>是</td></tr><tr><td>students</td><td>-</td><td>Array</td><td>选课学生数组</td><td>是</td></tr><tr><td>-</td><td>name</td><td>String</td><td>学生姓名</td><td>是</td></tr><tr><td>-</td><td>stuId</td><td>String</td><td>学生学号</td><td>是</td></tr></tbody></table></div><h4 id="返回参数-11"><a href="#返回参数-11" class="headerlink" title="返回参数"></a>返回参数</h4><div class="table-container"><table><thead><tr><th>参数</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>courseId</td><td>String</td><td>生成的课程编号</td></tr></tbody></table></div><h4 id="错误代码-4"><a href="#错误代码-4" class="headerlink" title="错误代码"></a>错误代码</h4><div class="table-container"><table><thead><tr><th>code</th><th>说明</th></tr></thead><tbody><tr><td>2001</td><td>讲师不存在</td></tr></tbody></table></div><hr><h3 id="修改课程"><a href="#修改课程" class="headerlink" title="修改课程"></a>修改课程</h3><div class="table-container"><table><thead><tr><th>method</th><th>url</th><th>type</th></tr></thead><tbody><tr><td>POST</td><td>/updateCourse</td><td>私有接口</td></tr></tbody></table></div><h4 id="请求参数-12"><a href="#请求参数-12" class="headerlink" title="请求参数"></a>请求参数</h4><div class="table-container"><table><thead><tr><th>参数</th><th>字段</th><th>类型</th><th>说明</th><th>必填</th></tr></thead><tbody><tr><td>courseId</td><td>-</td><td>String</td><td>课程编号（乱传打爆你▄︻┻═┳一）</td><td>是</td></tr><tr><td>courseName</td><td>-</td><td>String</td><td>课程名称</td><td>是</td></tr><tr><td>teacherId</td><td>-</td><td>String</td><td>讲师在数据库中的id</td><td>是</td></tr><tr><td>startTime</td><td>-</td><td>String</td><td>上课开始时间戳</td><td>是</td></tr><tr><td>endTime</td><td>-</td><td>String</td><td>上课结束时间戳</td><td>是</td></tr><tr><td>location</td><td>-</td><td>String</td><td>上课地点</td><td>是</td></tr><tr><td>students</td><td>-</td><td>Array</td><td>选课学生数组</td><td>是</td></tr><tr><td>-</td><td>name</td><td>String</td><td>学生姓名</td><td>是</td></tr><tr><td>-</td><td>stuId</td><td>String</td><td>学生学号</td><td>是</td></tr></tbody></table></div><h4 id="返回参数-12"><a href="#返回参数-12" class="headerlink" title="返回参数"></a>返回参数</h4><div class="table-container"><table><thead><tr><th>参数</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>message</td><td>String</td><td>修改结果</td></tr></tbody></table></div><h4 id="错误代码-5"><a href="#错误代码-5" class="headerlink" title="错误代码"></a>错误代码</h4><div class="table-container"><table><thead><tr><th>code</th><th>说明</th></tr></thead><tbody><tr><td>2001</td><td>讲师不存在</td></tr><tr><td>2002</td><td>课程编号不存在</td></tr></tbody></table></div><hr><h3 id="获取讲师信息"><a href="#获取讲师信息" class="headerlink" title="获取讲师信息"></a>获取讲师信息</h3><div class="table-container"><table><thead><tr><th>method</th><th>url</th><th>type</th></tr></thead><tbody><tr><td>POST</td><td>/getTeachers</td><td>私有接口</td></tr></tbody></table></div><h4 id="请求参数-13"><a href="#请求参数-13" class="headerlink" title="请求参数"></a>请求参数</h4><div class="table-container"><table><thead><tr><th>参数</th><th>类型</th><th>说明</th><th>必填</th></tr></thead><tbody><tr><td>perPage</td><td>Number</td><td>每页包含元素个数</td><td>是</td></tr><tr><td>page</td><td>Number</td><td>页码，第几页</td><td>是</td></tr></tbody></table></div><h4 id="返回参数-13"><a href="#返回参数-13" class="headerlink" title="返回参数"></a>返回参数</h4><div class="table-container"><table><thead><tr><th>参数</th><th>字段</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>length</td><td>-</td><td>Number</td><td>讲师总数</td></tr><tr><td>teachers</td><td>-</td><td>Array</td><td>一个包含指定页数所有讲师信息的数组</td></tr><tr><td>-</td><td>id</td><td>Number</td><td>该讲师在数据库的唯一标识</td></tr><tr><td>-</td><td>name</td><td>String</td><td>讲师姓名</td></tr><tr><td></td><td>imageUrl</td><td>String</td><td>讲师照片的 url</td></tr></tbody></table></div><hr><h3 id="删除讲师"><a href="#删除讲师" class="headerlink" title="删除讲师"></a>删除讲师</h3><div class="table-container"><table><thead><tr><th>method</th><th>url</th><th>type</th></tr></thead><tbody><tr><td>POST</td><td>/deleteTeacher</td><td>私有接口</td></tr></tbody></table></div><h4 id="请求参数-14"><a href="#请求参数-14" class="headerlink" title="请求参数"></a>请求参数</h4><div class="table-container"><table><thead><tr><th>参数</th><th>类型</th><th>说明</th><th>必填</th></tr></thead><tbody><tr><td>id</td><td>Number</td><td>讲师 id ，在 <code>/getTeachers</code> 接口获取到的</td><td>是</td></tr></tbody></table></div><h4 id="返回参数-14"><a href="#返回参数-14" class="headerlink" title="返回参数"></a>返回参数</h4><div class="table-container"><table><thead><tr><th>参数</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>message</td><td>String</td><td>删除结果</td></tr></tbody></table></div><hr><h3 id="搜索讲师"><a href="#搜索讲师" class="headerlink" title="搜索讲师"></a>搜索讲师</h3><div class="table-container"><table><thead><tr><th>method</th><th>url</th><th>type</th></tr></thead><tbody><tr><td>POST</td><td>/searchTeachers</td><td>私有接口</td></tr></tbody></table></div><h4 id="请求参数-15"><a href="#请求参数-15" class="headerlink" title="请求参数"></a>请求参数</h4><div class="table-container"><table><thead><tr><th>参数</th><th>类型</th><th>说明</th><th>必填</th></tr></thead><tbody><tr><td>keyword</td><td>String</td><td>搜索关键词</td><td>是</td></tr><tr><td>maxLength</td><td>Number</td><td>搜索结果最大返回数目（默认为5）</td><td>否</td></tr></tbody></table></div><h4 id="返回参数-15"><a href="#返回参数-15" class="headerlink" title="返回参数"></a>返回参数</h4><div class="table-container"><table><thead><tr><th>参数</th><th>字段</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>teachers</td><td>-</td><td>Array</td><td>满足搜索关键字的讲师数组</td></tr><tr><td></td><td>id</td><td>Number</td><td>该讲师在数据库的唯一标识</td></tr><tr><td>-</td><td>name</td><td>String</td><td>讲师姓名</td></tr><tr><td></td><td>imageUrl</td><td>String</td><td>讲师照片的 url</td></tr></tbody></table></div><hr><h3 id="查询一个讲师的详细信息"><a href="#查询一个讲师的详细信息" class="headerlink" title="查询一个讲师的详细信息"></a>查询一个讲师的详细信息</h3><div class="table-container"><table><thead><tr><th>method</th><th>url</th><th>type</th></tr></thead><tbody><tr><td>POST</td><td>/getTeacherInfo</td><td>私有接口</td></tr></tbody></table></div><h4 id="请求参数-16"><a href="#请求参数-16" class="headerlink" title="请求参数"></a>请求参数</h4><div class="table-container"><table><thead><tr><th>参数</th><th>类型</th><th>说明</th><th>必填</th></tr></thead><tbody><tr><td>id</td><td>Number</td><td>讲师 id ，在 <code>/getTeachers</code> 接口获取到的</td><td>是</td></tr></tbody></table></div><h4 id="返回参数-16"><a href="#返回参数-16" class="headerlink" title="返回参数"></a>返回参数</h4><div class="table-container"><table><thead><tr><th>参数</th><th>字段</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>name</td><td>-</td><td>String</td><td>讲师姓名</td></tr><tr><td>college</td><td>-</td><td>String</td><td>所属单位</td></tr><tr><td>intro</td><td>-</td><td>String</td><td>老师简介</td></tr><tr><td>phone</td><td>-</td><td>String</td><td>手机号码</td></tr><tr><td>office</td><td>-</td><td>String</td><td>办公地址</td></tr><tr><td>email</td><td>-</td><td>String</td><td>邮箱地址</td></tr><tr><td>imageUrl</td><td>-</td><td>String</td><td>导师照片 url</td></tr><tr><td>teachForm</td><td>-</td><td>String</td><td>授课形式</td></tr><tr><td>teachTopic</td><td>-</td><td>Array</td><td>该讲师授课专题的数组</td></tr><tr><td></td><td>-</td><td>String</td><td>授课专题</td></tr></tbody></table></div><hr><h3 id="图片上传接口"><a href="#图片上传接口" class="headerlink" title="图片上传接口"></a>图片上传接口</h3><div class="table-container"><table><thead><tr><th>method</th><th>url</th><th>type</th></tr></thead><tbody><tr><td>POST</td><td>/upload</td><td>私有接口</td></tr></tbody></table></div><h4 id="请求参数-17"><a href="#请求参数-17" class="headerlink" title="请求参数"></a>请求参数</h4><div class="table-container"><table><thead><tr><th>参数</th><th>类型</th><th>说明</th><th>必填</th></tr></thead><tbody><tr><td>-</td><td>FormData</td><td>图片数据</td><td>是</td></tr></tbody></table></div><h4 id="返回参数-17"><a href="#返回参数-17" class="headerlink" title="返回参数"></a>返回参数</h4><div class="table-container"><table><thead><tr><th>参数</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>url</td><td>String</td><td>图片 url</td></tr></tbody></table></div><hr><h3 id="添加讲师"><a href="#添加讲师" class="headerlink" title="添加讲师"></a>添加讲师</h3><div class="table-container"><table><thead><tr><th>method</th><th>url</th><th>type</th></tr></thead><tbody><tr><td>POST</td><td>/addTeacher</td><td>私有接口</td></tr></tbody></table></div><h4 id="请求参数-18"><a href="#请求参数-18" class="headerlink" title="请求参数"></a>请求参数</h4><div class="table-container"><table><thead><tr><th>参数</th><th>字段</th><th>类型</th><th>说明</th><th>必填</th></tr></thead><tbody><tr><td>name</td><td>-</td><td>String</td><td>讲师姓名</td><td>是</td></tr><tr><td>college</td><td>-</td><td>String</td><td>所属单位</td><td>是</td></tr><tr><td>intro</td><td>-</td><td>String</td><td>老师简介</td><td>是</td></tr><tr><td>phone</td><td>-</td><td>String</td><td>手机号码</td><td>是</td></tr><tr><td>office</td><td>-</td><td>String</td><td>办公地址</td><td>是</td></tr><tr><td>email</td><td>-</td><td>String</td><td>邮箱地址</td><td>是</td></tr><tr><td>imageUrl</td><td>-</td><td>String</td><td>导师照片 url</td><td>是</td></tr><tr><td>teachForm</td><td>-</td><td>String</td><td>授课形式</td><td>是</td></tr><tr><td>teachTopic</td><td>-</td><td>Array</td><td>该讲师授课专题的数组</td><td>是</td></tr><tr><td></td><td>-</td><td>String</td><td>授课专题</td><td>是</td></tr></tbody></table></div><h4 id="返回参数-18"><a href="#返回参数-18" class="headerlink" title="返回参数"></a>返回参数</h4><div class="table-container"><table><thead><tr><th>参数</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>id</td><td>Number</td><td>该讲师在数据库的唯一标识</td></tr></tbody></table></div><hr><h3 id="修改讲师信息"><a href="#修改讲师信息" class="headerlink" title="修改讲师信息"></a>修改讲师信息</h3><div class="table-container"><table><thead><tr><th>method</th><th>url</th><th>type</th></tr></thead><tbody><tr><td>POST</td><td>/updateTeacher</td><td>私有接口</td></tr></tbody></table></div><h4 id="请求参数-19"><a href="#请求参数-19" class="headerlink" title="请求参数"></a>请求参数</h4><div class="table-container"><table><thead><tr><th>参数</th><th>字段</th><th>类型</th><th>说明</th><th>必填</th></tr></thead><tbody><tr><td>id</td><td>-</td><td>Number</td><td>要修改的讲师的 id</td><td>是</td></tr><tr><td>name</td><td>-</td><td>String</td><td>讲师姓名</td><td>是</td></tr><tr><td>college</td><td>-</td><td>String</td><td>所属单位</td><td>是</td></tr><tr><td>intro</td><td>-</td><td>String</td><td>老师简介</td><td>是</td></tr><tr><td>phone</td><td>-</td><td>String</td><td>手机号码</td><td>是</td></tr><tr><td>office</td><td>-</td><td>String</td><td>办公地址</td><td>是</td></tr><tr><td>email</td><td>-</td><td>String</td><td>邮箱地址</td><td>是</td></tr><tr><td>imageUrl</td><td>-</td><td>String</td><td>导师照片 url</td><td>是</td></tr><tr><td>teachForm</td><td>-</td><td>String</td><td>授课形式</td><td>是</td></tr><tr><td>teachTopic</td><td>-</td><td>Array</td><td>该讲师授课专题的数组</td><td>是</td></tr><tr><td></td><td>-</td><td>String</td><td>授课专题</td><td>是</td></tr></tbody></table></div><h4 id="返回参数-19"><a href="#返回参数-19" class="headerlink" title="返回参数"></a>返回参数</h4><div class="table-container"><table><thead><tr><th>参数</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>message</td><td>String</td><td>修改结果</td></tr></tbody></table></div><h4 id="错误代码-6"><a href="#错误代码-6" class="headerlink" title="错误代码"></a>错误代码</h4><div class="table-container"><table><thead><tr><th>code</th><th>说明</th></tr></thead><tbody><tr><td>3001</td><td>指定 id 的老师不存在</td></tr></tbody></table></div>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;API-接口设计&quot;&gt;&lt;a href=&quot;#API-接口设计&quot; class=&quot;headerlink&quot; title=&quot;API 接口设计&quot;&gt;&lt;/a&gt;API 接口设计&lt;/h2&gt;&lt;h3 id=&quot;接口地址&quot;&gt;&lt;a href=&quot;#接口地址&quot; class=&quot;headerlink&quot; title=&quot;接口地址&quot;&gt;&lt;/a&gt;接口地址&lt;/h3&gt;&lt;div class=&quot;table-container&quot;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;环境&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;URL&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;开发环境&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;http://like.suevily.cn/&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;生产环境&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;待定&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;h3 id=&quot;通用&quot;&gt;&lt;a href=&quot;#通用&quot; class=&quot;headerlink&quot; title=&quot;通用&quot;&gt;&lt;/a&gt;通用&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;以下接口分为开放接口和私有接口&lt;ul&gt;
&lt;li&gt;开放接口：无需登录校验即可请求&lt;/li&gt;
&lt;li&gt;私有接口：需校验登录 token 方可请求&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;以下所有接口 url 都默认自带 &lt;code&gt;/api&lt;/code&gt; 前缀
    
    </summary>
    
    
      <category term="API" scheme="http://Bithub00.com/tags/API/"/>
    
      <category term="Node.js" scheme="http://Bithub00.com/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>AWS:S3 + Athena + Glue</title>
    <link href="http://Bithub00.com/2019/04/03/AWS/"/>
    <id>http://Bithub00.com/2019/04/03/AWS/</id>
    <published>2019-04-03T09:52:53.423Z</published>
    <updated>2019-08-07T07:58:35.080Z</updated>
    
    <content type="html"><![CDATA[<p><font size="3"><br>整理一下自己了解的S3、Athena和Glue</font><br><a id="more"></a></p><h2 id="S3"><a href="#S3" class="headerlink" title="S3"></a>S3</h2><p>AWS使用S3（Simple Storage Service）进行存储，它可以存储海量的数据，存储的往往是不常使用的冷数据，而且采取特定的Parquet格式进行列式存储或分区，可以节省存储空间而且提升查询性能。</p><p>使用S3存储动态数据会使得系统依赖于S3本身的可用性，可以通过增加缓存层或CDN(Content Deliver Network)服务来减轻影响。</p><p>S3提供REST接口,两个组成层次是容器(bucket)和对象(object)。容器是S3最上面的分类，所有的对象都放在容器里，因此容器名称必须是唯一的，每个对象都有唯一可识别的URL，应该尽量避免对容器进行操作，使用对象名称就可以实现分层次和分类了.</p><p>存储在S3的对象，除了本身的值以外,还会记录标头、元数据、访问控制列表等等，标头中存储了对象类型等信息，元数据就是用户自己定义的表头，为键值对，访问控制列表就是访问权限。因为S3有所谓偷窥对象的功能，即只读取对象的标头的信息，我们可以先看标头信息，再决定要不要把对象读取下来。</p><p>S3没有目录的概念，是扁平化的存储结构，“photo/1.jpg”和“photo/2.jpg”可能存在于不同的服务器集群。</p><h2 id="Athena"><a href="#Athena" class="headerlink" title="Athena"></a>Athena</h2><p>Athena是一个查询服务，可以使用标准的SQL来对S3上存储的数据进行查询。而且它是一个serverless的服务，不需要去考虑底层的硬件设施，只需要为查询服务付费。同时，Athena使用IAM来管理权限，部分操作需要对应的权限才能进行。</p><p>Athena使用SerDe来与各种数据格式进行交互，包括CSV,JSON和Parquet。在使用时进行指定。</p><h2 id="Glue"><a href="#Glue" class="headerlink" title="Glue"></a>Glue</h2><p>Glue是一个元数据系统，它维护了信息诸如数据具体存储的位置以及数据的结构，它本身还提供了ETL的能力。<br>Glue里面几个关键的概念是Database, Table, Crawler, Classifier, Job:</p><ul><li>Database 跟我们普通理解的数据库的概念是类似的，是一组table的逻辑集合。</li><li>Table 是数据的元数据，它定义数据保存在哪里(比如S3的路径)，有哪些column，怎么分区的。</li><li>Crawler 是元数据的爬虫，你给它一个路径，告诉它每天去爬一次，Crawler就可以及时把更新的元数据，比如新增的分区同步到Glue里面来供计算引擎消费。</li><li>Classifier 是数据结构的解析器，你给Crawler一个S3的路径它怎么就能解析出其中的结构呢，这就是Classifier要干的事情，Glue里面已经内置了一些Classfier, 用户也可以自定义Classifier。</li><li>Job是一个ETL脚本</li></ul><p><img src="https://s2.ax1x.com/2019/04/03/AgAio8.png" alt=""></p><h2 id="Glue与Athena"><a href="#Glue与Athena" class="headerlink" title="Glue与Athena"></a>Glue与Athena</h2><p>AWS Glue 是一项完全托管的 ETL (提取、转换和加载) 服务，能够对数据进行分类、清理和扩充，并在各种数据存储之间可靠地移动数据。AWS Glue 爬网程序自动从源数据推断数据库和表架构，从而将关联的元数据存储在 AWS Glue 数据目录中。在 Athena 中创建表时，可以选择使用 AWS Glue 爬网程序创建表。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><ul><li><p><a href="https://aws.amazon.com/cn/blogs/big-data/build-a-data-lake-foundation-with-aws-glue-and-amazon-s3/" target="_blank" rel="noopener">使用Glue读取csv并转换成Parquet格式随后使用Athena查询</a></p></li><li><p><a href="https://aws.amazon.com/cn/blogs/china/etl-pipeline-for-serverless-architecture-using-glue/" target="_blank" rel="noopener">Glue自定义分类器识别服务器日志</a></p></li><li><p><a href="https://aws.amazon.com/cn/blogs/database/how-to-extract-transform-and-load-data-for-analytic-processing-using-aws-glue-part-2/" target="_blank" rel="noopener">How to extract, transform, and load data for analytic processing using AWS Glue (Part 2)</a></p></li><li><p><a href="https://gorillalogic.com/blog/in-search-of-happiness-a-quick-etl-use-case-with-aws-glue-redshift/" target="_blank" rel="noopener">In Search of Happiness: A Quick ETL Use Case with AWS Glue + Redshift</a></p></li></ul><h2 id="Athena与S3"><a href="#Athena与S3" class="headerlink" title="Athena与S3"></a>Athena与S3</h2><p>Athena 可帮助分析在 Amazon S3 中存储的非结构化、半结构化和结构化数据。包括 CSV、JSON 或列式数据格式，如 Apache Parquet 和 Apache ORC。可以使用 ANSI SQL 通过 Athena 运行临时查询，而无需将数据聚合或加载到 Athena 中。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font size=&quot;3&quot;&gt;&lt;br&gt;整理一下自己了解的S3、Athena和Glue
&lt;/font&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="AWS" scheme="http://Bithub00.com/tags/AWS/"/>
    
  </entry>
  
  <entry>
    <title>L1与L2范数</title>
    <link href="http://Bithub00.com/2019/04/03/%E8%8C%83%E6%95%B0/"/>
    <id>http://Bithub00.com/2019/04/03/范数/</id>
    <published>2019-04-03T04:59:52.310Z</published>
    <updated>2019-08-07T08:00:29.935Z</updated>
    
    <content type="html"><![CDATA[<font size="3">看到的一篇很好的介绍L1与L2范数的文章，mark下来</font><a id="more"></a><p><img src="https://s2.ax1x.com/2019/04/03/Accl6O.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;font size=&quot;3&quot;&gt;
看到的一篇很好的介绍L1与L2范数的文章，mark下来
&lt;/font&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://Bithub00.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>安卓Activity移植</title>
    <link href="http://Bithub00.com/2018/09/07/%E5%AE%89%E5%8D%93Activity%E7%A7%BB%E6%A4%8D/"/>
    <id>http://Bithub00.com/2018/09/07/安卓Activity移植/</id>
    <published>2018-09-07T04:31:55.617Z</published>
    <updated>2019-08-06T04:38:29.791Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章记录一下之前将写的一个Activity加入现有应用时遇到的坑<br><a id="more"></a></p><h2 id="找不到R"><a href="#找不到R" class="headerlink" title="找不到R"></a>找不到R</h2><p>&#8194;这个问题移植完后马上就会遇到，在将layout里的xml文件等都复制过来后，如果问题还存在，直接Android Studio中 Build-Clen Project 一次，问题基本上就解决了</p><h2 id="包名"><a href="#包名" class="headerlink" title="包名"></a>包名</h2><p>&#8194;形如com.package.XXXXX等问题，复制代码文件时IDE会自动帮我们修正，但布局文件中IDE是不会帮我们纠正过来的,例如<center>`"tools:context=".MainActivity""`</center>就要进行修改，或者在标签中出现com.package.XXXX没有修改的情况，只能一个个xml文件去找了</p><h2 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h2><p>&#8194;如果在移植的Activity中继承了Application类创造了自己的，那移植过去后一定要在AndroidManifest.xml文件的\<application>里的android:name中进行修改</application></p><h2 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h2><p>&#8194;最后就是一直过去后要在AndroidManifest.xml文件中添加移植过去的Activity，不然运行时会报错，Logcat中也会给出建议</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章记录一下之前将写的一个Activity加入现有应用时遇到的坑&lt;br&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://Bithub00.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>SIMLR算法论文个人翻译</title>
    <link href="http://Bithub00.com/2018/07/25/SIMLR%E7%AE%97%E6%B3%95/"/>
    <id>http://Bithub00.com/2018/07/25/SIMLR算法/</id>
    <published>2018-07-25T12:00:18.373Z</published>
    <updated>2019-08-07T09:19:27.860Z</updated>
    
    <content type="html"><![CDATA[<font size="5">基于多核函数的单细胞RNA序列分析与可视化算法</font><p>&#8194; </p><font size="3">摘要：我们将要介绍的SIMLR算法，在理论框架和软件应用上已经实现，它从输入的单细胞RNA序列中学习到一种相似度的信息，随后可以用这种信息来实现降维、聚类和可视化等后续处理。在七个公开的数据集上我们对算法进行了检验并于一些常用的算法进行了比较分析。结果证明了SIMLR算法对大规模数据的良好处理以及极大程度上提高了聚类的效果，同时提升了可视化的效果以及对细胞间相似程度的识别。</font><a id="more"></a><font size="3">关键词：多核函数；低秩约束；单细胞RNA序列</font><h2 id="背景介绍及概览"><a href="#背景介绍及概览" class="headerlink" title="背景介绍及概览"></a>背景介绍及概览</h2><p>&#8194; 此前，对单细胞RNA序列的研究揭示了细胞种群间未被洞悉的异构性与功能分化。近期的研究阐释说明了通过对RNA序列的无偏分析，是有可能做到对细胞子群功能特异性的de novo分析的。然而，大部分用来应用的算法都是针对传统的大规模RNA序列数据，而基因的表达结果在一群细胞中被平均化了。这些算法并不能成功地处理如下问题：如噪声数据、离散点以及dropout现象（获取基因表达数据时未能成功识别基因表达结果而标记为0，而实际情况是基因进行了表达）。诸如DropSeq和GemCode的平台已经显著增加了数千个细胞的细胞信息，然而，这类平台产生的多为稀疏数据，其中95%的基因测量结果被标记为0。对于诸如降维、聚类以及数据可视化等无监督学习的方法来说，其中一个关键就是相似度矩阵的学习，而这个矩阵对于不同平台或者生物实验得到的数据并不通用。为了解决上述问题，我们提出了SIMLR算法，一个从输入的单细胞RNA序列数据中学习细胞与细胞之间相似度矩阵的框架。</p><p>&#8194; 相较于传统的算法，SIMLR算法有三个主要的优势：首先，它通过使用多个核函数的方法来学习一个最符合输入数据的结构的相似性矩阵。常规的降维或聚类算法对数据的假设有时并不适用于单细胞RNA序列数据。而多个核函数被证实在描绘数据多角度的信息下有着更好的效果，而且相对于单个核函数具有更好的灵活性。第二，对于高维度下的dropout现象，SIMLR算法通过对学习的相似度矩阵应用秩约束以及使用图扩散的方法来解决。秩约束的应用增强了相似度矩阵的分块对角结构，而图扩散方法提高了对弱相似度的识别。第三，算法习得的相似度矩阵可以被高效的用来后续的数据分析，比如通过SNE算法进行数据在低维空间下的可视化。</p><p>&#8194; 我们通过在四个公开的单细胞数据集上应用SIMLR算法来与传统的算法比较，结果是SIMLR算法习得的相似度矩阵在表现数据相似度上要表现得更好。每个数据集中细胞所属的种类是先验的并且在研究中已经被证实正确。通过输入数据集和细胞的种类数，SIMLR算法就能学习出一个细胞间的相似度矩阵，而不需要输入细胞真实所属类别的标签信息。而且相较于传统的相关系数或欧几里得距离衡量相似度，SIMLR算法的结果要更加接近真实结果。特别的是，Buettner数据集的真实标签是细胞周期的状态，我们在这个数据集上额外应用了SIMLR算法来对基因进行排序。算法输出一个基因网络，来展现不同的基因在细胞各个周期、翻译以及代谢过程中的相关性。</p><p><img src="https://s1.ax1x.com/2018/07/31/PdhleH.png" alt=""></p><p>&#8194; 图表1：SIMLR算法的总览。给定一个基因表达数据的矩阵作为输入，算法构建并学习多个核函数之间的权重，并构建出一个相似度矩阵。给定细胞种类数C作为输入，构建出的相似度矩阵将有一个含C个分块的分块对角矩阵，每个分块中的细胞都更为相似。算法使用得到的相似度矩阵来进行降维、可视化、聚类等后续处理。实心箭头代表了需要被用来构建相似度矩阵的信息，而点线箭头则表明聚类的结果可以与可视化以及基因排序相结合。2D散点图中的每一个点代表一个细胞，而不同的颜色代表细胞所属的不同类别。</p><p>&#8194; 为了分析算法在降维上的效果，我们与8个传统的降维算法进行了比较，包括主成分分析、tSNE以及ZIFA算法。在六种不同的表现算法优劣矩阵中，SIMLE算法在四个公开的数据集上表现出色，并且远远的拉开了与第二名的差距。</p><p>&#8194; 我们还进行了低维数据的可视化实验。结果表明，在各个数据集上SIMLR算法的结果不仅能吻合数据集给出的真实标签，甚至在秩约束有关的参数没有贡献时同样能保持相似度矩阵的分块对角结构。特别地，在Kolodziejczyk这个数据集上，我们还从SIMLR算法的结果上发现，在已知的分类结果上其实还能继续往下细分，这个结果也符合与这个数据集有关的理论研究。</p><p>&#8194; SIMLR算法同样可以用来进行细胞聚类，通过降维后应用k-means算法或者直接对习得的相似度矩阵使用AP近邻算法来实现。后者的表现性要远远超过使用皮尔逊相关系数或欧几里得距离来衡量相似性的方法。而前者的表现性在四个数据集上也比现有的针对单细胞的聚类算法要更好。</p><p>&#8194; 为了检验算法的能力，我们应用了更多更有挑战性的方案。我们分析了一个GemCode平台上提供的周边血液单核球细胞的稀疏数据集，里面包含了2700个细胞且其中95%的基因表达结果被标记为0。通过降维后应用k-means算法，我们识别出八种主要的细胞类别，包括一个只含12个细胞的megakaryocyte种类。除此之外，我们还在不同的已经得到充分研究的数据集上试验了SIMLR算法的表现性。</p><p>&#8194; 为了说明SIMLR算法在大规模数据上的表现性，我们在三个公开的大规模数据集上进行了试验。我们对真实标签与算法输出的预测表情的相关性进行了计算。对于Zeisei数据集，我们应用了一个二级聚类的方法，发现SIMLR算法可以用来进行在对细胞的层次结构的分析。而且，低维可视化的结果也很好的符合了真实的数据标签。即使是大规模数据集中因为噪声和离散点所造成的相似信息被隐藏的情况，SIMLR算法也能学习一个合适的细胞之间的距离。</p><p><img src="https://s1.ax1x.com/2018/07/31/PdhGFI.png" alt=""><br>&#8194; 图表2：在不同数据集上的测试结果。分别给出了SIMLR算法、基于高斯核的欧几里得距离以及皮尔逊相关系数所得到的相似度矩阵。排放的次序基于相似度的高低。矩阵中的细胞都按照真实的种类来进行排列，使得同一种类的细胞排列在一起，坐标轴上的不同颜色代表不同的种类。可以看出，SIMLR算法的相似度矩阵的分块对角结构与真实标签基本符合。&#8194;</p><p>&#8194; 总的来说，SIMLR算法可以基于不同的数据集通用地判断那些细胞更为相似，即判断结果不受特定数据集影响，并应用降维、聚类、数据可视化等分析方法。SIMLR算法在有着清晰分类的数据集上表现出色，而我们预测这个多核学习的框架在分类不明显的数据集上也会同样产生作用。</p><p><img src="https://s1.ax1x.com/2018/07/31/PdhMOe.png" alt=""><br>&#8194; 图表3： 2维可视化结果的比较。坐标轴无实际意义。每个点代表一个细胞，而靠得越近的点代表相似度越高。数据可视化时没有输入真实的标签信息，在算法的输出时才让各个数据点标上真实的颜色以检验算法的效果。</p><h2 id="算法详述："><a href="#算法详述：" class="headerlink" title="算法详述："></a>算法详述：</h2><p>SIMLR算法提供了Matlab和R语言两个版本的实现（<a href="https://github.com/BatzoglouLabSU/SIMLR）" target="_blank" rel="noopener">https://github.com/BatzoglouLabSU/SIMLR）</a></p><p>&#8194; k-means算法的实现我们使用了Matlab和R语言自带的模块。而SNE算法我们修改了两个语言中这一模块的源代码。四个公开的数据集随着源代码一起被提供。而三个大型的数据集可以在相应的平台上得到。输入一个N×M的的基因表达矩阵，N代表细胞个数，M代表基因数。SIMLR算法将输出一个S×S的相似性矩阵。其中Sij表示两个细胞之间的相似度。给定一个细胞种类数C，算法假定输出的相似度矩阵将有一个含C个分块的分块对角矩阵，各个分块中的细胞更为相似。我们对两个细胞之间的距离定义为：</p><p><img src="https://s1.ax1x.com/2018/07/31/PdhuQO.png" alt=""><br>其中wl代表核函数的权重</p><font size="4"> 算法依据如下损失函数来计算细胞与细胞之间的相似性：</font><p><img src="https://s1.ax1x.com/2018/07/31/PdhKyD.png" alt=""><br>&#8194; 其中IN和IC分别为N×N和C×C的单位矩阵，tr(.)代表矩阵的秩，β和γ均为非零值，||S||F为范数表示，L为辅助的用来对S进行低秩约束。因此这个损失函数求解三个参数：相似度矩阵S，核函数权重向量w以及一个结构为N×C的秩约束矩阵L。</p><font size="3">  &#8194; 损失函数的第一项含义为，如果两个细胞间的距离很远，则它们的相似度应该很低。第二项是一个对S的正则化，防止S矩阵过于接近一个单位矩阵。如果细胞可以被划分为C类，则每一类中的细胞更为相似，理想情况下矩阵S的秩为C。因此，损失函数的第三项以及L矩阵的引入增强了S的低秩结构，而矩阵（IN-S）即为拉普拉斯矩阵，在一个相似图中，每个节点代表一个细胞，边衡量节点间的相似性。第四项对核函数的权重进行约束，防止单核函数情况的出现。实践证明，这个正则化项提高了相似矩阵的表现。</font>  <h3 id="核函数的构建"><a href="#核函数的构建" class="headerlink" title="核函数的构建"></a>核函数的构建</h3><p>我们以带有不同超参数的高斯核为基础构建不同的核函数，实践证明相对其它核函数高斯核的表现更好。</p><p><img src="https://s1.ax1x.com/2018/07/31/Pdh1wd.png" alt=""></p><p>式中||ci - cj||表示细胞i和j之间的欧几里得距离。</p><font size="3"> 方差ɛij的定义式如下：</font><p><img src="https://s1.ax1x.com/2018/07/31/Pdh3TA.png" alt=""></p><p>&#8194; 因此，每一个核函数被一对参数(σ，k).我们设定k = 10，12，14,…,30 以及σ = 1.0，1.25，1.5，1.75，2，产生了55个不同的核函数。然而，实践证明，算法对核函数的数量以及参数的选择并不敏感。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ul><li>核函数的权重w被初始化为核函数数量的倒数：</li></ul><p><img src="https://s1.ax1x.com/2018/07/31/PdhTt1.png" alt=""></p><ul><li>相似度矩阵S被初始化为：</li></ul><p><img src="https://s1.ax1x.com/2018/07/31/PdhokR.png" alt=""></p><ul><li>而矩阵L被初始化为拉普拉斯矩阵（IN - S）的前C个特征向量。</li></ul><h3 id="优化算法"><a href="#优化算法" class="headerlink" title="优化算法"></a>优化算法</h3><p>我们对S,L和w进行优化。上文中的优化式非凸，但固定某两个参数得到的目标函数为凸函数。因此我们可以有效的应用凸优化算法来进行求解。</p><ul><li>步骤1：固定L和w对S进行更新。损失函数可以被重写为：</li></ul><p><img src="https://s1.ax1x.com/2018/07/31/Pdhbp6.png" alt=""></p><p>&#8194; 目标函数中第一项求和式以及约束项均为线性，而第二项是一个二次项，它可以在多项式复杂度的时间内计算出来。</p><ul><li>步骤2：固定S和w对L进行更新。损失函数可以被重写为：</li></ul><p><img src="https://s1.ax1x.com/2018/07/31/Pdh579.png" alt=""></p><p>&#8194; 此时对L矩阵的求解就是拉普拉斯矩阵（S-IN）对应的C个最大特征值的特征向量。</p><ul><li>步骤三：固定S和L对w进行更新。同样地，损失函数可以被重写为如下形式：</li></ul><p><img src="https://s1.ax1x.com/2018/07/31/Pdh7fx.png" alt=""></p><p>&#8194; 对于这样一个包含凸函数和线性约束的问题，任何一个凸优化算法都可以进行求解。</p><ul><li>步骤四：基于扩散方法的相似度矩阵优化。我们应用了一种扩散方法来减少噪声和dropout现象对S矩阵的影响。给定矩阵S，我们构建如下形式的过渡矩阵P：</li></ul><p><img src="https://s1.ax1x.com/2018/07/31/Pdhjne.png" alt=""></p><p>&#8194; Ak(i)代表一个集合，里面包含了细胞i的k个近邻细胞的索引。构建出来的过渡矩阵是稀疏的，并且保留了极大部分的相似度结构。算法的更新方法如下所示：</p><p><img src="https://s1.ax1x.com/2018/07/31/Pdhq1K.png" alt=""></p><p>&#8194; H(0)ij = Sij作为输入，而最终迭代出来的结果Hij作为新的相似值Sij。这个额外的扩散方法将会很大程度上避免单细胞RNA序列数据中的噪声值所带来的影响。然而，因为这个算法的高计算复杂度，在面对大规模数据集时它无法发挥有效作用。</p><font size="3">  &#8194; SIMLR算法重复步骤1-4直到算法收敛。随后使用得到的相似度矩阵S进行后续分析：</font><h2 id="后续分析"><a href="#后续分析" class="headerlink" title="后续分析"></a>后续分析</h2><h3 id="降维处理："><a href="#降维处理：" class="headerlink" title="降维处理："></a>降维处理：</h3><p>&#8194; 算法基于SNE算法进行降维，并进行了调整。不同点在于，tSNE算法基于高斯核来计算高维度空间下数据之间的相似度，随后将其映射到低维空间并保留这个相似度信息。我们没有选择直接输入基因表达矩阵而是输入了相似度矩阵S。</p><h3 id="可视化："><a href="#可视化：" class="headerlink" title="可视化："></a>可视化：</h3><p>&#8194; 我们使用降维算法来投影到二维或三维空间进行可视化。如k-means聚类，我们将维度降到B维，得到一个N×B相应的矩阵Z，随后应用k-means算法来对于细胞进行聚类。B的值与输入的C的值相同。C同时也是上文提到的秩约束的参数。</p><h3 id="基于相似度矩阵的基因排序："><a href="#基于相似度矩阵的基因排序：" class="headerlink" title="基于相似度矩阵的基因排序："></a>基于相似度矩阵的基因排序：</h3><p>&#8194; 我们通过计算某个基因在不同细胞中表达的值与习得的相似度的相关程度来对基因进行排序。给定相似度矩阵S和某个基因在所有细胞中的表达结果f，表达式如下：</p><p><img src="https://s1.ax1x.com/2018/07/31/PdhL6O.png" alt=""></p><p>&#8194; 这是一个经典的用来衡量基因和相似度之间相关性的无监督特征排序算法。表达式的值越高，则基因在不同细胞中的表达越重要。然而，表达式对相似度矩阵中的噪声值非常敏感。为了克服这个问题，我们随机选取一定比例的细胞（如细胞总数的80%），随后根据剩余细胞的相似度矩阵来对基因进行排序。</p><h3 id="大规模数据集上的应用："><a href="#大规模数据集上的应用：" class="headerlink" title="大规模数据集上的应用："></a>大规模数据集上的应用：</h3><p>&#8194; 我们在含有数万个细胞的数据集上进行了试验，关键因素在于用KNN相似度来近似于细胞的相似度。第一步，我们采用了目前更为先进的近邻搜索算法<a href="https://github.com/spotify/annoy" target="_blank" rel="noopener">ANNOY</a>，ANNOY算法认为，一个近邻点的近邻也可能是一个近邻点。因此，在构建出KNN图后，算法只更新每个细胞所预先选定的前k个近邻点。因为得到的相似度矩阵是稀疏的，我们使用<a href="http://yixuan.cos.name/spectra/" target="_blank" rel="noopener">Spectra</a>来对L进行求解。当我们按照这种方式而不是进行涉及到矩阵求逆运算的闭式求解，我们只需要在有限次的迭代中就可以得到一个结果。</p><p>&#8194; 在我们得到相似度矩阵后，我们就可以进行细胞可视化和细胞聚类了。聚类时，从t-SNE算法中获得嵌入的低维空间的过程的计算量很大。相反，我们采用了一种谱聚类算法，它基本上等同于我们的SIMLR算法中对矩阵L应用k均值。这种简单的算法对稀疏相似性的聚类非常有效，并可扩展到数以万计的细胞中。对于可视化，由于我们仅将细胞到细胞的相似性映射到二维或三维空间，因此应用t-SNE算法在计算上仍是可行的。我们对tSNE算法中的Barnes–Hut算法进行了调整。</p><h2 id="数据来源"><a href="#数据来源" class="headerlink" title="数据来源"></a>数据来源</h2><p>&#8194; 我们在本文中使用了七个单细胞RNA-seq的数据集。前四个数据集每个包含少于1,000个细胞，而最后三个数据集包含数千到数万个细胞。下面是所有单细胞RNA-seq数据集的详细描述。</p><p>&#8194;（1）11个细胞群，包括神经细胞和血细胞（Pollen数据集）。该数据集旨在测试低覆盖率单细胞RNA-seq在鉴别不同细胞群体方面的效用，因此含有多种细胞类型的混合物：皮肤细胞，多能干细胞，血细胞和神经细胞。该数据集包括在高深度和低深度处测序的样本。我们分析了高深度样本，每个样本的平均测序数为890万。</p><p>&#8194; （2）具有感觉亚型的神经元细胞（Usoskin数据集）。该数据集包含来自小鼠背根神经节的622个细胞，每个细胞平均有114万个读段。作者将细胞分为四种神经元类型：肽能伤害性伤害感受器，非肽能伤害性伤害感受器，含神经丝，含酪氨酸羟化酶。</p><p>&#8194; （3）不同细胞周期阶段的胚胎干细胞（Buettner数据集）。该数据集来自对照研究，该对照研究量化了细胞周期对个体小鼠胚胎干细胞（mESC）中基因表达水平的影响。对于182个细胞中的每一个细胞，获得平均五十万个读数，并且至少20％的读数被定位于mm9小鼠基因组上的已知外显子。使用荧光激活细胞分选将细胞分选为细胞周期的三个阶段，并且使用金标准Hoechst染色对它们进行验证。</p><p>&#8194; （4）不同环境条件下的多能细胞（Kolodziejczyk数据集）。该数据集是从干细胞研究中获得的，研究不同培养条件如何影响mESC的多能状态。该研究从涉及三种不同培养条件的九个不同实验中量化了704个mESC中约10,000个基因的表达水平。每个细胞平均获得900万个读数，超过60％的读数映射到小家鼠基因组上的外显子。</p><p>&#8194; （5）具有39个亚型的小鼠视网膜细胞（Macoskco数据集）。通过基于液滴的高通量技术Drop-seq获得，该数据集包括44,808个单元的UMI（3端）计数（由其定制的计算管道识别）。细胞类型通过PCA和基于密度的聚类进行分类，并且通过差异基因表达进行验证。根据原始处理程序，我们过滤掉少于900个基因的细胞（涉及到11,040个细胞）用于无监督分析。</p><p>&#8194; （6）来自一个健康人类的PBMCs数据集（PBMC68k数据集）。通过GemCode平台生成scRNA-seq文库，这是一种基于液滴的高通量技术，以及具有UMI（3’端）计数的68,560个细胞通过其定制的计算流水线来识别。这种细胞群包括健康人体内的主要免疫细胞类型。</p><p>&#8194; （7）使用独特的分子识别（UMI）分析和3’端计数收集来自小鼠皮质和海马的细胞（Zeisel数据集）。收集来自小鼠脑的3,005个细胞，并且通过分级双聚类鉴定了47个亚型，并通过基因标记进行了验证。</p><p>&#8194;  对于以上涉及到的数据集，我们进行了如下的数据预处理：</p><p><img src="https://s1.ax1x.com/2018/07/31/PdhOXD.png" alt="PdhOXD.png"> </p>]]></content>
    
    <summary type="html">
    
      &lt;font size=&quot;5&quot;&gt;
基于多核函数的单细胞RNA序列分析与可视化算法
&lt;/font&gt;

&lt;p&gt;&amp;#8194; &lt;/p&gt;
&lt;font size=&quot;3&quot;&gt;
摘要：我们将要介绍的SIMLR算法，在理论框架和软件应用上已经实现，它从输入的单细胞RNA序列中学习到一种相似度的信息，随后可以用这种信息来实现降维、聚类和可视化等后续处理。在七个公开的数据集上我们对算法进行了检验并于一些常用的算法进行了比较分析。结果证明了SIMLR算法对大规模数据的良好处理以及极大程度上提高了聚类的效果，同时提升了可视化的效果以及对细胞间相似程度的识别。
&lt;/font&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://Bithub00.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Jupyter Notebook 的快捷键</title>
    <link href="http://Bithub00.com/2018/07/24/jupyter%20notebook%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>http://Bithub00.com/2018/07/24/jupyter notebook快捷键/</id>
    <published>2018-07-24T06:16:20.378Z</published>
    <updated>2018-07-24T06:22:27.766Z</updated>
    
    <content type="html"><![CDATA[<p>Jupyter Notebook 有两种键盘输入模式。编辑模式，允许你往单元中键入代码或文本；这时的单元框线是绿色的。命令模式，键盘输入运行程序命令；这时的单元框线是灰色。<br><a id="more"></a></p><h3 id="命令模式-按键-Esc-开启"><a href="#命令模式-按键-Esc-开启" class="headerlink" title="命令模式 (按键 Esc 开启)"></a>命令模式 (按键 Esc 开启)</h3><ul><li><strong>Enter</strong> : 转入编辑模式</li><li><strong>Shift-Enter</strong> : 运行本单元，选中下个单元</li><li><strong>Ctrl-Enter</strong> : 运行本单元</li><li><strong>Alt-Enter</strong> : 运行本单元，在其下插入新单元</li><li><strong>Y</strong> : 单元转入代码状态</li><li><strong>M</strong> :单元转入markdown状态</li><li><strong>R</strong> : 单元转入raw状态</li><li><strong>1</strong> : 设定 1 级标题</li><li><strong>2</strong> : 设定 2 级标题</li><li><strong>3</strong> : 设定 3 级标题</li><li><strong>4</strong> : 设定 4 级标题</li><li><strong>5</strong> : 设定 5 级标题</li><li><strong>6</strong> : 设定 6 级标题</li><li><strong>Up</strong> : 选中上方单元</li><li><strong>K</strong> : 选中上方单元</li><li><strong>Down</strong> : 选中下方单元</li><li><strong>J</strong> : 选中下方单元</li><li><strong>Shift-K</strong> : 扩大选中上方单元</li><li><strong>Shift-J</strong> : 扩大选中下方单元</li><li><strong>A</strong> : 在上方插入新单元</li><li><strong>B</strong> : 在下方插入新单元</li><li><strong>X</strong> : 剪切选中的单元</li><li><strong>C</strong> : 复制选中的单元</li><li><strong>Shift-V</strong> : 粘贴到上方单元</li><li><strong>V</strong> : 粘贴到下方单元</li><li><strong>Z</strong> : 恢复删除的最后一个单元</li><li><strong>D,D</strong> : 删除选中的单元</li><li><strong>Shift-M</strong> : 合并选中的单元</li><li><strong>Ctrl-S</strong> : 文件存盘</li><li><strong>S</strong> : 文件存盘</li><li><strong>L</strong> : 转换行号</li><li><strong>O</strong> : 转换输出</li><li><strong>Shift-O</strong> : 转换输出滚动</li><li><strong>Esc</strong> : 关闭页面</li><li><strong>Q</strong> : 关闭页面</li><li><strong>H</strong> : 显示快捷键帮助</li><li><strong>I,I</strong> : 中断Notebook内核</li><li><strong>0,0</strong> : 重启Notebook内核</li><li><strong>Shift</strong> : 忽略</li><li><strong>Shift-Space</strong> : 向上滚动</li><li><strong>Space</strong> : 向下滚动</li></ul><h3 id="编辑模式-Enter-键启动"><a href="#编辑模式-Enter-键启动" class="headerlink" title="编辑模式 ( Enter 键启动)"></a>编辑模式 ( Enter 键启动)</h3><ul><li><strong>Tab</strong> : 代码补全或缩进</li><li><strong>Shift-Tab</strong> : 提示</li><li><strong>Ctrl-]</strong> : 缩进</li><li><strong>Ctrl-[</strong> : 解除缩进</li><li><strong>Ctrl-A</strong> : 全选</li><li><strong>Ctrl-Z</strong> : 复原</li><li><strong>Ctrl-Shift-Z</strong> : 再做</li><li><strong>Ctrl-Y</strong> : 再做</li><li><strong>Ctrl-Home</strong> : 跳到单元开头</li><li><strong>Ctrl-Up</strong> : 跳到单元开头</li><li><strong>Ctrl-End</strong> : 跳到单元末尾</li><li><strong>Ctrl-Down</strong> : 跳到单元末尾</li><li><strong>Ctrl-Left</strong> : 跳到左边一个字首</li><li><strong>Ctrl-Right</strong> : 跳到右边一个字首</li><li><strong>Ctrl-Backspace</strong> : 删除前面一个字</li><li><strong>Ctrl-Delete</strong> : 删除后面一个字</li><li><strong>Esc</strong> : 进入命令模式</li><li><strong>Ctrl-M</strong> : 进入命令模式</li><li><strong>Shift-Enter</strong> : 运行本单元，选中下一单元</li><li><strong>Ctrl-Enter</strong> : 运行本单元</li><li><strong>Alt-Enter</strong> : 运行本单元，在下面插入一单元</li><li><strong>Ctrl-Shift—</strong> : 分割单元</li><li><strong>Ctrl-Shift-Subtract</strong> : 分割单元</li><li><strong>Ctrl-S</strong> : 文件存盘</li><li><strong>Shift</strong> : 忽略</li><li><strong>Up</strong> : 光标上移或转入上一单元</li><li><strong>Down</strong> :光标下移或转入下一单元</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Jupyter Notebook 有两种键盘输入模式。编辑模式，允许你往单元中键入代码或文本；这时的单元框线是绿色的。命令模式，键盘输入运行程序命令；这时的单元框线是灰色。&lt;br&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://Bithub00.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>VPN</title>
    <link href="http://Bithub00.com/2018/04/06/vpn/"/>
    <id>http://Bithub00.com/2018/04/06/vpn/</id>
    <published>2018-04-06T11:58:10.712Z</published>
    <updated>2019-08-07T07:59:44.374Z</updated>
    
    <content type="html"><![CDATA[<font size="5">edu.cn的学校邮箱+5美元 = 11个月的境外服务器</font><h3 id="领取github的vps优惠码"><a href="#领取github的vps优惠码" class="headerlink" title="领取github的vps优惠码"></a>领取github的vps优惠码</h3><a id="more"></a><ul><li>教程<br><a href="https://www.ichenfei.com/get-github-students-gift.html" target="_blank" rel="noopener">https://www.ichenfei.com/get-github-students-gift.html</a></li><li>领取优惠码页面<br><a href="https://education.github.com/pack/offers#digitalocean" target="_blank" rel="noopener">https://education.github.com/pack/offers#digitalocean</a></li><li><p>vps开通页面(需要翻墙，学校使用ipv6地址可以直接翻出去)<br><a href="https://www.digitalocean.com/" target="_blank" rel="noopener">https://www.digitalocean.com/</a><br>不要使用一次性邮箱注册账号，因为以后每次登陆都要邮箱验证</p></li><li><p>登陆页面<br><a href="https://cloud.digitalocean.com/login" target="_blank" rel="noopener">https://cloud.digitalocean.com/login</a> (建议翻墙访问)</p></li><li><p>注册paypal账号来支付<br><a href="https://www.paypal.com/c2/home" target="_blank" rel="noopener">https://www.paypal.com/c2/home</a></p><!--more--><p>paypal绑定了银行卡和手机，建议用不常用的银行卡，然后充35块钱进去<br>支付成功后，激活digitalocean账号，填入github的优惠卷，获得50美元</p></li></ul><h3 id="创建自己的服务器"><a href="#创建自己的服务器" class="headerlink" title="创建自己的服务器"></a>创建自己的服务器</h3><p>建议选SFO一区的服务器，不容易被墙，配置的话5美元那种就差不多了，服务器型号建议ubuntu</p><h3 id="连接服务器"><a href="#连接服务器" class="headerlink" title="连接服务器"></a>连接服务器</h3><p>通过console连上服务器后，使用秋水逸冰大大的命令一键安装:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget --no-check-certificate -O shadowsocks-all.sh https:<span class="comment">//raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-all.sh</span></span><br><span class="line"></span><br><span class="line">chmod +x shadowsocks-all.sh &amp;&amp; ./shadowsocks-all.sh <span class="number">2</span>&gt;&amp;<span class="number">1</span> | tee shadowsocks-all.<span class="built_in">log</span></span><br></pre></td></tr></table></figure></p><font size="4">探索新世界吧:)</font>]]></content>
    
    <summary type="html">
    
      &lt;font size=&quot;5&quot;&gt;edu.cn的学校邮箱+5美元 = 11个月的境外服务器&lt;/font&gt;

&lt;h3 id=&quot;领取github的vps优惠码&quot;&gt;&lt;a href=&quot;#领取github的vps优惠码&quot; class=&quot;headerlink&quot; title=&quot;领取github的vps优惠码&quot;&gt;&lt;/a&gt;领取github的vps优惠码&lt;/h3&gt;
    
    </summary>
    
    
      <category term="vpn" scheme="http://Bithub00.com/tags/vpn/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://Bithub00.com/2018/04/05/hello-world/"/>
    <id>http://Bithub00.com/2018/04/05/hello-world/</id>
    <published>2018-04-05T14:57:07.298Z</published>
    <updated>2019-08-07T08:05:31.440Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;Quick Start&quot;&gt;&lt;/a&gt;Quick Start&lt;/h2&gt;&lt;h3 id=&quot;Create-a-new-post&quot;&gt;&lt;a href=&quot;#Create-a-new-post&quot; class=&quot;headerlink&quot; title=&quot;Create a new post&quot;&gt;&lt;/a&gt;Create a new post&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo new &lt;span class=&quot;string&quot;&gt;&quot;My New Post&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
